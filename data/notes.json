[
  {
    "id": "1764955646088-5pfk5aqqn",
    "scriptId": "1764951215001-x5otld1ik",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Technische Grundlagen der Informatik – Lernnotizen zur Probeklausur\n\nKurzer Überblick:  \nSchwerpunkt auf Rechenwerk-Entwicklung, Zahlendarstellung, Boolescher Algebra, KV-Diagrammen und Addierwerken.\n\n---\n\n## 1. Mooresches Gesetz und physikalische Grenzen\n\n### Mooresches Gesetz\n*Definition:*  \nDie Anzahl der Transistoren auf einem Chip (und damit die Rechenleistung) verdoppelt sich ungefähr alle $18$–$24$ Monate.\n\n### Aktuelle Herausforderungen / physikalische Grenzen\n\n- **Leckströme und Miniaturisierung**\n  - Immer kleinere Strukturbreiten $\\Rightarrow$ stärkere **Leckströme**\n  - Transistoren lassen sich nicht beliebig verkleinern (atomare/quanteneffekte)\n\n- **Leistungsdichte und Kühlung**\n  - Leistungsaufnahme: $P \\approx C \\cdot U^2 \\cdot f$\n  - Erhöhte Taktfrequenz $f$ und Transistoranzahl $\\Rightarrow$ mehr Wärme\n  - Kühlung und Energieversorgung werden zum Engpass\n\n- **Taktfrequenzgrenze**\n  - Signal-Laufzeiten auf dem Chip (Ausbreitungsgeschwindigkeit, RC-Verzögerungen)\n  - Synchronisation über große Chipflächen wird schwierig\n\n- **Variabilität und Fertigungstoleranzen**\n  - Schwankungen bei Transistoreigenschaften bei sehr kleinen Strukturen\n  - Zuverlässigkeit und Fehlerraten steigen\n\n- **Kosten**\n  - Exponentiell steigende Kosten für neue Fertigungstechnologien und Fabriken\n\n**Merksatz:**  \n**Moore** prognostiziert exponentielles Wachstum, **Physik** (Leistung, Wärme, Quanten- und Materialgrenzen) bremst dieses Wachstum zunehmend aus.\n\n---\n\n## 2. Gajski-Kuhn-Y-Diagramm\n\n### Grundidee\n*Definition:*  \nDas **Gajski-Kuhn-Y-Diagramm** beschreibt den *Entwurfsraum* eines Systems entlang **drei Achsen** (Domänen) und auf **mehreren Abstraktionsebenen**.\n\n### Drei grundlegende Eigenschaften\n\n1. **Drei Entwurfsdomänen (Y-Achsen)**\n   - **Verhaltensdomäne** (*Behavioral*):\n     - Was soll das System tun?\n     - Beschreibung z.B. durch Algorithmen, Zustandsautomaten\n   - **Strukturdomaine** (*Structural*):\n     - Wie ist das System aufgebaut?\n     - Komponenten und deren Verbindungen (Register, ALU, Busse)\n   - **Physische Domäne** (*Physical / Geometrical*):\n     - Wie wird es realisiert?\n     - Layout, Platzierung, Verdrahtung auf dem Chip/Platine\n\n2. **Abstraktionsebenen (konzentrische Schichten)**\n   Typische Ebenen (von grob nach fein):\n   - Systemebene\n   - Architektur-/Register-Transfer-Ebene (RT-Ebene)\n   - Logikebene\n   - Schaltkreisebene\n   - Layout-/Transistorebene  \n   Jede Ebene kann in allen drei Domänen beschrieben werden.\n\n3. **Zusammenhang / Projektion**\n   - Jede **Punktposition** im Diagramm beschreibt ein System\n     - z.B. Verhalten auf RT-Ebene, Struktur auf Logikebene, physisches Layout\n   - Entwurfsschritte sind **Projektionen** zwischen Domänen und Ebenen:\n     - Verhaltensbeschreibung $\\Rightarrow$ strukturelle Realisierung\n     - Struktur $\\Rightarrow$ physische Implementierung\n\n**Merksatz:**  \nDas Y-Diagramm verbindet **Verhalten**, **Struktur** und **physische Realisierung** eines Systems über mehrere **Abstraktionsebenen**.\n\n---\n\n## 3. Horner-Schema zur Basis-Umwandlung\n\n### Grundprinzip\n\n*Aufgabe:*  \nWandlung einer Zahl $n$ in Basis $b$ in eine Dezimalzahl.\n\nEine Zahl in Basis $b$ mit Ziffern $a_k a_{k-1} \\dots a_1 a_0$ bedeutet:\n$$\nn = a_k b^k + a_{k-1} b^{k-1} + \\dots + a_1 b^1 + a_0 b^0\n$$\n\n**Horner-Schema (verschachtelte Form):**\n$$\nn = (\\dots((a_k \\cdot b + a_{k-1}) \\cdot b + a_{k-2}) \\cdot b + \\dots + a_0\n$$\n\n### Beispiel: $(1258)_8$\n\nZiffern: $1, 2, 5, 8$ in Basis $b = 8$\n\nBerechnung nach Horner:\n1. Start: $r_0 = 1$\n2. $r_1 = r_0 \\cdot 8 + 2 = 1 \\cdot 8 + 2 = 10$\n3. $r_2 = r_1 \\cdot 8 + 5 = 10 \\cdot 8 + 5 = 80 + 5 = 85$\n4. $r_3 = r_2 \\cdot 8 + 8 = 85 \\cdot 8 + 8 = 680 + 8 = 688$\n\nErgebnis:\n$$\n(1258)_8 = 688_{10}\n$$\n\n**Merksatz:**  \nBeim **Horner-Schema** wird von links nach rechts iterativ mit der Basis multipliziert und die nächste Ziffer addiert.\n\n---\n\n## 4. Festkommazahlen (Fixed-Point) in Binärdarstellung\n\n### Allgemeines Modell\n\nEine $n$-Bit-Festkommazahl mit\n- $1$ Vorzeichenbit $s$\n- $k$ Vorkommabits\n- $j$ Nachkommabits  \n\nhat die Form:\n$$\nx = (-1)^s \\cdot \\left( \\sum_{i=0}^{k-1} b_i \\cdot 2^i + \\sum_{m=1}^{j} b_{-m} \\cdot 2^{-m} \\right)\n$$\nmit $b_i \\in \\{0,1\\}$.\n\n- $s = 0$: Zahl ist positiv\n- $s = 1$: Zahl ist negativ (i.d.R. Zweierkomplement)\n\n### Vorgehen zur Umwandlung\n\n1. **Vorzeichen prüfen:**  \n   - $s = 0 \\Rightarrow$ direkt umrechnen  \n   - $s = 1 \\Rightarrow$ Zweierkomplement bilden, Betrag berechnen, dann negatives Vorzeichen\n\n2. **Binärzahl in Ganzzahl umrechnen**  \n   - Bits links vom Komma: Gewicht $2^i$\n   - Bits rechts vom Komma: Gewicht $2^{-m}$\n\n3. **Dezimalwert berechnen**  \n   - Summe der gewichteten Bits bilden\n   - Vorzeichen anwenden\n\n### Beispiel (schematisch, da konkrete Zahl fehlt)\n\nAngenommen: $n = 16$, $k = 13$, $j = 2$, Binärzahl:\n$$\ns~b_{12}b_{11}\\dots b_1b_0, b_{-1}b_{-2}\n$$\n\n1. **Vorzeichen:**  \n   z.B. $s = 0 \\Rightarrow$ positiv\n\n2. **Wert:**\n$$\nx = \\sum_{i=0}^{12} b_i \\cdot 2^i + b_{-1}\\cdot 2^{-1} + b_{-2}\\cdot 2^{-2}\n$$\n\n3. **Dezimalzahl:**  \n   Gewichte berechnen und aufsummieren.\n\n**Merksatz:**  \nFestkommazahlen sind wie Ganzzahlen, nur mit einem **festen Kommapunkt** zwischen Vorkomma- und Nachkommabits.\n\n---\n\n## 5. Boolesche Algebra – Vereinfachung von Ausdrücken\n\n### Wichtige Axiome und Theoreme\n\n- **Idempotenz:**\n  - $x + x = x$\n  - $x \\cdot x = x$\n\n- **Null- und Eins-Gesetze:**\n  - $x + 0 = x$\n  - $x \\cdot 1 = x$\n  - $x + 1 = 1$\n  - $x \\cdot 0 = 0$\n\n- **Komplementärgesetze:**\n  - $x + \\bar{x} = 1$\n  - $x \\cdot \\bar{x} = 0$\n\n- **Assoziativität:**\n  - $(x + y) + z = x + (y + z)$\n  - $(x \\cdot y) \\cdot z = x \\cdot (y \\cdot z)$\n\n- **Kommutativität:**\n  - $x + y = y + x$\n  - $x \\cdot y = y \\cdot x$\n\n- **Distributivität:**\n  - $x \\cdot (y + z) = x\\cdot y + x\\cdot z$\n  - $x + y\\cdot z = (x + y)\\cdot(x + z)$\n\n- **Absorptionsgesetze:**\n  - $x + x\\cdot y = x$\n  - $x \\cdot (x + y) = x$\n\n- **De-Morgan:**\n  - $\\overline{x\\cdot y} = \\bar{x} + \\bar{y}$\n  - $\\overline{x + y} = \\bar{x}\\cdot \\bar{y}$\n\n### Beispiel einer Vereinfachung (allgemein)\n\nGegeben:\n$$\ny = x\\cdot z + x\\cdot \\bar{z}\n$$\n\nSchritte:\n1. Faktorisieren (Distributivität):\n   $$\n   y = x\\cdot (z + \\bar{z})\n   $$\n2. Komplementärgesetz:\n   $$\n   z + \\bar{z} = 1\n   $$\n3. Eins-Gesetz:\n   $$\n   y = x\\cdot 1 = x\n   $$\n\n**Merksatz:**  \nBei Vereinfachungen immer nach **gemeinsamen Faktoren** suchen und **Absorptions- sowie Komplementärgesetze** ausnutzen.\n\n---\n\n## 6. KV-Diagramm, Primimplikanten und DMF\n\n### Wahrheitstabelle (gegeben)\n\n| $x_2$ | $x_1$ | $x_0$ | $y$ |\n|:-----:|:-----:|:-----:|:---:|\n| 0     | 0     | 0     | 0   |\n| 0     | 0     | 1     | 0   |\n| 0     | 1     | 0     | 1   |\n| 0     | 1     | 1     | 0   |\n| 1     | 0     | 0     | 1   |\n| 1     | 0     | 1     | 1   |\n| 1     | 1     | 0     | 1   |\n| 1     | 1     | 1     | 1   |\n\nMinterme mit $y=1$:\n- $m_2$: $(x_2,x_1,x_0) = (0,1,0)$\n- $m_4$: $(1,0,0)$\n- $m_5$: $(1,0,1)$\n- $m_6$: $(1,1,0)$\n- $m_7$: $(1,1,1)$\n\n### KV-Diagramm (3 Variablen)\n\nAnordnung (Gray-Code in $x_1x_0$):\n\n| $x_2 \\backslash x_1x_0$ | 00 | 01 | 11 | 10 |\n|-------------------------|:--:|:--:|:--:|:--:|\n| 0                       |  0 |  0 |  0 |  1 |\n| 1                       |  1 |  1 |  1 |  1 |\n\n(Merkpunkt: $x_1x_0 = 10$ entspricht $m_2$ etc.)\n\n### Primimplikanten (größtmögliche Blöcke)\n\n- **Block 1**: Alle $1$ in Zeile $x_2 = 1$ (vier Felder)\n  - Bedingung: $x_2 = 1$  \n  - Implikant: $x_2$\n\n- **Block 2**: Spalte $x_1x_0 = 10$ (zwei Felder: $m_2$ und $m_6$)\n  - Bedingung: $x_1 = 1$, $x_0 = 0$  \n  - Implikant: $x_1 \\cdot \\bar{x}_0$\n\n### Disjunktive Minimalform (DMF)\n\nAlle $1$-Zellen abdecken:\n\n- $x_2$ deckt: $m_4, m_5, m_6, m_7$\n- $x_1\\bar{x}_0$ deckt: $m_2, m_6$\n\nDamit:\n$$\ny = x_2 + x_1\\cdot \\bar{x}_0\n$$\n\n### Logikschaltung gemäß DMF (DIN 40900)\n\n- **Eingänge:** $x_2, x_1, x_0$\n- **Bausteine:**\n  - 1× **NOT-Gatter**: bildet $\\bar{x}_0$\n  - 1× **AND-Gatter**: Eingang $x_1$ und $\\bar{x}_0$ $\\Rightarrow$ $x_1\\bar{x}_0$\n  - 1× **OR-Gatter**: Eingänge $x_2$ und $x_1\\bar{x}_0$ $\\Rightarrow$ Ausgang $y$\n\nStruktur:\n1. $x_0 \\rightarrow$ NOT $\\rightarrow \\bar{x}_0$\n2. $x_1$ und $\\bar{x}_0 \\rightarrow$ AND $\\rightarrow x_1\\bar{x}_0$\n3. $x_2$ und $x_1\\bar{x}_0 \\rightarrow$ OR $\\rightarrow y$\n\n**Merksatz:**  \nIm KV-Diagramm immer **größtmögliche 2er-Potenzen** (1,2,4,8,…) gruppieren, um eine minimale **ODER-von-UND**-Form zu erhalten.\n\n---\n\n## 7. Addierwerke mit Volladdierern\n\n### Volladdierer (Grundbaustein)\n\n*Definition:*  \nEin **Volladdierer** addiert zwei Eingangsbits $a$, $b$ und einen Übertrag $c_{in}$:\n- Summe: $s$\n- Übertrag: $c_{out}$\n\nFunktionen:\n$$\ns = a \\oplus b \\oplus c_{in}\n$$\n$$\nc_{out} = a\\cdot b + c_{in}\\cdot (a \\oplus b)\n$$\n\n### Typische Addierwerke\n\n#### Addierwerk 1: Ripple-Carry-Addierer (serieller Übertrag)\n\n- $n$ Volladdierer in Reihe\n- $c_{out}$ eines Volladdierers $\\rightarrow c_{in}$ des nächsten\n\n**Eigenschaften:**\n- **Vorteile:**\n  - Einfache Struktur\n  - Geringe Hardwarekosten\n  - Leicht zu verstehen und zu implementieren\n- **Nachteile:**\n  - Additionszeit wächst linear mit Bitbreite:  \n    $$t_{add} \\approx n \\cdot t_{FA}$$\n  - Für große Wortbreiten sehr langsam\n\n#### Addierwerk 2: Carry-Lookahead-Addierer (schneller Übertrag)\n\n- Verwendet **Generate**- und **Propagate**-Signale:\n  - $g_i = a_i \\cdot b_i$  (Generate)\n  - $p_i = a_i \\oplus b_i$ (Propagate)\n- Überträge werden **parallel** berechnet:\n  - $c_1 = g_0 + p_0 \\cdot c_0$\n  - $c_2 = g_1 + p_1 \\cdot c_1$ usw.  \n  (mit weiterer Parallelisierung)\n\n**Eigenschaften:**\n- **Vorteile:**\n  - Deutlich schnellere Addition\n  - Übertragsberechnung in $O(\\log n)$ möglich\n- **Nachteile:**\n  - Höherer Schaltungsaufwand (mehr Gatter, komplexere Logik)\n  - Größerer Flächen- und Energiebedarf\n\n### Vergleich – Vor- und Nachteile\n\n| Addierwerk            | Vorteile                                | Nachteile                                  |\n|-----------------------|------------------------------------------|--------------------------------------------|\n| Ripple-Carry          | Einfach, wenig Hardware                  | Langsam, Laufzeit $\\propto$ Bitbreite      |\n| Carry-Lookahead u.ä.  | Sehr schnell, geeignet für große Breiten | Komplex, hoher Flächen- und Energiebedarf  |\n\n**Merksatz:**  \n**Ripple-Carry** ist **einfach aber langsam**, **Carry-Lookahead** ist **schnell aber komplex**.\n\n---\n\n## Kompakte Merksätze (Zusammenfassung)\n\n- **Moore vs. Physik:**  \n  Mehr Transistoren sind möglich, aber **Leistung, Wärme und Quanten-Effekte** begrenzen die Entwicklung.\n\n- **Y-Diagramm:**  \n  Drei Domänen (**Verhalten, Struktur, Physik**) und mehrere **Abstraktionsebenen** beschreiben den gesamten Systementwurf.\n\n- **Horner-Schema:**  \n  Iterativ: **Ergebnis mit Basis multiplizieren und nächste Ziffer addieren**.\n\n- **Festkomma:**  \n  Fester Kommapunkt; Vorzeichen separat; Bits links/rechts vom Komma haben Gewichte $2^i$ bzw. $2^{-m}$.\n\n- **Boolesche Vereinfachung:**  \n  Nutze v.a. **Distributivität, Absorption und Komplementärgesetze**.\n\n- **KV-Diagramm:**  \n  Gruppiere $1$en in **größtmöglichen 2er-Potenzen**; daraus direkt die **DMF** ablesen.\n\n- **Addierwerke:**  \n  **Ripple-Carry**: billig, langsam – **Carry-Lookahead**: teuer, schnell.",
    "generatedAt": "2025-12-05T17:27:26.088Z"
  },
  {
    "id": "1764955684551-47tr8r4x4",
    "scriptId": "1764951172126-td7oknkzj",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Minimierung boolescher Funktionen mit dem Quine–McCluskey-Verfahren\n\n## Überblick\n\nThema: **Minimierung einer booleschen Funktion** der Variablen $x_3, x_2, x_1, x_0$ mit dem **Quine–McCluskey-Verfahren**.\n\nZiel:\n- Bestimmung der **Primimplikanten**\n- Aufbau der **Primimplikantentafel**\n- Bestimmung der **disjunktiven Minimalform** (DNF)\n\n---\n\n## 1. Kernkonzepte\n\n### Boolesche Funktion und Minterme\n\n- *Boolesche Funktion*: $f : \\{0,1\\}^n \\to \\{0,1\\}$\n- *Minterm*: Produktterm (AND-Verknüpfung), in dem **jede Variable genau einmal** vorkommt (ggf. negiert), z.B.  \n  $$m = \\bar{x}_3 x_2 x_1 \\bar{x}_0$$\n- In der Wertetabelle entspricht **jeder Zeile** ein Minterm (Index = Binärwert der Eingabe).\n\n### Disjunktive Normalform (DNF)\n\n- *Disjunktive Normalform*:  \n  $$f = \\bigvee \\text{(Minterme, für die } f = 1 \\text{ ist)}$$\n- *Disjunktive Minimalform*: DNF mit **minimaler Anzahl** und **minimaler Länge** von Produkttermen.\n\n### Primimplikant\n\n- *Implikant*: Produktterm, der **nur solche Minterme überdeckt**, für die $f=1$ ist.\n- *Primimplikant*: Implikant, der **nicht weiter verallgemeinert** (vereinfacht) werden kann, ohne Minterme mit $f=0$ zu überdecken.\n\n---\n\n## 2. Gegebene Funktion\n\n### Wertetabelle\n\n| Index | $x_3$ | $x_2$ | $x_1$ | $x_0$ | $y$ |\n|-------|-------|-------|-------|-------|-----|\n| 0     | 0     | 0     | 0     | 0     | 0   |\n| 1     | 0     | 0     | 0     | 1     | 1   |\n| 2     | 0     | 0     | 1     | 0     | 1   |\n| 3     | 0     | 0     | 1     | 1     | 1   |\n| 4     | 0     | 1     | 0     | 0     | 0   |\n| 5     | 0     | 1     | 0     | 1     | 0   |\n| 6     | 0     | 1     | 1     | 0     | 1   |\n| 7     | 0     | 1     | 1     | 1     | 1   |\n| 8     | 1     | 0     | 0     | 0     | 1   |\n| 9     | 1     | 0     | 0     | 1     | 1   |\n| 10    | 1     | 0     | 1     | 0     | 0   |\n| 11    | 1     | 0     | 1     | 1     | 0   |\n| 12    | 1     | 1     | 0     | 0     | 0   |\n| 13    | 1     | 1     | 0     | 1     | 0   |\n| 14    | 1     | 1     | 1     | 0     | 0   |\n| 15    | 1     | 1     | 1     | 1     | 1   |\n\n### Minterme mit $y=1$\n\nDie Funktion ist $1$ für folgende Indizes (Minterme):\n\n$$\nM = \\{1, 2, 3, 6, 7, 8, 9, 15\\}\n$$\n\n---\n\n## 3. Quine–McCluskey: Bestimmung der Primimplikanten\n\n### 3.1 Implikanten 0. Ordnung (Minterme)\n\nWir starten mit allen Mintermen (0. Ordnung):\n\n| Index | $x_3$ | $x_2$ | $x_1$ | $x_0$ |\n|-------|-------|-------|-------|-------|\n| 1     | 0     | 0     | 0     | 1     |\n| 2     | 0     | 0     | 1     | 0     |\n| 3     | 0     | 0     | 1     | 1     |\n| 6     | 0     | 1     | 1     | 0     |\n| 7     | 0     | 1     | 1     | 1     |\n| 8     | 1     | 0     | 0     | 0     |\n| 9     | 1     | 0     | 0     | 1     |\n| 15    | 1     | 1     | 1     | 1     |\n\n### 3.2 Implikanten 1. Ordnung\n\nZiel: **Paarweise Kombination** von Mintermen, die sich in **genau einem Bit** unterscheiden. Dieses Bit wird zu einem **„-“** (Don’t-Care).\n\nBeispiele der Kombination:\n\n- $1: 0001$ und $3: 0011$  \n  $$\\Rightarrow 1,3 : 00-1$$\n- $1: 0001$ und $9: 1001$  \n  $$\\Rightarrow 1,9 : -001$$\n- $2: 0010$ und $3: 0011$  \n  $$\\Rightarrow 2,3 : 001-$$\n- $2: 0010$ und $6: 0110$  \n  $$\\Rightarrow 2,6 : 0-10$$\n- $3: 0011$ und $7: 0111$  \n  $$\\Rightarrow 3,7 : 0-11$$\n- $6: 0110$ und $7: 0111$  \n  $$\\Rightarrow 6,7 : 011-$$\n- $7: 0111$ und $15: 1111$  \n  $$\\Rightarrow 7,15 : -111$$\n- $8: 1000$ und $9: 1001$  \n  $$\\Rightarrow 8,9 : 100-$$\n\nMarkierung: Die mit ✓ gekennzeichneten Terme lassen sich **nicht weiter** zu 2. Ordnung kombinieren oder werden später als Primimplikanten erkannt.\n\n| Indizes | $x_3$ | $x_2$ | $x_1$ | $x_0$ | Bemerkung |\n|---------|-------|-------|-------|-------|-----------|\n| 1, 3    | 0     | 0     | –     | 1     | ✓         |\n| 1, 9    | –     | 0     | 0     | 1     | ✓         |\n| 2, 3    | 0     | 0     | 1     | –     | →         |\n| 2, 6    | 0     | –     | 1     | 0     | →         |\n| 3, 7    | 0     | –     | 1     | 1     | →         |\n| 6, 7    | 0     | 1     | 1     | –     | →         |\n| 7, 15   | –     | 1     | 1     | 1     | ✓         |\n| 8, 9    | 1     | 0     | 0     | –     | ✓         |\n\n### 3.3 Implikanten 2. Ordnung\n\nNun kombinieren wir 1.-Ordnung-Implikanten, die sich wieder nur in **einem Bit** unterscheiden:\n\n- Kombination von $2,3 : 001-$ mit $6,7 : 011-$  \n  $$\\Rightarrow 2,3,6,7 : 0-1-$$\n\nDieser Term kann nicht weiter kombiniert werden → **Primimplikant**.\n\n| Indizes      | $x_3$ | $x_2$ | $x_1$ | $x_0$ | Bemerkung |\n|--------------|-------|-------|-------|-------|-----------|\n| 2,3,6,7      | 0     | –     | 1     | –     | ✓         |\n\n### 3.4 Liste der Primimplikanten (symbolisch)\n\nWir interpretieren „–“ als **Don’t-Care** und übersetzen in Produktterme:\n\n1. $2,3,6,7 : 0-1-$  \n   - $x_3 = 0 \\Rightarrow \\bar{x}_3$  \n   - $x_2$ egal  \n   - $x_1 = 1$  \n   - $x_0$ egal  \n   $$\\Rightarrow \\bar{x}_3 x_1$$\n\n2. $1,3 : 00-1$  \n   - $x_3 = 0 \\Rightarrow \\bar{x}_3$  \n   - $x_2 = 0 \\Rightarrow \\bar{x}_2$  \n   - $x_1$ egal  \n   - $x_0 = 1$  \n   $$\\Rightarrow \\bar{x}_3 \\bar{x}_2 x_0$$\n\n3. $1,9 : -001$  \n   - $x_3$ egal  \n   - $x_2 = 0 \\Rightarrow \\bar{x}_2$  \n   - $x_1 = 0 \\Rightarrow \\bar{x}_1$  \n   - $x_0 = 1$  \n   $$\\Rightarrow \\bar{x}_2 \\bar{x}_1 x_0$$\n\n4. $7,15 : -111$  \n   - $x_3$ egal  \n   - $x_2 = 1$  \n   - $x_1 = 1$  \n   - $x_0 = 1$  \n   $$\\Rightarrow x_2 x_1 x_0$$\n\n5. $8,9 : 100-$  \n   - $x_3 = 1$  \n   - $x_2 = 0 \\Rightarrow \\bar{x}_2$  \n   - $x_1 = 0 \\Rightarrow \\bar{x}_1$  \n   - $x_0$ egal  \n   $$\\Rightarrow x_3 \\bar{x}_2 \\bar{x}_1$$\n\n**Primimplikanten-Menge:**\n$$\n\\{\\;\\bar{x}_3 x_1,\\;\\bar{x}_3 \\bar{x}_2 x_0,\\;\\bar{x}_2 \\bar{x}_1 x_0,\\;x_2 x_1 x_0,\\;x_3 \\bar{x}_2 \\bar{x}_1\\;\\}\n$$\n\n---\n\n## 4. Primimplikantentafel\n\n### 4.1 Vollständige Primimplikantentafel\n\nSpalten: Minterme mit $y=1$  \nZeilen: Primimplikanten, Markierung ● = Minterm wird überdeckt\n\n| Primimplikant               | Form (binär) | 1 | 2 | 3 | 6 | 7 | 8 | 9 | 15 |\n|-----------------------------|--------------|---|---|---|---|---|---|---|----|\n| $2,3,6,7 : \\bar{x}_3 x_1$   | $0-1-$       |   | ● | ● | ● | ● |   |   |    |\n| $1,3 : \\bar{x}_3 \\bar{x}_2 x_0$ | $00-1$  | ● |   | ● |   |   |   |   |    |\n| $1,9 : \\bar{x}_2 \\bar{x}_1 x_0$ | $-001$  | ● |   |   |   |   |   | ● |    |\n| $7,15 : x_2 x_1 x_0$        | $-111$       |   |   |   |   | ● |   |   | ●  |\n| $8,9 : x_3 \\bar{x}_2 \\bar{x}_1$ | $100-$  |   |   |   |   |   | ● | ● |    |\n\n---\n\n## 5. Auswahl der Primimplikanten (Reduktion)\n\n### 5.1 Zwingende (essentielle) Primimplikanten\n\nEin Primimplikant ist *zwingend*, wenn er einen Minterm überdeckt, der von **keinem anderen** Primimplikanten überdeckt wird.\n\nAus der Tafel:\n\n- Minterm $2$ wird **nur** von $\\bar{x}_3 x_1$ überdeckt  \n  → $\\bar{x}_3 x_1$ ist **essentiell**\n- Minterm $3$ wird von $\\bar{x}_3 x_1$ und $\\bar{x}_3 \\bar{x}_2 x_0$ überdeckt  \n  → nicht eindeutig\n- Minterm $6$ wird nur von $\\bar{x}_3 x_1$ überdeckt (bereits enthalten)\n- Minterm $7$ wird von $\\bar{x}_3 x_1$ und $x_2 x_1 x_0$ überdeckt\n- Minterm $8$ wird nur von $x_3 \\bar{x}_2 \\bar{x}_1$ überdeckt  \n  → $x_3 \\bar{x}_2 \\bar{x}_1$ ist **essentiell**\n- Minterm $15$ wird nur von $x_2 x_1 x_0$ überdeckt  \n  → $x_2 x_1 x_0$ ist **essentiell**\n\nDamit haben wir bereits:\n\n$$\nf_{\\text{teil}} = \\bar{x}_3 x_1 \\;\\vee\\; x_3 \\bar{x}_2 \\bar{x}_1 \\;\\vee\\; x_2 x_1 x_0\n$$\n\n### 5.2 Reduzierte Primimplikantentafel\n\nNachdem die essentiellen Primimplikanten gewählt sind, bleiben ggf. noch Minterme übrig. In der angegebenen Folienlösung wird zusätzlich noch\n\n- $1,3 : \\bar{x}_3 \\bar{x}_2 x_0$\n\nals weiterer Primimplikant verwendet (siehe „Reduzierte Primimplikantentafel (0. Iteration)“).\n\nReduzierte Tafel (nur noch relevante Zeile/Spalte):\n\n| Primimplikant                  | 1 |\n|--------------------------------|---|\n| $1,3 : \\bar{x}_3 \\bar{x}_2 x_0$| ● |\n\nDies stellt sicher, dass Minterm $1$ (und damit alle Minterme) abgedeckt sind.\n\n---\n\n## 6. Disjunktive Minimalform\n\nAus der Tafel (Folienlösung) ergibt sich als **disjunktive Minimalform**:\n\n$$\nf(x_3,x_2,x_1,x_0) \n= \\bar{x}_3 x_1 \\;\\vee\\; \\bar{x}_3 \\bar{x}_2 x_0 \\;\\vee\\; x_3 \\bar{x}_2 \\bar{x}_1 \\;\\vee\\; x_2 x_1 x_0\n$$\n\nAlle Terme sind **ODER-verknüpfte Produktterme** (AND), also DNF.\n\n---\n\n## 7. Durchgerechnetes Beispiel (kompakt)\n\n### Schritt 1: Minterme\n\n$$\nM = \\{1,2,3,6,7,8,9,15\\}\n$$\n\n### Schritt 2: Kombination zu 1.-Ordnung-Implikanten\n\nBeispiel:\n- $1(0001)$ und $3(0011) \\Rightarrow 00-1$\n- $8(1000)$ und $9(1001) \\Rightarrow 100-$  \nusw.\n\n### Schritt 3: Kombination zu 2.-Ordnung-Implikanten\n\n- $2,3(001-)$ und $6,7(011-) \\Rightarrow 0-1-$\n\n### Schritt 4: Primimplikanten ablesen\n\n- $0-1- \\Rightarrow \\bar{x}_3 x_1$\n- $00-1 \\Rightarrow \\bar{x}_3 \\bar{x}_2 x_0$\n- $-001 \\Rightarrow \\bar{x}_2 \\bar{x}_1 x_0$\n- $-111 \\Rightarrow x_2 x_1 x_0$\n- $100- \\Rightarrow x_3 \\bar{x}_2 \\bar{x}_1$\n\n### Schritt 5: Primimplikantentafel und Auswahl\n\n- Essentielle Primimplikanten:  \n  $$\\bar{x}_3 x_1,\\; x_3 \\bar{x}_2 \\bar{x}_1,\\; x_2 x_1 x_0$$\n- Ergänzung durch $\\bar{x}_3 \\bar{x}_2 x_0$ zur vollständigen Abdeckung.\n\nErgebnis:\n$$\nf = \\bar{x}_3 x_1 \\;\\vee\\; \\bar{x}_3 \\bar{x}_2 x_0 \\;\\vee\\; x_3 \\bar{x}_2 \\bar{x}_1 \\;\\vee\\; x_2 x_1 x_0\n$$\n\n---\n\n## 8. Merksätze\n\n- **Minterme** sind vollständige Produktterme, die genau **eine Zeile** der Wahrheitstabelle mit $f=1$ beschreiben.\n- Beim **Quine–McCluskey-Verfahren**:\n  - Minterme nach Anzahl der Einsen gruppieren.\n  - Nur Terme kombinieren, die sich in **genau einem Bit** unterscheiden.\n  - Kombinierte Terme erhalten ein „–“ an der Stelle des Unterschieds.\n- **Primimplikanten** sind die Implikanten, die **nicht weiter kombinierbar** sind.\n- In der **Primimplikantentafel**:\n  - ● markieren, wo ein Primimplikant einen Minterm überdeckt.\n  - Minterme, die nur von **einem** Primimplikanten überdeckt werden, machen diesen zu einem **essentiellen Primimplikanten**.\n- Die **disjunktive Minimalform** ist die ODER-Verknüpfung der ausgewählten (essentiellen + ggf. zusätzlichen) Primimplikanten.",
    "generatedAt": "2025-12-05T17:28:04.551Z"
  },
  {
    "id": "1764955718994-yo4nofqgx",
    "scriptId": "1764951169925-xipqgg3z3",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Minimierung von Schaltfunktionen für eine Sieben-Segment-Anzeige\n\n## Überblick\n\n- Thema: **Entwurf und Minimierung** von Schaltfunktionen zur Ansteuerung einer **Sieben-Segment-Anzeige**.\n- Ziel: Aus einem 4-Bit-Binäreingang $abcd$ (Ziffern $0$–$9$) die Ausgänge für die sieben Segmente ableiten und **minimal** darstellen (unter Nutzung von *Don't Cares*).\n\n---\n\n## 1. Kernkonzepte\n\n### 1.1 Sieben-Segment-Anzeige\n\n- Eine Sieben-Segment-Anzeige besteht aus **7 einzeln ansteuerbaren Segmenten**, die gemeinsam Ziffern darstellen.\n- Jedes Segment wird durch eine **binäre Schaltfunktion** angesteuert:\n  - $1$: Segment leuchtet\n  - $0$: Segment ist aus\n\nTypische Segmentbezeichnungen (hier nach Aufgabenblatt):\n\n- $o$ : oberes Segment\n- $lo$: **l**inkes **o**beres Segment\n- $lu$: **l**inkes **u**nteres Segment\n- $u$ : unteres Segment\n- $ru$: **r**echtes **u**nteres Segment\n- $ro$: **r**echtes **o**beres Segment\n- $m$ : mittleres Segment\n\n### 1.2 Eingangsvariablen\n\n- Es werden **vier Eingangsbits** verwendet:\n  - $a$: höchstwertiges Bit (MSB)\n  - $b$\n  - $c$\n  - $d$: niederwertigstes Bit (LSB)\n- Interpretation als Binärzahl:\n  - $abcd \\in \\{0000, 0001, \\dots, 1001\\}$ entspricht den Dezimalziffern $0$ bis $9$.\n\n---\n\n## 2. Wahrheitstabelle und Don't Cares\n\n### 2.1 Gültige Eingaben\n\n- Gültige Ziffern: $0$ bis $9$  \n  also $abcd = 0000$ bis $1001$.\n\n### 2.2 Don't Cares\n\n- Für $abcd \\in \\{1010, 1011, 1100, 1101, 1110, 1111\\}$  \n  also Dezimal $10$ bis $15$:\n  - Die Anzeige wird **nicht benötigt**.\n  - Die Funktionswerte der Segmente sind *egal*.\n  - Diese Zustände werden als **Don't Cares** ($D$) behandelt.\n- Nutzen:\n  - *Don't Cares* dürfen in der Minimierung (z. B. Karnaugh-Diagramm) wie $0$ oder $1$ verwendet werden, um größere Gruppen zu bilden und so **einfachere Schaltfunktionen** zu erhalten.\n\n---\n\n## 3. Minimierte Schaltfunktionen der Segmente\n\nIm Folgenden sind die **minimierten Schaltfunktionen** für die sieben Segmente angegeben.  \nAlle Ausdrücke sind in **disjunktiver Normalform** (ODER-Verknüpfung von UND-Termen).\n\n### 3.1 Oberes Segment $o$\n\n**Schaltfunktion:**\n\\[\no = a \\;\\vee\\; c \\;\\vee\\; \\lnot b \\,\\lnot d \\;\\vee\\; b d\n\\]\n\n- $a$: leuchtet für alle Ziffern $\\geq 8$\n- $c$: leuchtet u. a. für Ziffern mit $c=1$\n- $\\lnot b \\,\\lnot d$: zusätzliche Kombinationen mit $b=0$, $d=0$\n- $b d$: zusätzliche Kombinationen mit $b=1$, $d=1$\n\n---\n\n### 3.2 Linkes oberes Segment $lo$\n\n**Schaltfunktion:**\n\\[\nlo = a \\;\\vee\\; b \\,\\lnot d \\;\\vee\\; \\lnot c \\,\\lnot d \\;\\vee\\; b \\,\\lnot c\n\\]\n\n- $a$: alle Ziffern $\\geq 8$\n- $b \\,\\lnot d$: $b=1$, $d=0$\n- $\\lnot c \\,\\lnot d$: $c=0$, $d=0$\n- $b \\,\\lnot c$: $b=1$, $c=0$\n\n---\n\n### 3.3 Linkes unteres Segment $lu$\n\n**Schaltfunktion:**\n\\[\nlu = \\lnot b \\,\\lnot d \\;\\vee\\; c \\,\\lnot d\n\\]\n\n- $\\lnot b \\,\\lnot d$: $b=0$, $d=0$\n- $c \\,\\lnot d$: $c=1$, $d=0$\n\n---\n\n### 3.4 Unteres Segment $u$\n\n**Schaltfunktion:**\n\\[\nu = a \\;\\vee\\; \\lnot b\\,c \\;\\vee\\; \\lnot b\\,\\lnot d \\;\\vee\\; c\\,\\lnot d \\;\\vee\\; b\\,\\lnot c\\,d\n\\]\n\n- $a$: alle Ziffern $\\geq 8$\n- $\\lnot b\\,c$: $b=0$, $c=1$\n- $\\lnot b\\,\\lnot d$: $b=0$, $d=0$\n- $c\\,\\lnot d$: $c=1$, $d=0$\n- $b\\,\\lnot c\\,d$: $b=1$, $c=0$, $d=1$\n\n---\n\n### 3.5 Rechtes unteres Segment $ru$\n\n**Schaltfunktion:**\n\\[\nru = b \\;\\vee\\; \\lnot c \\;\\vee\\; d\n\\]\n\n- Sehr einfache Funktion:\n  - leuchtet, wenn **mindestens eine** der Bedingungen erfüllt ist:\n    - $b=1$ oder $c=0$ oder $d=1$.\n\n---\n\n### 3.6 Rechtes oberes Segment $ro$\n\n**Schaltfunktion:**\n\\[\nro = \\lnot b \\;\\vee\\; c d \\;\\vee\\; \\lnot c\\,\\lnot d\n\\]\n\n- $\\lnot b$: leuchtet für $b=0$\n- $c d$: leuchtet für $c=1$, $d=1$\n- $\\lnot c\\,\\lnot d$: leuchtet für $c=0$, $d=0$\n\n---\n\n### 3.7 Mittleres Segment $m$\n\n**Schaltfunktion:**\n\\[\nm = a \\;\\vee\\; \\lnot b\\,c \\;\\vee\\; b\\,\\lnot c \\;\\vee\\; b\\,\\lnot d\n\\]\n\n- $a$: alle Ziffern $\\geq 8$\n- $\\lnot b\\,c$: $b=0$, $c=1$\n- $b\\,\\lnot c$: $b=1$, $c=0$\n- $b\\,\\lnot d$: $b=1$, $d=0$\n\n---\n\n## 4. Zusammenhang: Eingabe–Ausgabe (schematisch)\n\nDie Segmente sind jeweils Funktionen der Eingänge $a,b,c,d$:\n\n\\[\n\\begin{aligned}\no   &= f_o(a,b,c,d) \\\\\nlo  &= f_{lo}(a,b,c,d) \\\\\nlu  &= f_{lu}(a,b,c,d) \\\\\nu   &= f_u(a,b,c,d) \\\\\nru  &= f_{ru}(a,b,c,d) \\\\\nro  &= f_{ro}(a,b,c,d) \\\\\nm   &= f_m(a,b,c,d)\n\\end{aligned}\n\\]\n\n- Jeder Funktionsausdruck ist aus der **Wahrheitstabelle** und mithilfe von **Karnaugh-Diagrammen** unter Berücksichtigung der *Don't Cares* minimiert worden.\n\n---\n\n## 5. Beispielrechnung (Schritt-für-Schritt)\n\n### 5.1 Gegeben\n\n- Dezimalziffer: $5$\n- Binärdarstellung: $5 = 0101_2$\n  - also $a=0$, $b=1$, $c=0$, $d=1$.\n\n### 5.2 Auswertung der Segmente\n\nSetze $a=0$, $b=1$, $c=0$, $d=1$ in jede Funktion ein.\n\n1. **Oberes Segment $o$**:\n   \\[\n   \\begin{aligned}\n   o &= a \\;\\vee\\; c \\;\\vee\\; \\lnot b\\,\\lnot d \\;\\vee\\; b d \\\\\n     &= 0 \\;\\vee\\; 0 \\;\\vee\\; \\lnot 1\\,\\lnot 1 \\;\\vee\\; 1\\cdot 1 \\\\\n     &= 0 \\;\\vee\\; 0 \\;\\vee\\; 0\\cdot 0 \\;\\vee\\; 1 \\\\\n     &= 1\n   \\end{aligned}\n   \\]\n\n2. **Linkes oberes Segment $lo$**:\n   \\[\n   \\begin{aligned}\n   lo &= a \\;\\vee\\; b\\,\\lnot d \\;\\vee\\; \\lnot c\\,\\lnot d \\;\\vee\\; b\\,\\lnot c \\\\\n      &= 0 \\;\\vee\\; 1\\cdot 0 \\;\\vee\\; 1\\cdot 0 \\;\\vee\\; 1\\cdot 1 \\\\\n      &= 0 \\;\\vee\\; 0 \\;\\vee\\; 0 \\;\\vee\\; 1 \\\\\n      &= 1\n   \\end{aligned}\n   \\]\n\n3. **Linkes unteres Segment $lu$**:\n   \\[\n   \\begin{aligned}\n   lu &= \\lnot b\\,\\lnot d \\;\\vee\\; c\\,\\lnot d \\\\\n      &= 0\\cdot 0 \\;\\vee\\; 0\\cdot 0 \\\\\n      &= 0\n   \\end{aligned}\n   \\]\n\n4. **Unteres Segment $u$**:\n   \\[\n   \\begin{aligned}\n   u &= a \\;\\vee\\; \\lnot b\\,c \\;\\vee\\; \\lnot b\\,\\lnot d \\;\\vee\\; c\\,\\lnot d \\;\\vee\\; b\\,\\lnot c\\,d \\\\\n     &= 0 \\;\\vee\\; 0\\cdot 0 \\;\\vee\\; 0\\cdot 0 \\;\\vee\\; 0\\cdot 0 \\;\\vee\\; 1\\cdot 1\\cdot 1 \\\\\n     &= 1\n   \\end{aligned}\n   \\]\n\n5. **Rechtes unteres Segment $ru$**:\n   \\[\n   \\begin{aligned}\n   ru &= b \\;\\vee\\; \\lnot c \\;\\vee\\; d \\\\\n      &= 1 \\;\\vee\\; 1 \\;\\vee\\; 1 \\\\\n      &= 1\n   \\end{aligned}\n   \\]\n\n6. **Rechtes oberes Segment $ro$**:\n   \\[\n   \\begin{aligned}\n   ro &= \\lnot b \\;\\vee\\; c d \\;\\vee\\; \\lnot c\\,\\lnot d \\\\\n      &= 0 \\;\\vee\\; 0\\cdot 1 \\;\\vee\\; 1\\cdot 0 \\\\\n      &= 0\n   \\end{aligned}\n   \\]\n\n7. **Mittleres Segment $m$**:\n   \\[\n   \\begin{aligned}\n   m &= a \\;\\vee\\; \\lnot b\\,c \\;\\vee\\; b\\,\\lnot c \\;\\vee\\; b\\,\\lnot d \\\\\n     &= 0 \\;\\vee\\; 0\\cdot 0 \\;\\vee\\; 1\\cdot 1 \\;\\vee\\; 1\\cdot 0 \\\\\n     &= 1\n   \\end{aligned}\n   \\]\n\n### 5.3 Ergebnis für die Ziffer 5\n\n- Aktivierte Segmente:\n  - $o = 1$\n  - $lo = 1$\n  - $lu = 0$\n  - $u = 1$\n  - $ru = 1$\n  - $ro = 0$\n  - $m = 1$\n\nDiese Kombination entspricht der **Anzeige der Ziffer 5** auf einer Sieben-Segment-Anzeige.\n\n---\n\n## 6. Merksätze\n\n- **Merksatz 1:**  \n  Für die **Ziffern 0–9** werden nur $abcd = 0000$ bis $1001$ benötigt; alle übrigen Kombinationen sind **Don't Cares** und dürfen zur **Minimierung** genutzt werden.\n\n- **Merksatz 2:**  \n  Jede Segmentfunktion ist eine **boolesche Funktion** der Eingänge $a,b,c,d$:\n  \\[\n  \\text{Segment} = f(a,b,c,d)\n  \\]\n\n- **Merksatz 3:**  \n  *Don't Cares* ($D$) können im Karnaugh-Diagramm sowohl als $0$ als auch als $1$ behandelt werden, um **größere Gruppen** zu bilden und damit **weniger Produktterme** zu erhalten.\n\n- **Merksatz 4:**  \n  Die minimierten Ausdrücke enthalten oft **gemeinsame Terme** (z. B. $a$ oder $b\\,\\lnot c$). Diese können bei der **Hardware-Implementierung** zur Reduktion der Gatteranzahl wiederverwendet werden.\n\n- **Merksatz 5:**  \n  Eine Sieben-Segment-Anzeige ist ein klassisches Beispiel für die Anwendung von **boolescher Algebra** und **Schaltfunktionsminimierung** in der digitalen Technik.",
    "generatedAt": "2025-12-05T17:28:38.994Z"
  },
  {
    "id": "1764955747720-pnb1xv90z",
    "scriptId": "1764951167989-um9mfxq0z",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Boolesche Algebra – Absorptionsgesetze, Tautologien und Vereinfachung\n\n## Überblick\n\nDiese Notizen fassen zentrale Inhalte zur **Booleschen Algebra** zusammen:\n- Absorptionsgesetze und ihre Beweise\n- Allgemeingültige Ausdrücke (Tautologien)\n- Vereinfachung boolescher Ausdrücke\n\n---\n\n## 1. Kernkonzepte der Booleschen Algebra\n\n### Grundoperationen\n\n- **UND-Verknüpfung** (*Konjunktion*): $x \\land y$\n- **ODER-Verknüpfung** (*Disjunktion*): $x \\lor y$\n- **Negation** (*Inversion*): $\\neg x$\n\n### Wichtige Konstanten\n\n- $0$ (oder *false*): immer falsch\n- $1$ (oder *true*): immer wahr\n\n---\n\n## 2. Absorptionsgesetze (Aufgabe 1)\n\n### 2.1 Formulierung der Absorptionsgesetze\n\n**Theorem 1:**\n$$(x \\lor \\neg y) \\land y = x \\land y$$\n\n**Theorem 2:**\n$$(x \\land \\neg y) \\lor y = x \\lor y$$\n\nDiese Gesetze „absorbieren“ den komplizierteren Ausdruck in den einfacheren.\n\n---\n\n### 2.2 Beweis per Wahrheitstafel\n\n#### Wahrheitstafel für Theorem 1: $(x \\lor \\neg y) \\land y = x \\land y$\n\n| $x$ | $y$ | $\\neg x$ | $\\neg y$ | $x \\lor \\neg y$ | $x \\land \\neg y$ | $(x \\lor \\neg y)\\land y$ | $x \\land y$ |\n|-----|-----|----------|----------|-----------------|------------------|---------------------------|-------------|\n| 0   | 0   | 1        | 1        | 1               | 0                | 0                         | 0           |\n| 0   | 1   | 1        | 0        | 0               | 0                | 0                         | 0           |\n| 1   | 0   | 0        | 1        | 1               | 1                | 0                         | 0           |\n| 1   | 1   | 0        | 0        | 1               | 0                | 1                         | 1           |\n\n- Letzte beiden Spalten sind in allen Zeilen gleich  \n  $\\Rightarrow$ $(x \\lor \\neg y)\\land y$ ist äquivalent zu $x \\land y$.\n\n#### Wahrheitstafel für Theorem 2: $(x \\land \\neg y) \\lor y = x \\lor y$\n\n| $x$ | $y$ | $\\neg y$ | $x \\land \\neg y$ | $(x \\land \\neg y)\\lor y$ | $x \\lor y$ |\n|-----|-----|----------|------------------|---------------------------|------------|\n| 0   | 0   | 1        | 0                | 0                         | 0          |\n| 0   | 1   | 0        | 0                | 1                         | 1          |\n| 1   | 0   | 1        | 1                | 1                         | 1          |\n| 1   | 1   | 0        | 0                | 1                         | 1          |\n\n- Letzte beiden Spalten sind identisch  \n  $\\Rightarrow$ $(x \\land \\neg y)\\lor y$ ist äquivalent zu $x \\lor y$.\n\n---\n\n### 2.3 Beweis durch algebraische Umformung\n\n#### Beweis von $(x \\lor \\neg y)\\land y = x \\land y$\n\n1. $$ (x \\lor \\neg y)\\land y $$\n2. $$ = (x \\land y) \\lor (\\neg y \\land y) \\quad\\text{// Distributivgesetz} $$\n3. $$ = (x \\land y) \\lor 0 \\quad\\text{// Inversion: } \\neg y \\land y = 0 $$\n4. $$ = x \\land y \\quad\\text{// Neutralität von } 0 \\text{ bei } \\lor $$\n\n#### Beweis von $(x \\land \\neg y)\\lor y = x \\lor y$\n\n1. $$ (x \\land \\neg y)\\lor y $$\n2. $$ = (x \\lor y)\\land (\\neg y \\lor y) \\quad\\text{// Distributivgesetz} $$\n3. $$ = (x \\lor y)\\land 1 \\quad\\text{// Inversion: } \\neg y \\lor y = 1 $$\n4. $$ = x \\lor y \\quad\\text{// Neutralität von } 1 \\text{ bei } \\land $$\n\n---\n\n## 3. Allgemeingültige Ausdrücke (Tautologien, Aufgabe 2)\n\n### 3.1 Erste Tautologie: $\\neg(x \\land y)\\lor x \\lor y$\n\n#### 3.1.1 Wahrheitstafel\n\n| $x$ | $y$ | $x \\land y$ | $\\neg(x \\land y)$ | $x \\lor y$ | $\\neg(x \\land y)\\lor(x \\lor y)$ |\n|-----|-----|-------------|-------------------|------------|----------------------------------|\n| 0   | 0   | 0           | 1                 | 0          | 1                                |\n| 0   | 1   | 0           | 1                 | 1          | 1                                |\n| 1   | 0   | 0           | 1                 | 1          | 1                                |\n| 1   | 1   | 1           | 0                 | 1          | 1                                |\n\n- Der Ausdruck ist in allen Zeilen $1$  \n  $\\Rightarrow$ *allgemeingültig* (Tautologie).\n\n#### 3.1.2 Algebraische Umformung\n\nAusdruck:\n$$\\neg(x \\land y)\\lor x \\lor y$$\n\n1. Wende de Morgan an:\n   $$\\neg(x \\land y) = \\neg x \\lor \\neg y$$\n   $$\\Rightarrow (\\neg x \\lor \\neg y)\\lor x \\lor y$$\n\n2. Umgruppieren (Assoziativität, Kommutativität):\n   $$= (\\neg x \\lor x)\\lor(\\neg y \\lor y)$$\n\n3. Inversion:\n   $$\\neg x \\lor x = 1,\\quad \\neg y \\lor y = 1$$\n   $$\\Rightarrow 1 \\lor 1 = 1$$\n\nDamit ist der Ausdruck immer $1$.\n\n---\n\n### 3.2 Zweite Tautologie: $(x \\land y)\\lor\\neg\\bigl((x \\lor \\neg y)\\land y\\bigr)$\n\n#### 3.2.1 Wahrheitstafel\n\n| $x$ | $y$ | $x \\land y$ | $x \\lor \\neg y$ | $(x \\lor \\neg y)\\land y$ | $\\neg((x \\lor \\neg y)\\land y)$ | $(x \\land y)\\lor\\neg((x \\lor \\neg y)\\land y)$ |\n|-----|-----|-------------|-----------------|---------------------------|--------------------------------|-----------------------------------------------|\n| 0   | 0   | 0           | 1               | 0                         | 1                              | 1                                             |\n| 0   | 1   | 0           | 0               | 0                         | 1                              | 1                                             |\n| 1   | 0   | 0           | 1               | 0                         | 1                              | 1                                             |\n| 1   | 1   | 1           | 1               | 1                         | 0                              | 1                                             |\n\n- Letzte Spalte ist immer $1$  \n  $\\Rightarrow$ *allgemeingültig*.\n\n#### 3.2.2 Algebraische Umformung\n\nAusdruck:\n$$(x \\land y)\\lor\\neg\\bigl((x \\lor \\neg y)\\land y\\bigr)$$\n\n1. Nutze das Absorptionsgesetz (vgl. Abschnitt 2):\n   $$(x \\lor \\neg y)\\land y = x \\land y$$\n\n2. Einsetzen:\n   $$(x \\land y)\\lor\\neg(x \\land y)$$\n\n3. Wende de Morgan rückwärts bzw. Komplementgesetz:\n   $$a \\lor \\neg a = 1 \\quad\\text{für } a = x \\land y$$\n\nDamit:\n$$(x \\land y)\\lor\\neg(x \\land y) = 1$$\n\n---\n\n## 4. Typische Vereinfachungen (Aufgabe 3 – Prinzipien)\n\n*(konkrete Ausdrücke fehlen im Material; hier die wichtigsten Regeln zur Vereinfachung)*\n\n### 4.1 Grundgesetze (Auswahl)\n\n- **Idempotenz:**\n  - $x \\lor x = x$\n  - $x \\land x = x$\n\n- **Dominanz:**\n  - $x \\lor 1 = 1$\n  - $x \\land 0 = 0$\n\n- **Neutralität:**\n  - $x \\lor 0 = x$\n  - $x \\land 1 = x$\n\n- **Komplementarität:**\n  - $x \\lor \\neg x = 1$\n  - $x \\land \\neg x = 0$\n\n- **Absorption:**\n  - $x \\lor (x \\land y) = x$\n  - $x \\land (x \\lor y) = x$\n\n- **Distributivität:**\n  - $x \\land (y \\lor z) = (x \\land y)\\lor(x \\land z)$\n  - $x \\lor (y \\land z) = (x \\lor y)\\land(x \\lor z)$\n\n- **de Morgan:**\n  - $\\neg(x \\land y) = \\neg x \\lor \\neg y$\n  - $\\neg(x \\lor y) = \\neg x \\land \\neg y$\n\n---\n\n## 5. Beispiel für Vereinfachung (Schritt-für-Schritt)\n\n### Gegeben\n\n$$f(x,y) = (x \\land y)\\lor(x \\land \\neg y)$$\n\n### Ziel\n\nSo weit wie möglich vereinfachen.\n\n### Lösung\n\n1. Ausklammern von $x$ (Distributivität):\n   $$(x \\land y)\\lor(x \\land \\neg y) = x \\land (y \\lor \\neg y)$$\n\n2. Inversion:\n   $$y \\lor \\neg y = 1$$\n\n3. Neutralität von $1$ bei $\\land$:\n   $$x \\land 1 = x$$\n\n**Ergebnis:**\n$$f(x,y) = x$$\n\n---\n\n## 6. Merksätze\n\n- **Absorptionsgesetze:**\n  - $(x \\lor \\neg y)\\land y = x \\land y$\n  - $(x \\land \\neg y)\\lor y = x \\lor y$\n\n- **Tautologien erkennen:**\n  - Ein Ausdruck ist *allgemeingültig*, wenn seine Wahrheitstafel in jeder Zeile $1$ liefert.\n  - Typische Form: $a \\lor \\neg a = 1$.\n\n- **Vereinfachung:**\n  - Immer zuerst:\n    - offensichtliche Komplementaritäten ($x \\lor \\neg x$, $x \\land \\neg x$),\n    - Ausklammern mit Distributivität,\n    - Absorptionsgesetze anwenden.\n  - Ziel ist eine möglichst kurze, logisch äquivalente Form.",
    "generatedAt": "2025-12-05T17:29:07.720Z"
  },
  {
    "id": "1764955809467-lp6kubrjj",
    "scriptId": "1764951165946-v3ra1bwpx",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Darstellung von Zahlen und Zeichen – Lernnotizen\n\nKurzer Überblick:  \nIn diesem Thema geht es um die **Darstellung von Zahlen in verschiedenen Zahlensystemen**, deren **Umrechnung** sowie um **arithmetische Operationen** (Addition, Subtraktion im Zweierkomplement) und **Gleitkommadarstellung nach IEEE 754**.\n\n---\n\n## 1. Positionszahlensysteme\n\n### Definition\n\n*Ein Positionszahlensystem* zur Basis $b$ (Radix) stellt eine Zahl $x$ als gewichtete Summe der Ziffern $z_i$ dar:\n\n- Für ganze Zahlen:\n  $$x = \\sum_{i=0}^{n} z_i \\cdot b^i$$\n\n- Für Zahlen mit Nachkommastellen:\n  $$x = \\sum_{i=-m}^{n} z_i \\cdot b^i$$\n\nmit:\n- Basis $b \\in \\mathbb{N}, b \\ge 2$\n- Ziffern $z_i \\in \\{0,1,\\dots,b-1\\}$\n\n**Beispiele für Basen:**\n- $b = 2$: Binärsystem\n- $b = 8$: Oktalsystem\n- $b = 10$: Dezimalsystem\n- $b = 16$: Hexadezimalsystem\n\n---\n\n## 2. Umrechnung: Allgemeines Prinzip\n\n### 2.1 Von Basis $b$ nach Dezimal\n\nFür eine Zahl\n$$(z_n z_{n-1} \\dots z_1 z_0.z_{-1} z_{-2} \\dots)_b$$\n\ngilt:\n\n$$x = \\sum_{i=0}^{n} z_i \\cdot b^i + \\sum_{i=1}^{m} z_{-i} \\cdot b^{-i}$$\n\n- Jede Stelle wird mit der entsprechenden Potenz der Basis multipliziert.\n- Die Summe ergibt den Dezimalwert.\n\n---\n\n### 2.2 Von Dezimal nach Basis $b$\n\n**Ganzzahliger Anteil: Division mit Rest**\n\n- Wiederholte Division durch $b$\n- Reste von unten nach oben gelesen ergeben die Ziffern:\n\nBeispielschablone:\n- $N : b = q_0$ Rest $r_0$\n- $q_0 : b = q_1$ Rest $r_1$\n- …\n- $q_k : b = 0$ Rest $r_k$\n\nErgebnis:\n$$(N)_{10} = (r_k r_{k-1} \\dots r_1 r_0)_b$$\n\n**Nachkommaanteil: Multiplikation**\n\n- Wiederholte Multiplikation mit $b$\n- Ganzzahlteile bilden die Ziffern von links nach rechts:\n\nBeispielschablone:\n- $x_0 \\cdot b = a_1 + x_1$\n- $x_1 \\cdot b = a_2 + x_2$\n- …\n\nErgebnis:\n$$(x)_{10} = (0.a_1 a_2 a_3 \\dots)_b$$\n\n---\n\n## 3. Beispiele: Summenschreibweise und Dezimalwert\n\n### 3.1 Ganze Zahlen\n\n**Beispiele:**\n\n1. $(312)_4$  \n   $$3\\cdot 4^2 + 1\\cdot 4^1 + 2\\cdot 4^0 = 3\\cdot 16 + 1\\cdot 4 + 2\\cdot 1 = 48 + 4 + 2 = (54)_{10}$$\n\n2. $(1202)_{16}$  \n   $$1\\cdot 16^3 + 2\\cdot 16^2 + 0\\cdot 16^1 + 2\\cdot 16^0 = 4096 + 512 + 0 + 2 = (4610)_{10}$$\n\n3. $(ab1)_{12}$ mit $a=10, b=11$  \n   $$10\\cdot 12^2 + 11\\cdot 12^1 + 1\\cdot 12^0 = 1440 + 132 + 1 = (1573)_{10}$$\n\n4. $(101011)_2$  \n   $$1\\cdot 2^5 + 0\\cdot 2^4 + 1\\cdot 2^3 + 0\\cdot 2^2 + 1\\cdot 2^1 + 1\\cdot 2^0 = 32 + 8 + 2 + 1 = (43)_{10}$$\n\n5. $(705)_8$  \n   $$7\\cdot 8^2 + 0\\cdot 8^1 + 5\\cdot 8^0 = 7\\cdot 64 + 5 = 448 + 5 = (453)_{10}$$\n\n6. $(ABC)_{16}$ mit $A=10,B=11,C=12$  \n   $$10\\cdot 16^2 + 11\\cdot 16^1 + 12\\cdot 16^0 = 2560 + 176 + 12 = (2748)_{10}$$\n\n7. $(1111)_2$  \n   $$1\\cdot 2^3 + 1\\cdot 2^2 + 1\\cdot 2^1 + 1\\cdot 2^0 = 8 + 4 + 2 + 1 = (15)_{10}$$\n\n8. $(127)_8$  \n   $$1\\cdot 8^2 + 2\\cdot 8^1 + 7\\cdot 8^0 = 64 + 16 + 7 = (87)_{10}$$\n\n---\n\n### 3.2 Zahlen mit Nachkommastellen\n\n**Beispiele:**\n\n1. $(1573.4)_8$  \n   $$1\\cdot 8^3 + 5\\cdot 8^2 + 7\\cdot 8^1 + 3\\cdot 8^0 + 4\\cdot 8^{-1}$$\n   $$= 512 + 320 + 56 + 3 + \\frac{4}{8} = 891 + 0{,}5 = (891{,}5)_{10}$$\n\n2. $(ABC.CBA)_{16}$  \n   $$10\\cdot 16^2 + 11\\cdot 16^1 + 12\\cdot 16^0 + 12\\cdot 16^{-1} + 11\\cdot 16^{-2} + 10\\cdot 16^{-3}$$\n   $$= 2560 + 176 + 12 + \\frac{12}{16} + \\frac{11}{256} + \\frac{10}{4096} = (2748{,}795)_{10}$$\n\n3. $(1011.1101)_2$  \n   $$1\\cdot 2^3 + 0\\cdot 2^2 + 1\\cdot 2^1 + 1\\cdot 2^0 + 1\\cdot 2^{-1} + 1\\cdot 2^{-2} + 0\\cdot 2^{-3} + 1\\cdot 2^{-4}$$\n   $$= 8 + 2 + 1 + 0{,}5 + 0{,}25 + 0{,}0625 = (11{,}8125)_{10}$$\n\n4. $(0.4)_8$  \n   $$0\\cdot 8^0 + 4\\cdot 8^{-1} = \\frac{4}{8} = (0{,}5)_{10}$$\n\n---\n\n## 4. Effiziente Basisumwandlungen\n\n### 4.1 Hexadezimal $\\leftrightarrow$ Oktal\n\n*Effiziente Methode:* über Binärsystem (je 4 Bit = 1 Hex-Ziffer, je 3 Bit = 1 Oktal-Ziffer).  \nIm Material wurde jedoch der Weg über Dezimal gewählt.\n\n**Beispiel:** $(ABBA)_{16}$ in Oktal\n\n1. Zuerst nach Dezimal:\n   $$A\\cdot 16^3 + B\\cdot 16^2 + B\\cdot 16^1 + A\\cdot 16^0$$\n   $$= 10\\cdot 4096 + 11\\cdot 256 + 11\\cdot 16 + 10\\cdot 1 = 40960 + 2816 + 176 + 10 = 43962_{10}$$\n\n2. Dann Dezimal $\\rightarrow$ Oktal (Division durch $8$):\n\n| Division       | Quotient | Rest |\n|----------------|----------|------|\n| $43962 : 8$    | $5495$   | $2$  |\n| $5495 : 8$     | $686$    | $7$  |\n| $686 : 8$      | $85$     | $6$  |\n| $85 : 8$       | $10$     | $5$  |\n| $10 : 8$       | $1$      | $2$  |\n| $1 : 8$        | $0$      | $1$  |\n\nReste von unten nach oben:\n$$(ABBA)_{16} = (125672)_8$$\n\n---\n\n## 5. Horner-Schema zur Basisumrechnung\n\n### 5.1 Idee des Hornerschemas\n\n*Horner-Darstellung* einer Zahl $(z_n z_{n-1} \\dots z_0)_b$ nach Dezimal:\n\n$$((((z_n \\cdot b + z_{n-1})\\cdot b + z_{n-2})\\cdot b + \\dots)\\cdot b + z_0)$$\n\nVorteil:\n- Weniger Potenzen\n- Nur Multiplikation und Addition\n\n### 5.2 Beispiele\n\n1. $(375)_8$:\n$$((3\\cdot 8 + 7)\\cdot 8 + 5) = (24 + 7)\\cdot 8 + 5 = 31\\cdot 8 + 5 = 248 + 5 = 253_{10}$$\n\n2. $(1210)_8$:\n$$(((1\\cdot 8 + 2)\\cdot 8 + 1)\\cdot 8 + 0) = (10\\cdot 8 + 1)\\cdot 8 = 81\\cdot 8 = 648_{10}$$\n\n3. $(888)_9$:\n$$(8\\cdot 9 + 8)\\cdot 9 + 8 = (72 + 8)\\cdot 9 + 8 = 80\\cdot 9 + 8 = 720 + 8 = 728_{10}$$\n\n4. $(ADA)_{16}$ mit $A=10, D=13$:\n$$(10\\cdot 16 + 13)\\cdot 16 + 10 = (160 + 13)\\cdot 16 + 10 = 173\\cdot 16 + 10 = 2768 + 10 = 2778_{10}$$\n\n---\n\n## 6. Dezimal $\\rightarrow$ andere Basen (Beispiele)\n\n### 6.1 $(1234)_{10}$ ins Siebenersystem\n\nDivision durch $7$:\n\n| Division       | Quotient | Rest |\n|----------------|----------|------|\n| $1234 : 7$     | $176$    | $2$  |\n| $176 : 7$      | $25$     | $1$  |\n| $25 : 7$       | $3$      | $4$  |\n| $3 : 7$        | $0$      | $3$  |\n\nReste von unten nach oben:\n$$(1234)_{10} = (3412)_7$$\n\n---\n\n### 6.2 $(77875)_{10}$ ins Dreiersystem\n\nDivision durch $3$:\n\n| Division       | Quotient | Rest |\n|----------------|----------|------|\n| $77875 : 3$    | $25958$  | $1$  |\n| $25958 : 3$    | $8652$   | $2$  |\n| $8652 : 3$     | $2884$   | $0$  |\n| $2884 : 3$     | $961$    | $1$  |\n| $961 : 3$      | $320$    | $1$  |\n| $320 : 3$      | $106$    | $2$  |\n| $106 : 3$      | $35$     | $1$  |\n| $35 : 3$       | $11$     | $2$  |\n| $11 : 3$       | $3$      | $2$  |\n| $3 : 3$        | $1$      | $0$  |\n| $1 : 3$        | $0$      | $1$  |\n\nReste von unten nach oben:\n$$(77875)_{10} = (10221211021)_3$$\n\n---\n\n### 6.3 $(0{,}19)_{10}$ ins Hexadezimalsystem\n\nMultiplikation mit $16$:\n\n| Schritt                | Ergebnis  | Ganzteil (Ziffer) |\n|------------------------|-----------|-------------------|\n| $0{,}19 \\cdot 16$      | $3{,}04$  | $3$               |\n| $0{,}04 \\cdot 16$      | $0{,}64$  | $0$               |\n| $0{,}64 \\cdot 16$      | $10{,}24$ | $A$               |\n| $0{,}24 \\cdot 16$      | $3{,}84$  | $3$               |\n| $0{,}84 \\cdot 16$      | $13{,}44$ | $D$               |\n| $0{,}44 \\cdot 16$      | $7{,}04$  | $7$               |\n| $0{,}04 \\cdot 16$      | $0{,}64$  | $0$               |\n\nErgebnis (abgeschnittene Genauigkeit):\n$$(0{,}19)_{10} \\approx (0{,}30A3D70)_{16}$$\n\n---\n\n## 7. Binäre Addition über Dezimalumweg\n\n### Vorgehen\n\n1. Dezimalzahlen in Binärzahlen umwandeln.\n2. Binäre Addition mit Überträgen durchführen.\n3. Ergebnis ggf. wieder in Dezimal interpretieren.\n\n### Beispiel 1: $(123)_{10} + (204)_{10}$\n\n- $123_{10} = 01111011_2$\n- $204_{10} = 11001100_2$\n\nAddition (mit Überträgen, 8 Bit):\n\n$$01111011_2 + 11001100_2 = 101000111_2$$\n\nInterpretation:\n$$(123)_{10} + (204)_{10} = (327)_{10} = (101000111)_2$$\n\n---\n\n### Beispiel 2: $(15)_{10} + (31)_{10}$\n\n- $15_{10} = 001111_2$\n- $31_{10} = 011111_2$\n\nAddition:\n\n$$001111_2 + 011111_2 = 101110_2$$\n\nInterpretation:\n$$(15)_{10} + (31)_{10} = (46)_{10} = (101110)_2$$\n\n---\n\n## 8. Subtraktion im Zweierkomplement (8 Bit)\n\n### 8.1 Zweierkomplement\n\nFür ein $n$-Bit-System:\n\n- *Betragsdarstellung* einer positiven Zahl $x$: normale Binärdarstellung.\n- *Zweierkomplement* von $x$:\n  1. Alle Bits invertieren (Einerkomplement).\n  2. $1$ addieren.\n\n*Subtraktion* $a - b$:\n- Rechne $a + (\\text{Zweierkomplement von } b)$.\n\n---\n\n### 8.2 Beispiel: $(57)_{10} - (122)_{10}$ (8 Bit)\n\n1. Darstellung von $122$:\n   $$122_{10} = 01111010_2$$\n\n2. Zweierkomplement von $122$:\n   - Invertieren: $10000101_2$\n   - $+1$: $10000110_2$\n\n3. Addition mit $57$:\n   - $57_{10} = 00111001_2$\n\n   $$00111001_2 + 10000110_2 = 10111111_2$$\n\nInterpretation (negativ, da MSB = 1):  \n$10111111_2$ ist $-65_{10}$ im Zweierkomplement.\n\nAlso:\n$$(57)_{10} - (122)_{10} = -65_{10} = (10111111)_2$$\n\n---\n\n### 8.3 Beispiel: $(17)_{10} - (109)_{10}$ (8 Bit)\n\n1. Darstellung von $109$:\n   $$109_{10} = 01101101_2$$\n\n2. Zweierkomplement von $109$:\n   - Invertieren: $10010010_2$\n   - $+1$: $10010011_2$\n\n3. Addition mit $17$:\n   - $17_{10} = 00010001_2$\n\n   $$00010001_2 + 10010011_2 = 10100100_2$$\n\nInterpretation:  \n$10100100_2$ ist $-92_{10}$.\n\nAlso:\n$$(17)_{10} - (109)_{10} = -92_{10} = (10100100)_2$$\n\n---\n\n## 9. Gleitkommazahlen nach IEEE 754 (Float, 32 Bit)\n\n### 9.1 Aufbau\n\n**IEEE 754 Single Precision (32 Bit):**\n\n- 1 Bit **Vorzeichen** $s$\n- 8 Bit **Exponent** $e$ (biased)\n- 23 Bit **Mantisse** $m$\n\nWert:\n$$x = (-1)^s \\cdot (1.f)_2 \\cdot 2^{E}$$\nmit:\n- $f$: Nachkommabits der Mantisse\n- $E = e_{\\text{unsigned}} - \\text{Bias}$\n- Bias für Float: $\\text{Bias} = 127$\n\n**Vorgehensweise:**\n\n1. Vorzeichen bestimmen $\\Rightarrow s$.\n2. Absolutwert in Binär umrechnen.\n3. Normalisieren: in Form $1,\\text{Nachkommabits} \\cdot 2^E$ bringen.\n4. Exponent codieren: $e = E + 127$ in Binär.\n5. Mantisse: Nachkommabits (ohne führende $1.$), auf 23 Bit auffüllen.\n\n---\n\n### 9.2 Beispiel: $125{,}875$\n\n1. Vorzeichen:\n   $$s = 0$$\n\n2. Vorkommateil $125_{10}$ nach Binär:\n\n| Division     | Quotient | Rest |\n|-------------|----------|------|\n| $125 : 2$   | $62$     | $1$  |\n| $62 : 2$    | $31$     | $0$  |\n| $31 : 2$    | $15$     | $1$  |\n| $15 : 2$    | $7$      | $1$  |\n| $7 : 2$     | $3$      | $1$  |\n| $3 : 2$     | $1$      | $1$  |\n| $1 : 2$     | $0$      | $1$  |\n\nErgebnis:\n$$125_{10} = 1111101_2$$\n\n3. Nachkommateil $0{,}875_{10}$ nach Binär:\n\n| Schritt                 | Ergebnis  | Ganzteil |\n|-------------------------|-----------|----------|\n| $0{,}875 \\cdot 2$       | $1{,}75$  | $1$      |\n| $0{,}75 \\cdot 2$        | $1{,}5$   | $1$      |\n| $0{,}5 \\cdot 2$         | $1{,}0$   | $1$      |\n\nErgebnis:\n$$0{,}875_{10} = 0{,}111_2$$\n\n4. Gesamtdarstellung:\n$$125{,}875_{10} = 1111101{,}111_2$$\n\nNormalisieren:\n$$1111101{,}111_2 = 1{,}111101111 \\cdot 2^6$$\n\n- Exponent: $E = 6$\n\n5. Exponent codieren:\n$$e = E + 127 = 6 + 127 = 133_{10} = 10000101_2$$\n\n6. Mantisse (Nachkommabits von $1{,}111101111$):\n$$f = 11110111100000000000000$$\n(auf 23 Bit mit Nullen aufgefüllt)\n\n**IEEE-754-Float (binär):**\n\n- $s = 0$\n- $e = 10000101_2$\n- $m = 11110111100000000000000_2$\n\n---\n\n### 9.3 Allgemeines Beispiel (aus Folie 69)\n\nGegeben (abstrakt):\n\n- Vorzeichen: $s = 0$\n- Exponentkodierung: $c$ (z.B. $c = (01011)_2 = 11_{10}$)\n- Bias: $k = 15_{10}$ (z.B. bei anderer Formatvariante)\n\nExponent:\n$$e = c - k = 11 - 15 = -4$$\n\nMantisse (normalisiert):\n$$m = 1{,}1101000000_2 = 1 + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{16} = 1{,}8125_{10}$$\n\nWert:\n$$x = m \\cdot 2^{-4} = 1{,}8125 \\cdot 2^{-4}$$\n\n---\n\n## 10. Merksätze\n\n- **Positionssystem:** Jede Stelle hat Gewicht $b^i$. Wert = Summe aus Ziffer $\\cdot$ Potenz.\n- **Umrechnung nach Dezimal:** Immer Summenschreibweise benutzen:\n  $$x = \\sum z_i \\cdot b^i$$\n- **Dezimal $\\rightarrow$ andere Basis:**\n  - Ganzteil: wiederholte Division durch Basis, Reste von unten nach oben.\n  - Nachkomma: wiederholte Multiplikation mit Basis, Ganzteile von oben nach unten.\n- **Horner-Schema:**  \n  $$((((z_n \\cdot b + z_{n-1})\\cdot b + \\dots)\\cdot b) + z_0)$$  \n  spart Potenzen und ist effizient.\n- **Zweierkomplement:**\n  - Invertieren der Bits + $1$.\n  - Subtraktion $a - b$ als $a + (\\text{Zweierkomplement von }b)$.\n- **IEEE 754 Float (32 Bit):**\n  - 1 Bit Vorzeichen, 8 Bit Exponent (Bias $127$), 23 Bit Mantisse.\n  - Normalform: $x = (-1)^s \\cdot (1,f)_2 \\cdot 2^{E}$ mit $E = e_{\\text{unsigned}} - 127$.\n- **Binär, Oktal, Hex:**\n  - $1$ Hex-Ziffer = $4$ Binärbits.\n  - $1$ Oktalziffer = $3$ Binärbits.  \n  Direkte Umrechnung über Binär ist besonders effizient.",
    "generatedAt": "2025-12-05T17:30:09.467Z"
  },
  {
    "id": "1764955856288-p5ctav10f",
    "scriptId": "1764951150347-ges59ebci",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Minimierung boolescher Funktionen mit Quine–McCluskey\n\nKurzes Beispiel zur Minimierung einer Funktion in vier Variablen mit dem Verfahren von **Quine–McCluskey**.\n\n---\n\n## 1. Problemstellung\n\nGegeben ist eine boolesche Funktion  \n$$y = f(x_3,x_2,x_1,x_0)$$  \ndurch ihre Wertetabelle. Gesucht sind:\n\n- alle **Primimplikanten** (mit Quine–McCluskey),\n- die **Primimplikantentafel**,\n- eine **disjunktive Minimalform** (DNF-Minimalform).\n\n---\n\n## 2. Gegebene Wertetabelle\n\n### 2.1 Wahrheitstabelle\n\n| Nr. | $x_3$ | $x_2$ | $x_1$ | $x_0$ | $y$ |\n|-----|-------|-------|-------|-------|-----|\n| 0   | 0     | 0     | 0     | 0     | 0   |\n| 1   | 0     | 0     | 0     | 1     | 1   |\n| 2   | 0     | 0     | 1     | 0     | 1   |\n| 3   | 0     | 0     | 1     | 1     | 1   |\n| 4   | 0     | 1     | 0     | 0     | 0   |\n| 5   | 0     | 1     | 0     | 1     | 0   |\n| 6   | 0     | 1     | 1     | 0     | 1   |\n| 7   | 0     | 1     | 1     | 1     | 1   |\n| 8   | 1     | 0     | 0     | 0     | 1   |\n| 9   | 1     | 0     | 0     | 1     | 1   |\n| 10  | 1     | 0     | 1     | 0     | 0   |\n| 11  | 1     | 0     | 1     | 1     | 0   |\n| 12  | 1     | 1     | 0     | 0     | 0   |\n| 13  | 1     | 1     | 0     | 1     | 0   |\n| 14  | 1     | 1     | 1     | 0     | 0   |\n| 15  | 1     | 1     | 1     | 1     | 1   |\n\n### 2.2 Minterme der Funktion\n\nDie Minterme mit $y=1$ sind:\n\n$$m \\in \\{1,2,3,6,7,8,9,15\\}$$\n\nIn Produktform:\n\n- $m_1 = \\bar x_3 \\bar x_2 \\bar x_1 x_0$\n- $m_2 = \\bar x_3 \\bar x_2 x_1 \\bar x_0$\n- $m_3 = \\bar x_3 \\bar x_2 x_1 x_0$\n- $m_6 = \\bar x_3 x_2 x_1 \\bar x_0$\n- $m_7 = \\bar x_3 x_2 x_1 x_0$\n- $m_8 = x_3 \\bar x_2 \\bar x_1 \\bar x_0$\n- $m_9 = x_3 \\bar x_2 \\bar x_1 x_0$\n- $m_{15} = x_3 x_2 x_1 x_0$\n\n---\n\n## 3. Kernkonzepte\n\n### 3.1 *Minterm* und *Implikant*\n\n- *Minterm*: Produktterm, in dem **alle** Variablen (ggf. negiert) vorkommen und der genau **einen** Eins-Eintrag der Funktion beschreibt, z.B.  \n  $$m_1 = \\bar x_3 \\bar x_2 \\bar x_1 x_0$$\n\n- *Implikant*: Produktterm, der für eine Menge von Mintermen $y=1$ ist. Er enthält **weniger Literale** durch Ersetzung gleicher Bits mit einem „Don’t care“ ($-$).\n\n### 3.2 *Primimplikant* und *wesentlicher Primimplikant*\n\n- *Primimplikant*: Ein Implikant, der nicht weiter durch Zusammenfassen vergrößert werden kann.\n- *Wesentlicher Primimplikant*: Deckt mindestens einen Minterm ab, der von **keinem anderen** Primimplikanten abgedeckt wird.\n\n---\n\n## 4. Quine–McCluskey-Verfahren (Überblick)\n\n### 4.1 Grundidee\n\n1. **Minterme nach Anzahl der Einsen** in der Binärdarstellung gruppieren.\n2. **Paarweises Zusammenfassen** je zweier Terme, die sich nur in einem Bit unterscheiden:\n   - unterschiedliches Bit wird zu „$-$“ (Don’t care).\n3. Wiederhole das Zusammenfassen mit den neu entstandenen Termen, bis nichts mehr kombinierbar ist.\n4. Alle nicht weiter kombinierbaren Terme sind **Primimplikanten**.\n5. Erstelle die **Primimplikantentafel** und wähle eine **Menge von Primimplikanten**, die alle Minterme abdeckt (Minimalform).\n\n---\n\n## 5. Durchführung am Beispiel\n\n### 5.1 Schritt 1: Minterme in Binärform\n\nWir schreiben die Indizes $0\\ldots 15$ binär als $(x_3 x_2 x_1 x_0)$:\n\n| Minterm | Binärform |\n|---------|-----------|\n| 1       | 0001      |\n| 2       | 0010      |\n| 3       | 0011      |\n| 6       | 0110      |\n| 7       | 0111      |\n| 8       | 1000      |\n| 9       | 1001      |\n| 15      | 1111      |\n\n### 5.2 Schritt 2: Gruppierung nach Anzahl der Einsen\n\n- **1 Eins**: $1(0001), 2(0010), 8(1000)$  \n- **2 Einsen**: $3(0011), 6(0110), 9(1001)$  \n- **3 Einsen**: $7(0111)$  \n- **4 Einsen**: $15(1111)$  \n\n---\n\n### 5.3 Schritt 3: Erste Kombinationsrunde\n\nWir kombinieren nur Terme, die sich in **genau einem Bit** unterscheiden.\n\n#### 5.3.1 Gruppe 1 ↔ Gruppe 2\n\n- $1(0001)$ und $3(0011)$  \n  $$0001 \\to 0011 \\Rightarrow 00-1 \\quad (m_1,m_3)$$\n- $1(0001)$ und $9(1001)$  \n  $$0001 \\to 1001 \\Rightarrow -001 \\quad (m_1,m_9)$$\n- $2(0010)$ und $3(0011)$  \n  $$0010 \\to 0011 \\Rightarrow 001- \\quad (m_2,m_3)$$\n- $2(0010)$ und $6(0110)$  \n  $$0010 \\to 0110 \\Rightarrow 0-10 \\quad (m_2,m_6)$$\n- $8(1000)$ und $9(1001)$  \n  $$1000 \\to 1001 \\Rightarrow 100- \\quad (m_8,m_9)$$\n\n#### 5.3.2 Gruppe 2 ↔ Gruppe 3\n\n- $3(0011)$ und $7(0111)$  \n  $$0011 \\to 0111 \\Rightarrow 0-11 \\quad (m_3,m_7)$$\n- $6(0110)$ und $7(0111)$  \n  $$0110 \\to 0111 \\Rightarrow 011- \\quad (m_6,m_7)$$\n\n#### 5.3.3 Gruppe 3 ↔ Gruppe 4\n\n- $7(0111)$ und $15(1111)$  \n  $$0111 \\to 1111 \\Rightarrow -111 \\quad (m_7,m_{15})$$\n\n#### 5.3.4 Ergebnis der ersten Runde\n\nNeue (kombinierte) Terme:\n\n- $00-1$   (deckt $m_1,m_3$)\n- $-001$   (deckt $m_1,m_9$)\n- $001-$   (deckt $m_2,m_3$)\n- $0-10$   (deckt $m_2,m_6$)\n- $100-$   (deckt $m_8,m_9$)\n- $0-11$   (deckt $m_3,m_7$)\n- $011-$   (deckt $m_6,m_7$)\n- $-111$   (deckt $m_7,m_{15}$)\n\nAlle ursprünglichen Minterme wurden mindestens einmal kombiniert, sind also **noch keine** Primimplikanten.\n\n---\n\n### 5.4 Schritt 4: Zweite Kombinationsrunde\n\nJetzt kombinieren wir die neuen Terme untereinander, wenn sie sich in genau einem Bit unterscheiden.\n\n#### 5.4.1 Kombinierbare Paare\n\n- $00-1$ und $0-11$:  \n  $$00-1 \\to 0-11 \\Rightarrow 0- -1 \\quad (m_1,m_3,m_7)$$\n- $001-$ und $0-1-$: (indirekt über $0-11$; besser direkt:)\n- $001-$ und $011-$:  \n  $$001- \\to 011- \\Rightarrow 0-1- \\quad (m_2,m_3,m_6,m_7)$$\n- $-001$ und $100-$:  \n  $$-001 \\to 100- \\Rightarrow 1 00- \\text{ bzw. } -00- \\quad \\text{(tatsächlich nicht nur 1 Bit verschieden, also nicht kombinierbar!)}$$\n\nTatsächlich sind im strengen Quine–McCluskey-Verfahren nur die folgenden Kombinationen zulässig:\n\n- $001-$ und $011-$  \n  $$001- \\to 011- \\Rightarrow 0-1-$$\n\nDie anderen Terme unterscheiden sich in mehr als einem Bit oder in Positionen mit „$-$“ und sind **nicht** weiter kombinierbar.\n\n#### 5.4.2 Neue Terme der zweiten Runde\n\n- $0-1-$   (deckt $m_2,m_3,m_6,m_7$)\n\n---\n\n### 5.5 Schritt 5: Bestimmung der Primimplikanten\n\nAlle Terme, die in der **letzten Runde** entstanden sind oder nicht weiter kombiniert werden konnten, sind **Primimplikanten**.\n\n**Primimplikanten (in Bitform):**\n\n- $0-1-$\n- $00-1$\n- $-001$\n- $0-10$\n- $100-$\n- $-111$\n\n(Je nach strenger Protokollierung können einige der 1-Runden-Terme als „verbraucht“ markiert sein; für die Funktion relevant sind aber nur die, die tatsächlich Minterme mit $y=1$ abdecken.)\n\nWir übersetzen sie in Produktterme:\n\n1. $0-1-$:  \n   - $x_3 = 0 \\Rightarrow \\bar x_3$\n   - $x_2 = - \\Rightarrow$ entfällt\n   - $x_1 = 1 \\Rightarrow x_1$\n   - $x_0 = - \\Rightarrow$ entfällt  \n   $$\\Rightarrow \\bar x_3 x_1$$\n\n2. $00-1$:  \n   - $x_3 = 0 \\Rightarrow \\bar x_3$\n   - $x_2 = 0 \\Rightarrow \\bar x_2$\n   - $x_1 = - \\Rightarrow$ entfällt\n   - $x_0 = 1 \\Rightarrow x_0$  \n   $$\\Rightarrow \\bar x_3 \\bar x_2 x_0$$\n\n3. $-001$:  \n   - $x_3 = - \\Rightarrow$ entfällt\n   - $x_2 = 0 \\Rightarrow \\bar x_2$\n   - $x_1 = 0 \\Rightarrow \\bar x_1$\n   - $x_0 = 1 \\Rightarrow x_0$  \n   $$\\Rightarrow \\bar x_2 \\bar x_1 x_0$$\n\n4. $0-10$:  \n   - $x_3 = 0 \\Rightarrow \\bar x_3$\n   - $x_2 = - \\Rightarrow$ entfällt\n   - $x_1 = 1 \\Rightarrow x_1$\n   - $x_0 = 0 \\Rightarrow \\bar x_0$  \n   $$\\Rightarrow \\bar x_3 x_1 \\bar x_0$$\n\n5. $100-$:  \n   - $x_3 = 1 \\Rightarrow x_3$\n   - $x_2 = 0 \\Rightarrow \\bar x_2$\n   - $x_1 = 0 \\Rightarrow \\bar x_1$\n   - $x_0 = - \\Rightarrow$ entfällt  \n   $$\\Rightarrow x_3 \\bar x_2 \\bar x_1$$\n\n6. $-111$:  \n   - $x_3 = - \\Rightarrow$ entfällt\n   - $x_2 = 1 \\Rightarrow x_2$\n   - $x_1 = 1 \\Rightarrow x_1$\n   - $x_0 = 1 \\Rightarrow x_0$  \n   $$\\Rightarrow x_2 x_1 x_0$$\n\n---\n\n## 6. Primimplikantentafel\n\n### 6.1 Abdeckung der Minterme\n\nWir tragen ein, welche Primimplikanten welche Minterme abdecken.\n\n| Primimplikant              | Form       | 1 | 2 | 3 | 6 | 7 | 8 | 9 | 15 |\n|----------------------------|-----------|---|---|---|---|---|---|---|----|\n| $\\bar x_3 x_1$             | $0-1-$    |   | 2 | 3 | 6 | 7 |   |   |    |\n| $\\bar x_3 \\bar x_2 x_0$    | $00-1$    | 1 |   | 3 |   |   |   |   |    |\n| $\\bar x_2 \\bar x_1 x_0$    | $-001$    | 1 |   |   |   |   |   | 9 |    |\n| $\\bar x_3 x_1 \\bar x_0$    | $0-10$    |   | 2 |   | 6 |   |   |   |    |\n| $x_3 \\bar x_2 \\bar x_1$    | $100-$    |   |   |   |   |   | 8 | 9 |    |\n| $x_2 x_1 x_0$              | $-111$    |   |   |   |   | 7 |   |   | 15 |\n\n(„2“ bedeutet z.B. „deckt Minterm 2 ab“; hier nur als Orientierung.)\n\n### 6.2 Wesentliche Primimplikanten\n\n- Minterm $8$ wird **nur** von $x_3 \\bar x_2 \\bar x_1$ abgedeckt  \n  ⇒ $x_3 \\bar x_2 \\bar x_1$ ist **wesentlich**.\n- Minterm $15$ wird **nur** von $x_2 x_1 x_0$ abgedeckt  \n  ⇒ $x_2 x_1 x_0$ ist **wesentlich**.\n\nDie übrigen Minterme $\\{1,2,3,6,7,9\\}$ können durch verschiedene Primimplikanten abgedeckt werden. Eine mögliche minimale Auswahl (nach Anzahl der Produktterme) ist:\n\n- $\\bar x_3 x_1$ deckt: $2,3,6,7$\n- $\\bar x_2 \\bar x_1 x_0$ deckt: $1,9$\n\nDamit sind alle Minterme abgedeckt.\n\n---\n\n## 7. Disjunktive Minimalform\n\nEine mögliche (logisch minimale) DNF-Minimalform ist:\n\n$$\n\\boxed{\ny = \\bar x_3 x_1\n\\;\\lor\\;\n\\bar x_2 \\bar x_1 x_0\n\\;\\lor\\;\nx_3 \\bar x_2 \\bar x_1\n\\;\\lor\\;\nx_2 x_1 x_0\n}\n$$\n\nAlle Terme sind **Primimplikanten**, und zusammen decken sie genau die Minterme $\\{1,2,3,6,7,8,9,15\\}$ ab.\n\n---\n\n## 8. Merksätze\n\n- **Quine–McCluskey** ist ein systematisches Verfahren zur Minimierung boolescher Funktionen, besonders geeignet für Implementierung per Computer.\n- *Primimplikanten* entstehen durch wiederholtes Zusammenfassen von Mintermen, die sich nur in **einem Bit** unterscheiden.\n- *Wesentliche Primimplikanten* müssen immer in der Minimalform enthalten sein.\n- Die **Primimplikantentafel** dient zur Auswahl einer Menge von Primimplikanten, die alle Minterme mit $y=1$ abdeckt.\n- Die **disjunktive Minimalform** ist eine ODER-Verknüpfung von Produkttermen (ANDs), die die Funktion mit minimaler Anzahl von Literalen/Termen beschreibt.",
    "generatedAt": "2025-12-05T17:30:56.288Z"
  },
  {
    "id": "1764955890661-uixh33r4f",
    "scriptId": "1764951148313-7m9z2z83m",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Ansteuerung einer Sieben-Segment-Anzeige\n\n## Überblick\n\nEine **Sieben-Segment-Anzeige** stellt Dezimalziffern von $0$ bis $9$ dar, indem sieben einzelne Segmente (LEDs oder LCD-Streifen) gezielt ein- oder ausgeschaltet werden.  \nZiel ist die **Entwicklung von Schaltfunktionen**, die aus einem binären Eingangswort $abcd$ (für die Ziffern $0$–$9$) die jeweils zu aktivierenden Segmente bestimmen.\n\n---\n\n## Kernkonzepte\n\n### Sieben-Segment-Anzeige\n\n- Eine Anzeige besteht aus **7 Segmenten**:\n  - Übliche Bezeichnung: $a, b, c, d, e, f, g$\n- Jedes Segment kann **einzeln angesteuert** werden.\n- Durch **Kombination** der Segmente lassen sich alle Dezimalziffern $0$–$9$ darstellen.\n\n### Binäre Eingabe\n\n- Die Eingabe sei ein **4-Bit-Binärwort**:\n  - $a, b, c, d$ sind die Eingangsvariablen (z.B. von einem BCD-Codierer)\n- Zuordnung der Binärwörter zu Dezimalziffern:\n  - $abcd = 0000 \\rightarrow 0$\n  - $abcd = 0001 \\rightarrow 1$\n  - $abcd = 0010 \\rightarrow 2$\n  - $abcd = 0011 \\rightarrow 3$\n  - $abcd = 0100 \\rightarrow 4$\n  - $abcd = 0101 \\rightarrow 5$\n  - $abcd = 0110 \\rightarrow 6$\n  - $abcd = 0111 \\rightarrow 7$\n  - $abcd = 1000 \\rightarrow 8$\n  - $abcd = 1001 \\rightarrow 9$\n\n- Für $abcd = 1010, 1011, 1100, 1101, 1110, 1111$ werden **keine Ziffern** dargestellt  \n  $\\Rightarrow$ diese Eingaben sind *Don't Cares*.\n\n---\n\n## Schaltfunktionen der Segmente\n\n### Allgemeine Form\n\nFür jedes Segment (z.B. Segment $S \\in \\{a,b,c,d,e,f,g\\}$) wird eine **Schaltfunktion** $S(a,b,c,d)$ gesucht:\n\n- $S(a,b,c,d) = 1$  \n  $\\Rightarrow$ Segment leuchtet\n- $S(a,b,c,d) = 0$  \n  $\\Rightarrow$ Segment ist aus\n\nAllgemein kann eine Funktion als **Summe von Mintermen** geschrieben werden:\n$$\nS(a,b,c,d) = \\sum m(i)\n$$\nwobei $m(i)$ die Minterme für die Dezimalziffern sind, bei denen das Segment leuchten soll.\n\n---\n\n## Wahrheitstabelle (schematisch)\n\nDa im Material nur auf die nächste Folie verwiesen wird, hier eine **strukturierte Darstellung** der Idee (ohne konkrete 0/1-Belegung für jedes Segment):\n\n| Dezimalziffer | $a b c d$ | Segment $a$ | Segment $b$ | Segment $c$ | Segment $d$ | Segment $e$ | Segment $f$ | Segment $g$ |\n|---------------|-----------|------------|------------|------------|------------|------------|------------|------------|\n| 0             | 0000      | ?          | ?          | ?          | ?          | ?          | ?          | ?          |\n| 1             | 0001      | ?          | ?          | ?          | ?          | ?          | ?          | ?          |\n| 2             | 0010      | ?          | ?          | ?          | ?          | ?          | ?          | ?          |\n| 3             | 0011      | ?          | ?          | ?          | ?          | ?          | ?          | ?          |\n| 4             | 0100      | ?          | ?          | ?          | ?          | ?          | ?          | ?          |\n| 5             | 0101      | ?          | ?          | ?          | ?          | ?          | ?          | ?          |\n| 6             | 0110      | ?          | ?          | ?          | ?          | ?          | ?          | ?          |\n| 7             | 0111      | ?          | ?          | ?          | ?          | ?          | ?          | ?          |\n| 8             | 1000      | ?          | ?          | ?          | ?          | ?          | ?          | ?          |\n| 9             | 1001      | ?          | ?          | ?          | ?          | ?          | ?          | ?          |\n| 10–15         | 1010–1111 | *Don't Care* | *Don't Care* | *Don't Care* | *Don't Care* | *Don't Care* | *Don't Care* | *Don't Care* |\n\n*Hinweis:* Die konkreten 0/1-Werte pro Segment stammen aus der im Kursmaterial erwähnten Wahrheitstabelle.\n\n---\n\n## Don't Cares\n\n### Definition\n\n*Don't Cares* sind Eingabekombinationen, für die der **Ausgangswert egal** ist, weil sie im praktischen Betrieb **nicht auftreten** oder **keine Rolle spielen**.\n\nFormell:\n- Für bestimmte Eingaben $abcd$ gilt:\n  $$\n  S(a,b,c,d) \\in \\{0,1\\} \\ \\text{beliebig}\n  $$\n- Diese Eingaben werden in der Minimierung **frei** genutzt, um die Schaltfunktion zu vereinfachen.\n\n### Anwendung im Kontext\n\n- Es sollen nur Ziffern von $0$ bis $9$ ausgegeben werden.\n- Eingabewerte $10$ bis $15$ (also $1010$ bis $1111$) werden **nie benötigt**:\n  - Für diese Eingaben haben alle Segmentfunktionen *Don't Care*-Zustand.\n\n---\n\n## Formale Beschreibung einer Segmentfunktion (Beispiel-Schema)\n\nAngenommen, für ein Segment $S$ leuchtet es bei den Ziffern $i \\in \\{0,2,3,5,7,8,9\\}$, dann:\n\n- **Unminimierte Form (Summe von Mintermen)**:\n  $$\n  S(a,b,c,d) = \\sum m(i), \\quad i \\in \\{0,2,3,5,7,8,9\\}\n  $$\n- Mit *Don't Cares* $d(i)$ für $i \\in \\{10,11,12,13,14,15\\}$:\n  $$\n  S(a,b,c,d) = \\sum m(0,2,3,5,7,8,9) + \\text{DC}(10,11,12,13,14,15)\n  $$\n\nDiese Darstellung ist die Ausgangsbasis für eine **Karnaugh-Minimierung**.\n\n---\n\n## Zusammenhang: Minimierung mit Karnaugh-Diagramm\n\n### Vorgehensweise\n\n- Für jedes Segment $S \\in \\{a,b,c,d,e,f,g\\}$:\n  1. Wahrheitstabelle ausfüllen (für Ziffern $0$–$9$).\n  2. Werte für $10$–$15$ als *Don't Cares* markieren.\n  3. In ein **4-Variablen-Karnaugh-Diagramm** eintragen.\n  4. **Gruppenbildung** (1, 2, 4, 8 Felder) unter Einbeziehung der *Don't Cares*:\n     - Ziel: möglichst große Gruppen bilden.\n  5. Aus den Gruppen die **minimierte Schaltfunktion** ablesen.\n\n### Typische Form der Ergebnisse\n\n- Minimierte Funktionen liegen meist als **SOP-Form** (Sum of Products) vor:\n  $$\n  S(a,b,c,d) = \\overline{a} \\, c \\, d + b \\, \\overline{c} + \\dots\n  $$\n- Alternativ POS-Form (Product of Sums), je nach Implementierungsvorgabe.\n\n---\n\n## Durchgerechnetes Beispiel (abstrakt)\n\n### Beispiel: Minimierung einer fiktiven Segmentfunktion $S$\n\nAngenommen:\n- $S = 1$ für Ziffern $0,1,2,5$\n- *Don't Cares* für Ziffern $10$–$15$\n\n1. **Minterm-Schreibweise**:\n   $$\n   S(a,b,c,d) = \\sum m(0,1,2,5) + \\text{DC}(10,11,12,13,14,15)\n   $$\n\n2. **Eintragen in Karnaugh-Diagramm** (4 Variablen $a,b,c,d$):\n   - Zellen für $0,1,2,5$ mit $1$\n   - Zellen für $10$–$15$ mit $X$ (*Don't Care*)\n\n3. **Gruppierung**:\n   - Nutze $X$-Zellen, um größere Blöcke zu bilden.\n   - Beispiel (vereinfacht, symbolisch):\n     - Gruppe 1: deckt $m(0,1)$ und zwei Don't-Cares\n     - Gruppe 2: deckt $m(2,5)$ und zwei Don't-Cares\n\n4. **Ablesen der Terme**:\n   - Gruppe 1 $\\Rightarrow$ Term $T_1 = \\overline{a}\\,\\overline{b}$\n   - Gruppe 2 $\\Rightarrow$ Term $T_2 = \\overline{c}\\,d$\n\n5. **Minimierte Funktion**:\n   $$\n   S(a,b,c,d) = \\overline{a}\\,\\overline{b} + \\overline{c}\\,d\n   $$\n\n*Hinweis:* Dies ist ein **abstraktes Beispiel**, um die Methode zu illustrieren, nicht die reale Funktion eines konkreten Segments.\n\n---\n\n## Merksätze\n\n- **Sieben-Segment-Anzeige**: 7 einzeln ansteuerbare Segmente, mit denen sich alle Dezimalziffern $0$–$9$ darstellen lassen.\n- **Eingangscodierung**: Ziffern werden als 4-Bit-Binärwort $abcd$ eingegeben.\n- **Segmentfunktionen**: Für jedes Segment gibt es eine boolesche Funktion $S(a,b,c,d)$.\n- **Don't Cares**: Eingabekombinationen, die im Betrieb nicht vorkommen (z.B. Ziffern $10$–$15$), dürfen beliebig als $0$ oder $1$ behandelt werden.\n- **Nutzen von Don't Cares**: Sie ermöglichen größere Gruppen im Karnaugh-Diagramm und damit **stärker minimierte Schaltfunktionen**.\n- **Ziel der Minimierung**: Weniger Gatter, geringere Schaltungs- und Kostenkomplexität.",
    "generatedAt": "2025-12-05T17:31:30.661Z"
  },
  {
    "id": "1764955932592-lq4f668zk",
    "scriptId": "1764951146375-bwfubqw1b",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Boolesche Algebra – Absorption, Tautologien und Vereinfachung\n\nKurzer Überblick:  \nDiese Notizen fassen zentrale Gesetze der booleschen Algebra zusammen, insbesondere **Absorptionsgesetze**, **allgemeingültige Ausdrücke (Tautologien)** und **algebraische Vereinfachung** mithilfe von Umformungsregeln und Wahrheitstabellen.\n\n---\n\n## 1. Kernkonzepte der booleschen Algebra\n\n### Grundoperationen\n\n- **Variablen:** $x, y \\in \\{0,1\\}$\n- **Negation (NICHT):** $\\neg x$\n- **Konjunktion (UND):** $x \\land y$\n- **Disjunktion (ODER):** $x \\lor y$\n\n### Wichtige Grundgesetze\n\n- **Idempotenz:**\n  - $x \\lor x = x$\n  - $x \\land x = x$\n- **Neutralität:**\n  - $x \\lor 0 = x$\n  - $x \\land 1 = x$\n- **Dominanz:**\n  - $x \\lor 1 = 1$\n  - $x \\land 0 = 0$\n- **Komplementarität:**\n  - $x \\lor \\neg x = 1$\n  - $x \\land \\neg x = 0$\n- **Assoziativität:**\n  - $(x \\lor y) \\lor z = x \\lor (y \\lor z)$\n  - $(x \\land y) \\land z = x \\land (y \\land z)$\n- **Kommutativität:**\n  - $x \\lor y = y \\lor x$\n  - $x \\land y = y \\land x$\n- **Distributivität:**\n  - $x \\land (y \\lor z) = (x \\land y) \\lor (x \\land z)$\n  - $x \\lor (y \\land z) = (x \\lor y) \\land (x \\lor z)$\n- **De-Morgan-Gesetze:**\n  - $\\neg(x \\land y) = \\neg x \\lor \\neg y$\n  - $\\neg(x \\lor y) = \\neg x \\land \\neg y$\n\n---\n\n## 2. Absorptionsgesetze (Aufgabe 1)\n\n### 2.1 Zu zeigende Theoreme\n\nDie folgenden beiden **Absorptionsgesetze** sollen gezeigt werden:\n\n1. $$(x \\lor \\neg y) \\land y = x \\land y$$\n2. $$(x \\land \\neg y) \\lor y = x \\lor y$$\n\n---\n\n### 2.2 Beweis mit Wahrheitstafel\n\nWir betrachten alle möglichen Belegungen von $x$ und $y$.\n\n| $x$ | $y$ | $\\neg x$ | $\\neg y$ | $x \\lor \\neg y$ | $x \\land \\neg y$ | $(x \\lor \\neg y)\\land y$ | $x \\land y$ | $(x \\land \\neg y)\\lor y$ | $x \\lor y$ |\n|-----|-----|----------|----------|-----------------|------------------|---------------------------|-------------|--------------------------|------------|\n| 0   | 0   | 1        | 1        | 1               | 0                | 0                         | 0           | 0                        | 0          |\n| 0   | 1   | 1        | 0        | 1               | 0                | 1                         | 0           | 1                        | 1          |\n| 1   | 0   | 0        | 1        | 1               | 1                | 0                         | 0           | 1                        | 1          |\n| 1   | 1   | 0        | 0        | 1               | 0                | 1                         | 1           | 1                        | 1          |\n\nVergleich der Spalten:\n\n- $(x \\lor \\neg y)\\land y$ und $x \\land y$ sind in allen Zeilen gleich.\n- $(x \\land \\neg y)\\lor y$ und $x \\lor y$ sind in allen Zeilen gleich.\n\nDamit sind beide Theoreme durch die Wahrheitstafel bewiesen.\n\n---\n\n### 2.3 Algebraischer Beweis\n\n#### 2.3.1 Beweis von $(x \\lor \\neg y)\\land y = x \\land y$\n\nAusgangsausdruck:\n$$(x \\lor \\neg y)\\land y$$\n\n1. Distributivität von $\\land$ über $\\lor$:\n   $$(x \\lor \\neg y)\\land y = (x \\land y) \\lor (\\neg y \\land y)$$\n2. Komplementarität:\n   $$\\neg y \\land y = 0$$\n   also:\n   $$(x \\land y) \\lor 0 = x \\land y$$\n3. Neutralität von $0$ bei $\\lor$:\n   $$x \\land y = x \\land y$$\n\nDamit:\n$$(x \\lor \\neg y)\\land y = x \\land y$$\n\n---\n\n#### 2.3.2 Beweis von $(x \\land \\neg y)\\lor y = x \\lor y$\n\nAusgangsausdruck:\n$$(x \\land \\neg y)\\lor y$$\n\n1. Distributivität von $\\lor$ über $\\land$:\n   $$(x \\land \\neg y)\\lor y = (x \\lor y)\\land (\\neg y \\lor y)$$\n2. Komplementarität:\n   $$\\neg y \\lor y = 1$$\n   also:\n   $$(x \\lor y)\\land 1 = x \\lor y$$\n3. Neutralität von $1$ bei $\\land$:\n   $$x \\lor y = x \\lor y$$\n\nDamit:\n$$(x \\land \\neg y)\\lor y = x \\lor y$$\n\n---\n\n## 3. Allgemeingültige Ausdrücke (Tautologien) (Aufgabe 2)\n\n### 3.1 Zu zeigende Tautologien\n\nDie folgenden Ausdrücke sollen **allgemeingültig** (immer wahr) sein:\n\n1. $$\\neg(x \\land y) \\lor x \\lor y$$\n2. $$(x \\land y) \\lor \\neg\\bigl((x \\lor \\neg y)\\land y\\bigr)$$\n\n---\n\n### 3.2 Beweis per Wahrheitstafel\n\n#### 3.2.1 Tautologie 1: $\\neg(x \\land y) \\lor x \\lor y$\n\n| $x$ | $y$ | $x \\land y$ | $\\neg(x \\land y)$ | $\\neg(x \\land y)\\lor x$ | $\\neg(x \\land y)\\lor x \\lor y$ |\n|-----|-----|-------------|-------------------|--------------------------|--------------------------------|\n| 0   | 0   | 0           | 1                 | 1                        | 1                              |\n| 0   | 1   | 0           | 1                 | 1                        | 1                              |\n| 1   | 0   | 0           | 1                 | 1                        | 1                              |\n| 1   | 1   | 1           | 0                 | 1                        | 1                              |\n\nLetzte Spalte ist immer $1$ → Ausdruck ist eine Tautologie.\n\n---\n\n#### 3.2.2 Tautologie 2: $(x \\land y) \\lor \\neg((x \\lor \\neg y)\\land y)$\n\n| $x$ | $y$ | $\\neg y$ | $x \\lor \\neg y$ | $(x \\lor \\neg y)\\land y$ | $\\neg((x \\lor \\neg y)\\land y)$ | $x \\land y$ | $(x \\land y)\\lor \\neg((x \\lor \\neg y)\\land y)$ |\n|-----|-----|----------|-----------------|---------------------------|---------------------------------|-------------|-----------------------------------------------|\n| 0   | 0   | 1        | 1               | 0                         | 1                               | 0           | 1                                             |\n| 0   | 1   | 0        | 1               | 1                         | 0                               | 0           | 0 \\lor 0 = 0? → hier aufpassen                |\n| 1   | 0   | 1        | 1               | 0                         | 1                               | 0           | 1                                             |\n| 1   | 1   | 0        | 1               | 1                         | 0                               | 1           | 1                                             |\n\nWichtiger Punkt:  \nAus Aufgabe 1 wissen wir bereits:\n$$(x \\lor \\neg y)\\land y = x \\land y$$\n\nDaher ist die Wahrheitstafel einfacher wie folgt:\n\n| $x$ | $y$ | $x \\land y$ | $\\neg((x \\lor \\neg y)\\land y)$ | $(x \\land y)\\lor \\neg((x \\lor \\neg y)\\land y)$ |\n|-----|-----|-------------|---------------------------------|-----------------------------------------------|\n| 0   | 0   | 0           | $\\neg 0 = 1$                    | 1                                             |\n| 0   | 1   | 0           | $\\neg 0 = 1$                    | 1                                             |\n| 1   | 0   | 0           | $\\neg 0 = 1$                    | 1                                             |\n| 1   | 1   | 1           | $\\neg 1 = 0$                    | 1                                             |\n\nLetzte Spalte ist immer $1$ → Ausdruck ist eine Tautologie.\n\n*(Hinweis: Die zuvor angedeutete Zeile mit „0?“ war nur zur Illustration – korrekt ist die vereinfachte Tabelle mit Nutzung von Aufgabe 1.)*\n\n---\n\n### 3.3 Algebraische Umformung der Tautologien\n\n#### 3.3.1 $\\neg(x \\land y) \\lor x \\lor y$\n\nAusgangsausdruck:\n$$\\neg(x \\land y) \\lor x \\lor y$$\n\n1. De-Morgan:\n   $$\\neg(x \\land y) = \\neg x \\lor \\neg y$$\n   also:\n   $$(\\neg x \\lor \\neg y) \\lor x \\lor y$$\n2. Assoziativität & Kommutativität:\n   $$(\\neg x \\lor x) \\lor (\\neg y \\lor y)$$\n3. Komplementarität:\n   $$\\neg x \\lor x = 1,\\quad \\neg y \\lor y = 1$$\n   damit:\n   $$1 \\lor 1 = 1$$\n\nDer Ausdruck ist immer $1$ → Tautologie.\n\n---\n\n#### 3.3.2 $(x \\land y) \\lor \\neg((x \\lor \\neg y)\\land y)$\n\nNutze zuerst das Ergebnis aus Aufgabe 1:\n$$(x \\lor \\neg y)\\land y = x \\land y$$\n\nDamit wird:\n$$(x \\land y) \\lor \\neg((x \\lor \\neg y)\\land y) = (x \\land y) \\lor \\neg(x \\land y)$$\n\nNun:\n\n1. Komplementarität:\n   $$(x \\land y) \\lor \\neg(x \\land y) = 1$$\n\nAlso ist der Ausdruck immer $1$ → Tautologie.\n\n---\n\n## 4. Vereinfachung boolescher Ausdrücke (Aufgabe 3)\n\n*(Die konkrete Liste der Ausdrücke ist im Material nicht vollständig sichtbar. Hier die generelle Vorgehensweise mit typischen Beispielen.)*\n\n### 4.1 Wichtige Vereinfachungsregeln\n\n- **Absorption:**\n  - $x \\lor (x \\land y) = x$\n  - $x \\land (x \\lor y) = x$\n  - Varianten mit Negation:\n    - $(x \\lor \\neg y)\\land y = x \\land y$\n    - $(x \\land \\neg y)\\lor y = x \\lor y$\n- **Redundanzbeseitigung:**\n  - $x \\lor (x \\lor y) = x \\lor y$\n  - $x \\land (x \\land y) = x \\land y$\n- **Doppelte Negation:**\n  - $\\neg(\\neg x) = x$\n\n---\n\n### 4.2 Typische Vereinfachungsbeispiele\n\n#### Beispiel 1\n\nVereinfachen:\n$$(x \\land y) \\lor (x \\land \\neg y)$$\n\n1. Faktorisieren (Distributivität):\n   $$(x \\land y) \\lor (x \\land \\neg y) = x \\land (y \\lor \\neg y)$$\n2. Komplementarität:\n   $$y \\lor \\neg y = 1$$\n   also:\n   $$x \\land 1 = x$$\n\n**Ergebnis:**  \n$$(x \\land y) \\lor (x \\land \\neg y) = x$$\n\n---\n\n#### Beispiel 2\n\nVereinfachen:\n$$(x \\lor y)\\land (x \\lor \\neg y)$$\n\n1. Distributivität:\n   $$(x \\lor y)\\land (x \\lor \\neg y) = x \\lor (y \\land \\neg y)$$\n2. Komplementarität:\n   $$y \\land \\neg y = 0$$\n   also:\n   $$x \\lor 0 = x$$\n\n**Ergebnis:**  \n$$(x \\lor y)\\land (x \\lor \\neg y) = x$$\n\n---\n\n#### Beispiel 3 (mit Absorption)\n\nVereinfachen:\n$$x \\lor (x \\land y)$$\n\n1. Absorptionsgesetz:\n   $$x \\lor (x \\land y) = x$$\n\n**Ergebnis:**  \n$$x \\lor (x \\land y) = x$$\n\n---\n\n## 5. Merksätze\n\n- **Absorption (Grundform):**\n  - $x \\lor (x \\land y) = x$\n  - $x \\land (x \\lor y) = x$\n- **Absorption mit Negation (aus Aufgabe 1):**\n  - $(x \\lor \\neg y)\\land y = x \\land y$\n  - $(x \\land \\neg y)\\lor y = x \\lor y$\n- **Tautologien (aus Aufgabe 2):**\n  - $\\neg(x \\land y) \\lor x \\lor y = 1$\n  - $(x \\land y) \\lor \\neg((x \\lor \\neg y)\\land y) = 1$\n- **Strategie zur Vereinfachung:**\n  - Nutze zuerst Komplementarität ($x \\lor \\neg x$, $x \\land \\neg x$).\n  - Wende Absorptionsgesetze an, um Terme zu kürzen.\n  - Setze Distributivität gezielt ein, um gemeinsame Faktoren herauszuziehen.\n- **Wahrheitstafel vs. Algebra:**\n  - *Wahrheitstafel*: zeigt Allgemeingültigkeit durch Auswertung aller Fälle.\n  - *Algebraische Umformung*: zeigt Gleichheit durch schrittweise Anwendung der Gesetze.",
    "generatedAt": "2025-12-05T17:32:12.592Z"
  },
  {
    "id": "1764955982037-a28mh0j4l",
    "scriptId": "1764951144352-g50i3zo49",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Darstellung von Zahlen und Zeichen\n\nKurzer Überblick: In diesem Themenblock geht es um **Positionssysteme**, **Basisumrechnungen**, **Summenschreibweise**, **Hornerschema**, **Zweierkomplement** und **IEEE‑754 Gleitkommazahlen**.\n\n---\n\n## 1. Positionssysteme und Summenschreibweise\n\n### 1.1 Grundbegriffe\n\n- *Positionssystem*: Eine Zahl wird als Summe von Ziffern mal Potenzen einer Basis $b$ dargestellt.\n- **Allgemeine Form** (Ganzzahl):\n  $$ (a_{n-1}\\dots a_1 a_0)_b = \\sum_{i=0}^{n-1} a_i \\cdot b^i $$\n- **Mit Nachkommastellen**:\n  $$ (a_{n-1}\\dots a_0 . a_{-1} a_{-2} \\dots)_b = \\sum_{i=-k}^{n-1} a_i \\cdot b^i $$\n\n### 1.2 Beispiele: Summenschreibweise und Dezimalwert\n\n#### Beispiel 1: $(312)_4$\n\nSummenschreibweise:\n$$ (312)_4 = 3\\cdot 4^2 + 1\\cdot 4^1 + 2\\cdot 4^0 $$\n\nBerechnung:\n$$ 3\\cdot 16 + 1\\cdot 4 + 2\\cdot 1 = 48 + 4 + 2 = 54_{10} $$\n\n#### Beispiel 2: $(101011)_2$\n\nSummenschreibweise:\n$$ (101011)_2 = 1\\cdot 2^5 + 0\\cdot 2^4 + 1\\cdot 2^3 + 0\\cdot 2^2 + 1\\cdot 2^1 + 1\\cdot 2^0 $$\n\nBerechnung:\n$$ 32 + 0 + 8 + 0 + 2 + 1 = 43_{10} $$\n\n#### Beispiel 3: Mit Nachkommastellen – $(1573.4)_8$\n\nSummenschreibweise:\n$$\n(1573.4)_8 = 1\\cdot 8^3 + 5\\cdot 8^2 + 7\\cdot 8^1 + 3\\cdot 8^0 + 4\\cdot 8^{-1}\n$$\n\nBerechnung:\n- $1\\cdot 512 = 512$\n- $5\\cdot 64 = 320$\n- $7\\cdot 8 = 56$\n- $3\\cdot 1 = 3$\n- $4\\cdot \\frac{1}{8} = 0{,}5$\n\n$$ (1573.4)_8 = 512 + 320 + 56 + 3 + 0{,}5 = 891{,}5_{10} $$\n\n#### Beispiel 4: $(1011.1101)_2$\n\nSummenschreibweise:\n$$\n(1011.1101)_2 = 1\\cdot 2^3 + 0\\cdot 2^2 + 1\\cdot 2^1 + 1\\cdot 2^0\n+ 1\\cdot 2^{-1} + 1\\cdot 2^{-2} + 0\\cdot 2^{-3} + 1\\cdot 2^{-4}\n$$\n\nBerechnung:\n- Ganzteil: $8 + 0 + 2 + 1 = 11$\n- Nachkommateil: $\\frac{1}{2} + \\frac{1}{4} + 0 + \\frac{1}{16} = 0{,}5 + 0{,}25 + 0{,}0625 = 0{,}8125$\n\n$$ (1011.1101)_2 = 11{,}8125_{10} $$\n\n### 1.3 Merksätze\n\n- Jede Ziffer steht für **Zifferwert $\\cdot$ Basis$^{\\text{Position}}$**.\n- Nachkommastellen haben **negative Exponenten**: $b^{-1}, b^{-2}, \\dots$.\n\n---\n\n## 2. Effiziente Basisumrechnung (Binär, Oktal, Hex)\n\n### 2.1 Zusammenhang der Basen\n\n- $2^3 = 8$ → **3 Binärstellen = 1 Oktalstelle**\n- $2^4 = 16$ → **4 Binärstellen = 1 Hexadezimalstelle**\n\n### 2.2 Vorgehen\n\n- Von Hex nach Oktal:\n  - Hex → Binär (jede Hex-Ziffer zu 4 Bits)\n  - Binär → Oktal (Bits in 3er-Gruppen zusammenfassen)\n\n### 2.3 Beispiel: $(\\text{ABBA})_{16}$ nach Oktal\n\n1. **Hex → Binär**\n\n   | Hex | Binär |\n   |-----|-------|\n   | A   | 1010  |\n   | B   | 1011  |\n   | B   | 1011  |\n   | A   | 1010  |\n\n   $$ (\\text{ABBA})_{16} = 1010\\ 1011\\ 1011\\ 1010_2 $$\n\n2. **Binär in 3er-Gruppen (von rechts)**\n\n   $$ 1\\ 010\\ 101\\ 110\\ 110\\ 10_2 $$\n\n   Auffüllen links mit Nullen:\n   $$ 001\\ 010\\ 101\\ 110\\ 110\\ 010_2 $$\n\n3. **Jede 3er-Gruppe in Oktal**\n\n   | Binär | Oktal |\n   |-------|-------|\n   | 001   | 1     |\n   | 010   | 2     |\n   | 101   | 5     |\n   | 110   | 6     |\n   | 110   | 6     |\n   | 010   | 2     |\n\n   $$ (\\text{ABBA})_{16} = (125662)_8 $$\n\n### 2.4 Merksätze\n\n- **Nie direkt Hex ↔ Oktal rechnen**, immer über Binär.\n- Links mit Nullen auffüllen, damit die Gruppengröße passt.\n\n---\n\n## 3. Hornerschema zur Basis-zu-Dezimal-Umrechnung\n\n### 3.1 Idee\n\nStatt Summenschreibweise:\n\n$$ (a_{n-1}\\dots a_0)_b = (((a_{n-1}\\cdot b + a_{n-2})\\cdot b + a_{n-3})\\cdots\\cdot b + a_0) $$\n\nDas ist das **Hornerschema**.\n\n### 3.2 Algorithmus (Ganzzahlen)\n\n- Starte mit $r = a_{n-1}$.\n- Für jede weitere Ziffer $a_i$:\n  $$ r \\leftarrow r \\cdot b + a_i $$\n\n### 3.3 Beispiel: $(375)_8$ nach Dezimal\n\nBasis $b = 8$, Ziffern: $3, 7, 5$\n\n1. Start: $r = 3$\n2. Nächste Ziffer $7$: \n   $$ r = 3\\cdot 8 + 7 = 24 + 7 = 31 $$\n3. Nächste Ziffer $5$:\n   $$ r = 31\\cdot 8 + 5 = 248 + 5 = 253 $$\n\nErgebnis:\n$$ (375)_8 = 253_{10} $$\n\n### 3.4 Beispiel: $(\\text{ADA})_{16}$ nach Dezimal\n\nHex-Ziffern: A=10, D=13, A=10\n\n1. Start: $r = 10$\n2. Nächste Ziffer 13:\n   $$ r = 10\\cdot 16 + 13 = 160 + 13 = 173 $$\n3. Nächste Ziffer 10:\n   $$ r = 173\\cdot 16 + 10 = 2768 + 10 = 2778 $$\n\nErgebnis:\n$$ (\\text{ADA})_{16} = 2778_{10} $$\n\n### 3.5 Merksätze\n\n- Hornerschema reduziert viele Potenzen auf **wiederholtes Multiplizieren und Addieren**.\n- Besonders effizient für **programmierte Umrechnungen**.\n\n---\n\n## 4. Von Dezimal in andere Basen\n\n### 4.1 Ganzzahlen: Division mit Rest\n\n- Wiederholte Division durch Basis $b$.\n- **Reste** bilden die Ziffern von **rechts nach links**.\n\n#### Beispiel: $(1234)_{10}$ ins Siebenersystem\n\n1. $1234 : 7 = 176$ Rest $2$\n2. $176 : 7 = 25$ Rest $1$\n3. $25 : 7 = 3$ Rest $4$\n4. $3 : 7 = 0$ Rest $3$\n\nReste von unten nach oben lesen: $3\\,4\\,1\\,2$\n\n$$ (1234)_{10} = (3412)_7 $$\n\n### 4.2 Nachkommastellen: Multiplikation mit Basis\n\n- Wiederholt: $x \\leftarrow x\\cdot b$\n- **Ganzzahlteile** der Produkte werden nacheinander die Ziffern nach dem Komma.\n\n#### Beispiel: $(0{,}19)_{10}$ ins Hexadezimalsystem\n\nBasis $b = 16$.\n\n1. $0{,}19\\cdot 16 = 3{,}04$ → Ziffer: $3$\n2. $0{,}04\\cdot 16 = 0{,}64$ → Ziffer: $0$\n3. $0{,}64\\cdot 16 = 10{,}24$ → Ziffer: $A$\n4. $0{,}24\\cdot 16 = 3{,}84$ → Ziffer: $3$\n   usw.\n\nApproximation (z.B. 4 Stellen):\n$$ (0{,}19)_{10} \\approx (0{,}30A3)_{16} $$\n\n### 4.3 Merksätze\n\n- Ganzteil: **Division mit Rest**.\n- Nachkommateil: **Multiplikation mit Basis**.\n- Repräsentation kann **periodisch** sein und wird oft **abgeschnitten oder gerundet**.\n\n---\n\n## 5. Rechnen über das Dualsystem\n\n### 5.1 Vorgehen bei Aufgaben\n\n1. Dezimalzahlen in **Binär** umwandeln.\n2. **Binäraddition** ausführen.\n3. Ergebnis bei Bedarf wieder in Dezimal umwandeln.\n\n### 5.2 Beispiel: $(15)_{10} + (31)_{10}$ im Dualsystem\n\n1. Umwandlung:\n   - $15_{10} = 1111_2$\n   - $31_{10} = 11111_2$\n\n2. Addition (mit Auffüllen):\n   $$ 0\\,1111_2 + 1\\,1111_2 = 10\\,1110_2 $$\n\n3. Kontrolle in Dezimal:\n   - $15 + 31 = 46$\n   - $10\\,1110_2 = 32 + 8 + 4 + 2 = 46$\n\n### 5.3 Merksätze\n\n- Binäraddition wie Dezimaladdition, aber mit Basis $2$:\n  - $0+0=0$\n  - $0+1=1$\n  - $1+1=10_2$ (Ergebnis $0$, Übertrag $1$)\n  - $1+1+1=11_2$ (Ergebnis $1$, Übertrag $1$)\n\n---\n\n## 6. Zweierkomplement und Subtraktion\n\n### 6.1 Darstellung im Zweierkomplement\n\nFür $n$ Bit:\n\n- Wertebereich:\n  $$ -2^{n-1} \\leq x \\leq 2^{n-1}-1 $$\n- Positiv: **normale Binärdarstellung**, führendes Bit $0$.\n- Negativ: \n  - Betrag binär darstellen\n  - **Bitweise invertieren**\n  - **$+1$ addieren**\n\n### 6.2 Subtraktion mit Zweierkomplement\n\n$$ a - b = a + (\\text{Zweierkomplement von } b) $$\n\n### 6.3 Beispiel: $(57)_{10} - (122)_{10}$ mit 8 Bit\n\n1. Wertebereich bei 8 Bit:\n   $$ -128 \\leq x \\leq 127 $$\n   Ergebnis erwartet: $57 - 122 = -65$ (im Bereich)\n\n2. $57_{10}$ in 8 Bit:\n   $$ 57_{10} = 00111001_2 $$\n\n3. $122_{10}$ in 8 Bit:\n   $$ 122_{10} = 01111010_2 $$\n\n4. Zweierkomplement von $122$:\n   - Invertieren: $10000101_2$\n   - $+1$: $10000110_2$\n\n   $$ -122_{10} = 10000110_2 $$\n\n5. Addition:\n   $$ \n   \\begin{aligned}\n   00111001_2 \\\\\n   +\\ 10000110_2 \\\\\n   \\hline\n   10111111_2\n   \\end{aligned}\n   $$\n\n6. Interpretation von $10111111_2$ (negativ, da MSB = 1):\n\n   - Invertieren: $01000000_2$\n   - $+1$: $01000001_2 = 65_{10}$\n\n   Also:\n   $$ 10111111_2 = -65_{10} $$\n\n### 6.4 Merksätze\n\n- MSB $1$ → Zahl ist **negativ**.\n- Zweierkomplement ist **eindeutig** und erlaubt **Addition auch für Subtraktion**.\n- Überlauf bei Operationen prüfen (MSB-Wechsel ohne Sinn).\n\n---\n\n## 7. IEEE 754 Gleitkommadarstellung (float, 32 Bit)\n\n### 7.1 Aufbau (Single Precision)\n\n- **1 Bit**: Vorzeichen $s$\n- **8 Bit**: Exponent $E$ (mit Bias $127$)\n- **23 Bit**: Mantisse $M$ (ohne führende $1$)\n\nWert:\n$$\nx = (-1)^s \\cdot 1.f \\cdot 2^{E-127}\n$$\nwobei $1.f$ die **normierte Mantisse** ist.\n\n### 7.2 Allgemeines Vorgehen\n\n1. Dezimalzahl in **Binär** umwandeln.\n2. In Form $x = \\pm 1,\\text{Mantisse} \\cdot 2^e$ bringen.\n3. Exponent:\n   $$ E = e + 127 $$\n4. Mantisse: Bits nach dem führenden $1,$ als 23 Bit.\n\n### 7.3 Beispiel: $125{,}875$\n\n1. Ganzteil $125$:\n   $$ 125_{10} = 1111101_2 $$\n2. Nachkommateil $0{,}875$:\n   - $0{,}875 = \\frac{7}{8} = 0{,}111_2$\n\n   $$ 125{,}875_{10} = 1111101{,}111_2 $$\n\n3. Normiert:\n   $$ 1111101{,}111_2 = 1{,}111101111 \\cdot 2^6 $$\n\n   → $e = 6$\n\n4. Exponent:\n   $$ E = 6 + 127 = 133_{10} = 10000101_2 $$\n\n5. Vorzeichen: $s = 0$\n\n6. Mantisse (23 Bit) nach dem Komma:\n   $$ f = 11110111100000000000000_2 $$\n\n7. IEEE 754 (float, 32 Bit):\n\n   | s | Exponent (8 Bit) | Mantisse (23 Bit)           |\n   |---|------------------|-----------------------------|\n   | 0 | 10000101         | 11110111100000000000000     |\n\n   $$ 125{,}875 \\to 0\\ 10000101\\ 11110111100000000000000_2 $$\n\n### 7.4 Merksätze\n\n- **Bias bei float**: $127$.\n- Normierte Form immer: $1,\\text{Mantisse}\\cdot 2^e$ (außer Spezialfälle: 0, Inf, NaN).\n- Mantisse speichert **nur die Nachkommabits** der normierten Darstellung.\n\n---\n\n## 8. Kompakte Merkliste\n\n- **Summenschreibweise**:\n  $$ (a_{n-1}\\dots a_0)_b = \\sum_{i=0}^{n-1} a_i b^i $$\n- **Hornerschema**:\n  $$ r \\leftarrow ((a_{n-1}b + a_{n-2})b + \\dots )b + a_0 $$\n- **Dezimal → andere Basis**:\n  - Ganzteil: Division mit Rest.\n  - Nachkommateil: Multiplikation mit Basis.\n- **Zweierkomplement**:\n  - Negativ: Invertieren + 1.\n  - Subtraktion: $a-b = a + (\\text{ZK von } b)$.\n- **IEEE 754 (float)**:\n  - $x = (-1)^s \\cdot 1.f \\cdot 2^{E-127}$.\n  - 1 Bit Vorzeichen, 8 Bit Exponent, 23 Bit Mantisse.",
    "generatedAt": "2025-12-05T17:33:02.037Z"
  },
  {
    "id": "1764956054237-as3wqhj1o",
    "scriptId": "1764951119718-s070vuskv",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Rechnerarchitektur, Mikroprozessoren und Pipelining\n\nKurze Übersicht: Diese Notizen fassen die Grundlagen von Rechner-/Computersystemen, der Von-Neumann-Architektur, generischen Prozessorarchitekturen, Befehlssatzarchitekturen und Pipelining zusammen.\n\n---\n\n## Rechner, Computersystem und Rechnerarchitektur\n\n### Was ist ein Computer?\n\n*Definition:*  \nEin **Computer** ist eine *elektronisch arbeitende Einrichtung*, die Probleme dadurch löst, dass sie **Daten nach einem vorgegebenen Algorithmus bzw. Programm verarbeitet**.\n\nWesentliche Punkte:\n- Verarbeitung von **Daten**\n- Ausführung eines **Programms** (Algorithmus)\n- Elektronische Realisierung\n\n---\n\n### Was ist ein Computersystem?\n\n*Definition:*  \nEin **Computersystem** besteht aus dem Computer und allen zugehörigen **Peripheriegeräten**.\n\nBestandteile:\n- **Rechner (CPU + Hauptspeicher)**\n- **Eingabegeräte**: z.B. Tastatur, Maus, Scanner\n- **Ausgabegeräte**: z.B. Monitor, Drucker\n- **Sekundärspeicher**: z.B. Festplatte, SSD, USB-Stick\n\n---\n\n### Was ist Rechnerarchitektur?\n\nUnterscheidung in **externe** und **interne** Architektur:\n\n- **Externe Architektur** (für Programmierer sichtbar)  \n  → wird oft als **Rechnerarchitektur** oder **Rechnerstrukturen** bezeichnet\n  - **Befehlssatz** (Instruction Set)\n  - **Adressierungsarten**\n  - **Datenbreite** (z.B. $32$ Bit, $64$ Bit)\n  - **Ein-/Ausgabemechanismen**\n\n- **Interne Architektur** (Implementierung)  \n  → wird oft als **Rechnerorganisation** bezeichnet\n  - **Kontrollsignale**\n  - **Schnittstellen**\n  - **Speicherorganisation** (Caches, Busse, etc.)\n\n**Merksatz:**  \n- *Rechnerarchitektur* = Was die Software „sieht“  \n- *Rechnerorganisation* = Wie es hardwareseitig umgesetzt ist\n\n---\n\n## Das Von-Neumann-Konzept\n\n### Grundidee und Komponenten\n\n*Definition:*  \nDas **Von-Neumann-Konzept** beschreibt das klassische **Grundprinzip eines Computersystems**, das bis heute den Aufbau moderner Mikroprozessoren prägt.\n\nWesentliche Komponenten:\n- **CPU** (Central Processing Unit)\n  - **Steuerwerk** (Control Unit)\n  - **Rechenwerk** (ALU / Akkumulator)\n- **Hauptspeicher** (Memory)\n- **Ein-/Ausgabewerk** (I/O)\n- **Bussystem** zur Verbindung der Komponenten\n\nHeutige Systeme:\n- Häufig **mehrere Prozessoren** → **Multiprozessorsysteme**\n\n---\n\n### Aufbau der CPU (Von-Neumann)\n\n- **Steuerwerk**\n  - lädt **Anweisungen** aus dem Speicher\n  - **decodiert** diese\n  - erzeugt eine **Sequenz von Steuersignalen** für Rechenwerk und andere Einheiten\n\n- **Rechenwerk**\n  - besteht aus **ALU** (Arithmetic Logic Unit) oder **Akkumulatorregister**\n  - lädt **Daten** aus dem Hauptspeicher\n  - **verknüpft** diese gemäß den Steuersignalen\n  - schreibt **Ergebnisse** zurück in den Speicher\n\n---\n\n### Hauptspeicher und Ein-/Ausgabewerk\n\n- **Hauptspeicher**\n  - speichert **Daten** und **Anweisungen** in **Binärform**\n  - **wahlfreier Zugriff** (Random Access)\n  - Zugriff über **Hauptspeicheradressen**\n  - **Lese- und Schreibzugriffe** möglich\n\n- **Ein-/Ausgabewerk**\n  - vermittelt zwischen CPU/Speicher und **Peripheriegeräten**\n  - Beispiele: Tastatur, Monitor, Drucker, Festplatten, Netzwerk\n\n---\n\n### Funktionsweise & Eigenschaften des Von-Neumann-Rechners\n\nEigenschaften:\n- **Programmgesteuert**\n  - im Speicher abgelegte Datenwörter werden von der CPU gemäß einem **definierten Befehlssatz** interpretiert und ausgeführt\n\n- **Universelles Berechnungsmodell**\n  - nicht für eine spezielle Aufgabe fest verdrahtet\n  - Befehlssatz muss **jeden möglichen Algorithmus** ausdrücken können (Turing-Vollständigkeit)\n\n- **Datenaustausch mit dem Speicher**\n  - Daten und Anweisungen liegen **gemeinsam im Hauptspeicher**\n  - Speicher ist **Schreib-Lese-Speicher**\n\n- **Keine Trennung zwischen Daten und Programm**\n  - CPU entscheidet, ob ein Wort als **Datenwort** oder **Befehlswort** interpretiert wird\n  - Alternative: **Harvard-Architektur** (Trennung von Daten- und Programmspeicher)\n\n- **Sprungfähigkeit**\n  - Programmfluss kann durch **Sprungbefehle** (z.B. bedingte/unbedingte Sprünge) verändert werden\n\n**Zusätzlicher Nachteil der Von-Neumann-Architektur:**  \n- **Von-Neumann-Flaschenhals**:  \n  - Daten und Instruktionen teilen sich **denselben Bus**  \n  - begrenzte **Bandbreite** → limitiert die Ausführungsgeschwindigkeit\n\n---\n\n### Abstraktionsebenen von Programmiersprachen\n\nEbenen (von hoch nach niedrig):\n- **Nicht-prozedurale Sprachen**  \n  - z.B. deklarative / logische Sprachen  \n  - abstrakte Datentypen, Datenfluss, Nachrichtenübertragung, Inferenz\n\n- **Höhere Programmiersprachen**  \n  - zusammengesetzte Datentypen  \n  - Kontrollstrukturen: **Sequenz, Verzweigung, Iteration**  \n  - Strukturelemente: **Module, Klassen, Funktionen**\n\n- **Einfache Programmiersprachen**  \n  - einfache Datentypen  \n  - Prozeduren, Funktionen\n\n- **Assembler**\n  - (interpretierte) **Bitstrings**\n  - Sprünge, Makros\n\n- **Maschinensprache**\n  - reine **Bitstrings** (binäre Befehle)\n\nÜbersetzungskette:\n- Höhere Sprache $\\rightarrow$ **Compiler** $\\rightarrow$ Assembler  \n- Assembler $\\rightarrow$ **Assembler-Übersetzer** $\\rightarrow$ Maschinensprache\n\n---\n\n### Beispiel: Von Hochsprache zu Assembler\n\nGegeben:  \n```c\nif (x != 0) y = y + 1;\n```\n\nMögliche Assembler-Sequenz:\n- `LDA 14`  // Operand $x$ aus Speicherstelle $14$ laden\n- `BRZ weiter`  // wenn $x = 0$ → springe zu `weiter`\n- `LDA 15`  // Operand $y$ aus Speicherstelle $15$ laden\n- `ADD #1`  // Addition von $1$\n- `STA 15`  // neues $y$ in Speicherstelle $15$ speichern\n\n---\n\n## Systembus-Konzept\n\n### Bus-Arten\n\nDas **Systembus-Konzept** verfeinert das Von-Neumann-Modell, indem es die Kommunikation über Busse strukturiert:\n\n- **Adressbus** (unidirektional)\n  - übermittelt **Speicheradressen** von der CPU an den Speicher\n\n- **Datenbus** (bidirektional)\n  - überträgt **Daten/Operanden** zwischen CPU und Speicher/Peripherie\n\n- **Steuerbus** (unidirektional)\n  - überträgt **Kontrollsignale** (z.B. Lese-/Schreibanforderung, Takt, Interrupts)\n\n**Merksatz:**  \n- Adressbus: *Wo?*  \n- Datenbus: *Was?*  \n- Steuerbus: *Wie/Wann?*\n\n---\n\n## Generische Prozessorarchitektur\n\n### Hauptkomponenten\n\n- **Steuerwerk**\n  - überwacht **Kontroll- und Datenfluss**\n  - steuert **Datentransport** zwischen Registern, ALU und Außenwelt\n\n- **Registersatz**\n  - sehr schnelle, interne **Speicherelemente**\n  - enthält:\n    - **Universalregister** (z.B. $R1, R2, R3, \\dots$)\n    - **Hilfsregister** (PC, SR, SP, …)\n\n- **Rechenwerk (ALU)**\n  - führt **arithmetische** und **logische** Operationen aus\n\n---\n\n### Registersatz im Detail\n\n*Definition:*  \n**Register** sind kleine, sehr schnelle Speicher im Prozessorkern. Ihre Wortbreite entspricht typischerweise der **Datenwortbreite** des Prozessors (z.B. $32$ oder $64$ Bit).\n\n#### Universalregister\n- dienen zur **Zwischenspeicherung von Datenworten**\n- können mit **beliebigen Werten** befüllt werden\n- theoretisch wäre **ein** Universalregister ausreichend,  \n  aber:\n  - Zwischenergebnisse müssten ständig in den **langsamen Hauptspeicher** geschrieben werden\n- reale Mikroprozessoren: **ca. $20$ bis $200$ Register**\n\n#### Hilfsregister\n\n- **Instruktionszähler / Programmzähler (Program Counter, PC)**\n  - enthält die **Adresse des nächsten Befehls**\n  - nach dem Holen eines Befehls: $PC := PC + 1$\n  - **Sprünge**: durch Überschreiben des PC-Inhalts\n\n- **Statusregister (Status Register, SR)**\n  - wird von der ALU nach jeder Operation **beschrieben**\n  - enthält **Statusbits** über das letzte Ergebnis, z.B.:\n    - **Carry-Bit $C$** – Überlaufprüfung\n    - **Zero-Bit $Z$** – Ergebnis ist $0$\n    - **Negative-Flag $N$** – Ergebnis ist negativ\n\n  Beispielhafte Bitbelegung:\n  | Bit | Bedeutung |\n  |-----|-----------|\n  |  C  | Carry     |\n  |  Z  | Zero      |\n  |  N  | Negative  |\n\n- **Stapelregister (Stack Pointer, SP)**\n  - zeigt auf die **aktuelle Spitze des Stacks**\n  - wichtig für **Unterprogramme/Funktionsaufrufe**\n  - ermöglicht Rücksprung, ohne PC zu überschreiben\n\n---\n\n### Befehlsverarbeitung in der CPU\n\nTypische Phasen (einfaches Modell):\n\n1. **Fetch** (Befehlsholphase)\n   - Befehl wird aus dem **Hauptspeicher** an der Adresse $PC$ geladen\n   - Befehl wird in die CPU eingelesen\n   - $PC := PC + 1$\n\n2. **Decode** (Decodierphase)\n   - Befehl wird **interpretiert**\n   - benötigte **Operanden** werden identifiziert/geladen\n\n3. **Execute** (Ausführungsphase)\n   - ALU führt die **Operation** aus (z.B. Addition, Vergleich)\n\n4. **Write Back** (Speicherphase)\n   - Ergebnis wird:\n     - in den **Speicher** geschrieben oder\n     - in ein **Register** abgelegt oder\n     - als **Sprungadresse** verwendet\n\n---\n\n## Entwicklung von Prozessorarchitekturen (historisch)\n\n- **1940er**: Akkumulator-Architekturen\n  - wenige Register, zentrale Rolle des **Akkumulators**\n\n- **1950er**: Load/Store-Architekturen (Register-Register)\n  - Leistungssteigerung durch **schnelle Allzweckregister**\n\n- **1960er**: Stack-Architekturen\n  - stark an **Programmiersprachen/Compiler** angepasst\n\n- **1970er**: Storage/Storage-Architekturen\n  - komplexe Maschineninstruktionen, einfache Übersetzung\n\n- **1980er**: **RISC** (Reduced Instruction Set Computer)\n  - **vereinfachte** Maschineninstruktionen, dafür **optimierte Compiler**\n\n---\n\n## Prozessor- / Befehlssatzarchitektur (ISA)\n\n*Definition:*  \nDie **Befehlssatzarchitektur** (Instruction Set Architecture, ISA) beschreibt die **nach außen sichtbare Architektur** eines Prozessors.\n\nUmfasst:\n- **Befehlssatz** (Menge aller Maschinenbefehle)\n- **Registermodell** (Anzahl, Typen, Nutzung)\n- **Datenformate** (z.B. Ganzzahl, Fließkomma, Wortbreite)\n- **Adressierungsarten** (z.B. direkt, indirekt, Register-indirekt)\n- **Ein-/Ausgabeorganisation**\n\nBeantwortet u.a.:\n- Wie werden **Daten repräsentiert**?\n- Wo werden die **Daten gespeichert**?\n- Welche **Operationen** sind möglich?\n- Wie werden **Befehle codiert**?\n- Wie wird auf **Daten zugegriffen**?\n\n**Prozessorfamilie:**  \n- Gruppe von Prozessoren mit **gleicher Basisarchitektur**  \n- oft **abwärtskompatibel** (ältere Programme laufen weiter)\n\n---\n\n## Befehlssatzarchitektur: Befehlstypen\n\n### Überblick Befehlstypen\n\n- **Arithmetisch/Logische Befehle**\n- **Fließkommaoperationen**\n- **Datentransport-Befehle**\n- **Steuerbefehle**\n  - Jump, Branch, Procedure Call/Return, Interrupts/Traps\n- **Ein-/Ausgabebefehle**\n- **Spezialbefehle** (Systemsteuerung, Kernel-Mode)\n\n---\n\n### Arithmetisch/Logische Befehle\n\n- **Arithmetische Befehle** (Ganzzahlen, vorzeichenbehaftet)\n  - $add$, $subtract$, $multiply$, $divide$\n  - $increment$, $decrement$, $negate$\n\n- **Logische Befehle**\n  - bitweise: $and$, $or$, $not$\n  - **Shift-Operationen** (z.B. Links- und Rechtsverschiebung)\n\n- **Typkonvertierung**\n  - z.B. binär $\\rightarrow$ dezimal\n\n- **Fließkommaarithmetik**\n  - oft durch **spezielle Hardwareeinheiten** (FPU) unterstützt\n  - früher teilweise als separater Koprozessor realisiert\n\n#### Beispiel: Arithmetischer Befehl\n\nGegeben: vier Integerzahlen $a, b, c, d$ im Speicher:\n\n- $a = MEM[100..103]$\n- $b = MEM[104..107]$\n- $c = MEM[108..111]$\n- $d = MEM[112..115]$\n\nZu berechnen:\n$$ d := a + b + c $$\n\nMögliche Register-Load/Store-Sequenz:\n- $LW\\ R1,\\ 100(R0)$\n- $LW\\ R2,\\ 104(R0)$\n- $LW\\ R3,\\ 108(R0)$\n- $ADD\\ R4,\\ R1,\\ R2$\n- $ADD\\ R5,\\ R4,\\ R3$\n- $SW\\ 112(R0),\\ R5$\n\n---\n\n### Datentransport-Befehle\n\nAufgaben:\n- Transport **vom Hauptspeicher in Register** (Load)\n- Transport **von Register in Hauptspeicher** (Store)\n- Transport **innerhalb des Hauptspeichers**\n\nSpezifikation:\n- **Quelle**\n- **Ziel**\n- **Datenmenge** (z.B. Byte, Wort)\n\nImplementierungsvarianten:\n- mehrere spezialisierte Befehle für verschiedene Datentransporte\n- oder ein Befehl mit vielen **Adressierungsarten**\n\n---\n\n### Steuerbefehle\n\n- **Jump** (unbedingter Sprung)\n  - Zieladresse wird direkt in den **PC** geladen\n\n- **Branch** (bedingter Sprung)\n  - wenn Bedingung erfüllt → Zieladresse in PC laden\n  - sonst → PC normal fortschreiben\n\n- **Procedure Call and Return**\n  - Sprung vom Hauptprogramm zu einem **Unterprogramm**\n  - beim Call: aktueller Prozessorzustand (mind. Rücksprungadresse) wird gesichert\n  - beim Return: Zustand wiederhergestellt\n\n- **Interrupts / Traps**\n  - synchrone/asynchrone **Unterbrechung** der Programmausführung\n  - aktueller Zustand wird gesichert\n  - Ausführung eines **Interrupt-Handlers** (i.d.R. Teil des Betriebssystems)\n\n---\n\n### Zieladressen von Steuerbefehlen\n\n- **Explizit**\n  - Adresse steht direkt im Befehl (z.B. absolute Adresse oder Displacement)\n  - zur **Übersetzungszeit** bekannt\n  - nutzt einen der zulässigen **Adressierungsmodi**\n  - Beispiel: PC-relative Adressierung mit Displacement:\n    $$ PC_{\\text{neu}} = PC_{\\text{alt}} + \\text{Displacement} $$\n\n- **Implizit**\n  - Adresse steht in einem **Register**\n  - Operation gibt ein **Register** an (z.B. für indirekte Sprünge)\n  - Verwendung eines **vordefinierten Registers** (z.B. Rücksprungadresse in Link-Register)\n\n---\n\n### Weitere Befehlstypen\n\n- **Ein-/Ausgabebefehle**\n  - Kommunikation oft über **Hauptspeicherbereiche**:\n    - **Memory-mapped I/O**: I/O-Geräte erscheinen als Speicheradressen\n    - Zugriff von außen über **DMA** (Direct Memory Access)\n\n- **Spezialbefehle (Systemsteuerung)**\n  - setzen Prozessor in einen speziellen Zustand\n  - z.B. **Kernel Mode**\n  - dürfen **nur vom Betriebssystem** verwendet werden\n\n---\n\n## Klassifikation von Befehlssätzen\n\n### Nach Komplexität\n\n- **CISC** (Complex Instruction Set Computer)\n  - viele, teils sehr komplexe Befehle\n  - einzelne Befehle können „viel Arbeit“ erledigen\n\n- **RISC** (Reduced Instruction Set Computer)\n  - kleiner, einheitlicher Befehlssatz\n  - einfache, schnell ausführbare Befehle\n  - stark auf **Pipelining** und **Compileroptimierung** ausgelegt\n\n---\n\n### Nach Verortung der Operanden\n\n- **Register-Speicher-Architektur**\n  - Operanden können in **Registern** oder im **Speicher** stehen\n  - arithmetische Befehle greifen ggf. direkt auf Speicher zu\n\n- **Load-Store-Architektur**\n  - Operanden für ALU-Befehle **nur in Registern**\n  - Zugriff auf Speicher nur über **Load/Store-Befehle**\n\n---\n\n### Nach Anzahl der Operanden\n\n- **Drei-Adress-Maschine**\n  - bis zu zwei Quelloperanden und ein Zieloperand:\n    $$ OpCode,\\ OP1,\\ OP2,\\ DEST $$\n\n- **Zwei-Adress-Maschine**\n  - zwei Operanden, einer ist zugleich **Ziel**:\n    $$ OpCode,\\ DEST/OP1,\\ OP2 $$\n\n- **Ein-Adress-Maschine / Akkumulator-Maschine**\n  - ein expliziter Operand:\n    $$ OpCode,\\ OP1 $$\n  - zweiter Operand ist implizit der **Akkumulator**\n\n- **Null-Adress-Maschine / Stack-Maschine**\n  - keine expliziten Operanden:\n    $$ OpCode $$\n  - Operanden werden vom **Stack** genommen, Ergebnis wird auf dem Stack abgelegt\n\n---\n\n## Befehlsformate\n\n*Definition:*  \nDas **Befehlsformat** legt fest, wie ein Maschinenbefehl **binär codiert** ist.\n\nBestandteile:\n- **OpCode** (Operation Code)\n  - legt die auszuführende Operation fest\n- **Operandenfelder** (z.B. $OP1, OP2, DEST$)\n  - Registeradressen, Speicheradressen oder Immediates\n\nWichtige Formate:\n- **3-Adress-Format**\n  - $OpCode,\\ OP1,\\ OP2,\\ DEST$\n- **2-Adress-Format**\n  - $OpCode,\\ DEST/OP1,\\ OP2$\n- **1-Adress-Format**\n  - $OpCode,\\ OP1$ (Akkumulator implizit)\n- **0-Adress-Format**\n  - $OpCode$ (Stack-Operanden implizit)\n\n---\n\n## Befehlszyklus\n\n### Einfacher Von-Neumann-Befehlszyklus\n\nZwei Hauptphasen:\n\n1. **Instruction Fetch (IF)**\n   - Speicher wird mit dem Inhalt des **PC** adressiert\n   - gelesene Information wird im Steuerwerk als **Befehl** interpretiert\n\n2. **Instruction Execution (EX)**\n   - Speicher wird mit den **Operandenadressen** aus dem Befehl adressiert\n   - geladene Operanden werden der **ALU** zugeführt\n   - Ergebnis wird in den Speicher zurückgeschrieben (Adresse im Befehl enthalten)\n\n---\n\n### Detaillierter Befehlszyklus (DLX, Load/Store-Architektur)\n\nAufteilung in fünf Pipeline-Stufen:\n\n1. **IF (Instruction Fetch)**\n   - liest Befehl aus dem Speicher an Adresse $PC$\n\n2. **ID (Instruction Decode & Source Register Fetch)**\n   - decodiert den Befehl\n   - liest Quellregister\n\n3. **EX (Execution / Effective Address Calculation)**\n   - führt ALU-Operation aus oder\n   - berechnet effektive Adresse für Load/Store oder\n   - berechnet Zieladresse für Sprünge\n\n4. **MEM (Memory Access / Branch)**\n   - führt Load/Store im Speicher aus\n   - führt Sprung tatsächlich aus (PC-Update)\n\n5. **WB (Write Back)**\n   - schreibt Ergebnis in Zielregister\n\n---\n\n## Pipelining\n\n### Grundidee\n\n*Definition:*  \n**Pipelining** ist eine Technik, bei der mehrere Befehle **zeitlich überlappend** bearbeitet werden. Die Befehle durchlaufen hintereinander mehrere **Pipeline-Stufen**, ähnlich einem Fließband.\n\nEigenschaften:\n- jede Stufe bearbeitet **einen Teil** des Befehls\n- zwischen den Stufen befinden sich **Pufferspeicher** (Pipeline-Register)\n- die **Bearbeitungszeit eines einzelnen Befehls** wird nicht kürzer\n- der **Durchsatz** (Befehle pro Zeiteinheit) wird erhöht\n\n---\n\n### Waschmaschinen-Beispiel (Intuition)\n\nGegeben:\n- Waschen: $30$ Minuten\n- Trocknen: $40$ Minuten\n- Falten: $20$ Minuten\n\nOhne Pipelining:\n- eine Ladung: $30 + 40 + 20 = 90$ Minuten\n- vier Ladungen: $4 \\cdot 90 = 360$ Minuten\n\nMit Pipelining:\n- nach der **Anlaufzeit** von $90$ Minuten kommt **alle $40$ Minuten** (langsamste Stufe) eine fertige Ladung heraus:\n  - Gesamtzeit für $4$ Ladungen:\n    $$ 90 + 3 \\cdot 40 = 210\\ \\text{Minuten} $$\n\n---\n\n### Pipeline-Entwurf und Durchsatz\n\n- alle Stufen sollten möglichst **gleiche Bearbeitungszeit** haben\n- die Zeit, um einen Befehl zur nächsten Stufe weiterzureichen, heißt **Maschinenzyklus**\n- der Maschinenzyklus wird durch die **langsamste Stufe** bestimmt\n\nWenn ohne Pipelining ein Befehl durchschnittlich die Zeit $T_{\\text{ohne}}$ benötigt und es $n$ Pipeline-Stufen gibt, ist idealisiert die **mittlere Befehlsausführungszeit**:\n\n$$\nT_{\\text{mit}} \\approx \\frac{T_{\\text{ohne}}}{n}\n$$\n\n(dies gilt nur bei optimaler Auslastung und ohne Hazards).\n\n---\n\n### DLX-Datenpfad mit Pipelining\n\n- jeder **Taktzyklus** startet die Bearbeitung eines neuen Befehls\n- jede der fünf Stufen (IF, ID, EX, MEM, WB) wird eine **Pipeline-Stufe**\n- ein Befehl befindet sich in jedem Takt in **genau einer Stufe**\n- zwischen den Stufen liegen **Pipeline-Register**, die Zwischenergebnisse halten\n\n---\n\n### Pipeline-Hazards\n\n*Definition:*  \nEin **Hazard** ist eine Situation, in der die **korrekte Ausführung** des nächsten Befehls **nicht ohne Verzögerung** möglich ist.\n\nFolge:\n- Einfügen von **Wartezyklen** (Stalls)\n\nArten von Hazards:\n\n1. **Strukturelle Hazards**\n   - mehrere Pipeline-Stufen benötigen **gleichzeitig dieselbe Hardware-Einheit**\n   - Beispiel: gemeinsame Speicher-/Bus-Einheit für Instruktionen und Daten\n\n2. **Daten-Hazards**\n   - ein Befehl benötigt ein **Ergebnis**, das von einem vorherigen Befehl noch **nicht bereitgestellt** wurde\n   - Beispiel:  \n     - $ADD\\ R1,\\ R2,\\ R3$  \n     - $SUB\\ R4,\\ R1,\\ R5$  (nutzt $R1$ zu früh)\n\n3. **Steuerungs-Hazards**\n   - ein Befehl ändert den Inhalt des **PC** (z.B. Branch/Jump)\n   - der **folgende Befehl** wurde aber schon **geladen**, evtl. mit falscher Adresse\n\n---\n\n## Durchgerechnetes Beispiel (Pipelining)\n\nAngenommen:\n- ohne Pipelining dauert eine Instruktion:\n  $$ T_{\\text{ohne}} = 20\\ \\text{ns} $$\n- wir führen eine **5-stufige Pipeline** ein:\n  $$ n = 5 $$\n\n**Idealer Mittelwert pro Befehl:**\n$$\nT_{\\text{mit}} \\approx \\frac{T_{\\text{ohne}}}{n} = \\frac{20\\ \\text{ns}}{5} = 4\\ \\text{ns}\n$$\n\n**Interpretation:**\n- Ein einzelner Befehl braucht immer noch etwa $20\\ \\text{ns}$ vom Eintritt bis zum Verlassen der Pipeline\n- aber nach der Anlaufphase wird **alle $4\\ \\text{ns}$** ein Befehl fertig  \n  → **fünffacher Durchsatz** bei idealen Bedingungen (keine Hazards, volle Auslastung)\n\n---\n\n## Wichtige Merksätze\n\n- **Von-Neumann-Rechner**\n  - Daten und Programme teilen sich **denselben Speicher** und **denselben Bus**  \n  → **Von-Neumann-Flaschenhals**\n\n- **Rechnerarchitektur vs. Rechnerorganisation**\n  - Architektur = *Sicht von außen* (ISA, Befehlssatz, Registermodell)  \n  - Organisation = *innere Umsetzung* (Mikroarchitektur, Kontrolllogik, Speicherhierarchie)\n\n- **Register sind wesentlich schneller** als Hauptspeicher → viele Register steigern die **Performance**\n\n- **Load/Store-Architektur (RISC)**:\n  - ALU-Operationen arbeiten nur auf **Registern**\n  - Speicherzugriffe nur über **Load/Store-Befehle**\n\n- **Pipelining erhöht den Durchsatz**, nicht die Ausführungszeit eines **einzelnen** Befehls\n\n- **Hazards** sind der Hauptgrund, warum reale Pipelines nicht die **theoretische Maximalbeschleunigung** erreichen.",
    "generatedAt": "2025-12-05T17:34:14.237Z"
  },
  {
    "id": "1764956156861-d2za8able",
    "scriptId": "1764951117646-ngxjbmsrn",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Schaltwerke, Flip-Flops, Register, Zähler und endliche Automaten\n\nKurze Übersicht: In diesen Notizen geht es um **sequentielle Schaltungen** (Schaltwerke), deren Grundbausteine (**Flip-Flops**) sowie daraus aufgebaute **Register**, **Zähler** und deren Modellierung mit **endlichen Automaten**.\n\n---\n\n## Sequentielle Schaltungen und Zustandsspeicher\n\n### Schaltnetze vs. Schaltwerke\n\n- **Schaltnetz** (kombinatorische Schaltung):\n  - Ausgänge hängen *nur* von aktuellen Eingängen ab.\n  - *Zustandslos*, vollständig durch eine Schaltfunktion beschrieben:\n    $$\\mathbf{y}(t) = f(\\mathbf{x}(t))$$\n\n- **Schaltwerk** (sequentielle Schaltung):\n  - Ausgänge hängen von Eingängen **und** früheren Ausgangs-/Zustandswerten ab:\n    $$\\mathbf{y}(t) = f(\\mathbf{x}(t), \\mathbf{z}(t-1))$$\n  - Es existiert ein interner *Zustand* $\\mathbf{z}(t)$, der gespeichert wird:\n    $$\\mathbf{z}(t) = g(\\mathbf{x}(t), \\mathbf{z}(t-1))$$\n  - Ermöglicht **Speicherung** von Information.\n\n### Zustandsspeicher durch Rückkopplung\n\n- *Definition:* Ein **Zustandsspeicher** hält vergangene Information in Form von Zuständen.\n- Einfachste Realisierung: **Rückkopplung** von Gatterausgängen auf deren Eingänge.\n\n#### Rückgekoppelte Inverter\n\n- Zwei Inverter in Reihe, Ausgang des zweiten auf Eingang des ersten zurückgeführt:\n  - Es entsteht eine **statische Speicherzelle**.\n  - Der gespeicherte Wert bleibt erhalten, solange Versorgungsspannung anliegt.\n- Umspeichern eines neuen Wertes:\n  - Rückkopplung kurzzeitig „öffnen“ (unterbrechen),\n  - neuen Wert anlegen und anschließend wieder rückkoppeln.\n\n---\n\n## Asynchrone RS-Speicher und RS-Flip-Flops\n\n### RS-Speicher mit NOR-Gattern\n\n- Aufbau: zwei rückgekoppelte **NOR-Gatter** mit Eingängen $r$ (Reset), $s$ (Set) und Ausgängen $q$, $\\overline{q}$.\n- Erlaubte Eingangskombinationen:\n  - $rs = 00,\\; 01,\\; 10$ erlaubt\n  - $rs = 11$ **nicht erlaubt** (illegal)\n- Verhalten:\n  - **Speichern:** $r = 0,\\; s = 0$ → aktueller Wert $q$ bleibt erhalten.\n  - **Setzen:** $s = 1,\\; r = 0$ → $q = 1$.\n  - **Rücksetzen:** $r = 1,\\; s = 0$ → $q = 0$.\n\n### RS-Speicher mit NAND-Gattern\n\n- Aufbau: zwei rückgekoppelte **NAND-Gatter** mit Eingängen $\\overline{r}$, $\\overline{s}$.\n- Verhalten:\n  - **Speichern:** $\\overline{r} = 1,\\; \\overline{s} = 1$ → aktueller Wert $q$ bleibt erhalten.\n  - **Reset:** $\\overline{r} = 0$ → $q = 0$.\n  - **Set:** $\\overline{s} = 0$ → $q = 1$.\n\n### Asynchrones RS-Flip-Flop\n\n- *Definition:* Ein **asynchrones RS-Flip-Flop** speichert **1 Bit**, Eingänge wirken **ohne Takt** sofort.\n- Typische Wahrheitstabelle (NOR-Version, mit vorherigem Zustand $q_{t-1}$):\n\n  | $r$ | $s$ | $q_{t-1}$ | $q_t$     |\n  |-----|-----|-----------|-----------|\n  | 0   | 0   | 0         | 0 (Hold)  |\n  | 0   | 0   | 1         | 1 (Hold)  |\n  | 0   | 1   | 0/1       | 1 (Set)   |\n  | 1   | 0   | 0/1       | 0 (Reset) |\n  | 1   | 1   | 0/1       | *illegal* |\n\n- Der vorherige Zustand $q_{t-1}$ hat **keinen Einfluss** auf die Funktion (außer im Hold-Fall).\n\n### Zeitverhalten und Schwingungen\n\n- Eingangsbelegung $r = 1,\\; s = 1$ ist **zu vermeiden**:\n  - Beim gleichzeitigen Wechsel auf $r = 0,\\; s = 0$ kann das System anfangen zu **schwingen**.\n  - Ursache: unterschiedliche **Signalverzögerungen** in Gattern und Leitungen.\n- Asynchrone Schaltwerke:\n  - reagieren **sofort** auf Eingangsänderungen,\n  - sind sehr **störempfindlich**,\n  - **Hasardfehler** können falsche Zustandsübergänge und Schwingungen auslösen.\n\n### Zustandsdiagramm des asynchronen RS-Flip-Flops\n\n- **Ohne** illegale Belegung $r = 1,\\; s = 1$:\n  - Zwei Zustände:\n    - Zustand 1: $q = 0,\\; \\overline{q} = 1$\n    - Zustand 2: $q = 1,\\; \\overline{q} = 0$\n  - Ausgänge hängen **nur von Eingängen** ab, nicht vom Zustand.\n\n- **Mit** illegaler Belegung $r = 1,\\; s = 1$ (unter Berücksichtigung des Zeitverhaltens):\n  - Vier mögliche Zustände:\n    - $q = 0,\\; \\overline{q} = 1$\n    - $q = 1,\\; \\overline{q} = 0$\n    - $q = 0,\\; \\overline{q} = 0$\n    - $q = 1,\\; \\overline{q} = 1$\n  - Ausgänge sind **zustandsabhängig**.\n  - Beim Übergang von $r = s = 1$ zu $r = s = 0$ aus instabilen Zuständen kann es zu **Schwingungen** kommen.\n\n---\n\n## Gesteuerte RS- und D-Flip-Flops\n\n### Gesteuertes RS-Flip-Flop (mit Enable)\n\n- Zusätzlicher Eingang **enable**:\n  - Nur wenn $\\text{enable} = 1$, werden $r$ und $s$ wirksam.\n  - Für $\\text{enable} = 0$ bleibt der Zustand **gesperrt** (keine Änderung).\n- Schutz vor Störungen an den Eingängen, **solange** $\\text{enable} = 0$.\n- Problem der illegalen Belegung bleibt:\n  - Bei $r = s = 1$ und $\\text{enable} = 1$ weiterhin potentielle **Schwingung**.\n\n### Gesteuertes D-Flip-Flop (Level-gesteuert)\n\n- Idee: illegale Belegung $r = 1,\\; s = 1$ verhindern, indem nur **ein** Dateneingang $d$ benutzt wird.\n- Typische Umsetzung:\n  - Aus $d$ werden $r$ und $s$ so abgeleitet, dass $r = s = 1$ nie auftritt.\n- Problem:\n  - Belegung $r = 0,\\; s = 0$ (Speichern) kann alleine nicht erzeugt werden.\n- Lösung:\n  - Kombination mit **Enable-Schaltung**:\n    - $\\text{enable} = 1$ → Eingabe übernehmen.\n    - $\\text{enable} = 0$ → Wert wird gespeichert.\n- Ergebnis: **D-Flip-Flop**:\n  - Speichert den Wert von $d$ bei aktivem Enable.\n\n---\n\n## Synchrone und getaktete Flip-Flops\n\n### Synchrone Flip-Flops mit Takt\n\n- Einführung eines **Taktsignals** $\\text{clock}$:\n  - Liefert eine gemeinsame **Zeitbasis**.\n  - Ziel: Eingänge stabilisieren, bevor Flip-Flop übernimmt.\n- Grundidee:\n  - Solange warten, bis $r$ und $s$ stabil sind.\n  - Dann bei $\\text{enable} = 1$ (z.B. durch $\\text{clock}$) Änderungen zulassen.\n- Taktsignal:\n  - Periodisch, Periode $T$ (Zeit zwischen zwei gleichen Flanken).\n  - **Lastzyklus** (Duty Cycle): Anteil der Zeit, in der $\\text{clock} = 1$ (hier $50\\%$).\n\n### Taktpegelgesteuerte Flip-Flops\n\n- *Definition:* **Taktpegelgesteuert** (taktzustandsgesteuert):\n  - Eingaben werden während eines bestimmten **Pegelzustands** des Takts verarbeitet (z.B. $\\text{clock} = 1$).\n- RS-Flip-Flop + zwei AND-Gatter:\n  - $r$ und $s$ werden mit $\\text{clock}$ verundet.\n  - Nur bei $\\text{clock} = 1$ wirken $r$ und $s$ auf das Flip-Flop.\n\n#### Synchrones D-Flip-Flop (taktpegelgesteuert)\n\n- Eingänge werden nur übernommen, wenn $\\text{clock} = 1$.\n- Verhalten:\n  - Ist im Lastzyklus $d = 1$, wird $q = 1$ gesetzt und bis zum nächsten Lastzyklus gehalten.\n  - Beim nächsten Lastzyklus kann sich $q$ ändern, abhängig von $d$.\n- Realisiert eine **Verzögerung** eines Datenstroms um **einen Takt**:\n  - Wenn an den steigenden Flanken abgetastet wird:\n    - $D$: $1\\; 0\\; 1\\; 0$\n    - $\\text{CLK}$: $\\uparrow\\; \\uparrow\\; \\uparrow\\; \\uparrow$\n    - $Q$: $1\\; 0\\; 1\\; 0$\n  - Daher Name: **D**-Flip-Flop (*Delay*).\n\n### Taktflankengesteuerte Flip-Flops\n\n- Problem bei Pegelsteuerung:\n  - Änderungen sind während des gesamten Lastzyklus möglich.\n- *Definition:* **Taktflankengesteuert**:\n  - Eingänge werden nur zum Zeitpunkt einer **Flanke** abgetastet.\n  - Zwei Varianten:\n    - **Positiv flankengesteuert**: Abtastung bei **steigender** Flanke.\n    - **Negativ flankengesteuert**: Abtastung bei **fallender** Flanke.\n- Wirkung:\n  - Zustandswechsel sind auf **Zeitpunkte** (Flanken) beschränkt, nicht auf Intervalle.\n\n### Master-Slave-Flip-Flop\n\n- Realisierung eines flankengesteuerten Flip-Flops aus zwei **taktpegelgesteuerten** RS-Flip-Flops:\n  - Flip-Flop 1 = **Master**, Flip-Flop 2 = **Slave**.\n  - Master wird mit $\\text{clock}$, Slave mit $\\overline{\\text{clock}}$ getaktet.\n- Ablauf (z.B. fallende Flanke wirksam):\n  - Bei steigender Flanke: Master liest Eingänge $r$, $s$ ein, Slave ist gesperrt.\n  - Bei fallender Flanke: Slave übernimmt den Zustand des Masters, Ausgänge ändern sich.\n- Ergebnis:\n  - Änderung des Speicherwerts **nur** bei einer definierten Flanke (z.B. fallende Flanke).\n\n### Ersatzschaltbilder flankengesteuerter Flip-Flops\n\n- Für flankengesteuerte RS- und D-Flip-Flops existieren Symboldarstellungen:\n  - Mit Markierung für **steigende** oder **fallende** Taktflanke (z.B. Dreieck mit bzw. ohne Blase).\n\n---\n\n## Weitere Flip-Flop-Typen: T- und JK-Flip-Flop\n\n### T-Flip-Flop\n\n- Aufbau: aus flankengesteuertem RS-Flip-Flop mit vorgeschalteten UND-Gattern.\n- Ein Eingang $t$:\n  - $t = 1$ → Ausgang $q$ wird **umgeschaltet**:\n    $$q_{\\text{neu}} = \\overline{q_{\\text{alt}}}$$\n  - $t = 0$ → keine Zustandsänderung:\n    $$q_{\\text{neu}} = q_{\\text{alt}}$$\n- Name: **T** für *Toggle*.\n- Stabil:\n  - $q$ und $\\overline{q}$ können nicht gleichzeitig $1$ sein.\n\n### JK-Flip-Flop\n\n- Universelle Erweiterung des RS-Flip-Flops mit Eingängen $j$ und $k$.\n- Realisierung: flankengesteuertes RS-Flip-Flop + zwei UND-Gatter.\n- Verhalten:\n  - Für $j = 0,\\; k = 0$: **Halten** (wie RS: $r = s = 0$).\n  - Für $j = 0,\\; k = 1$: **Reset** ($q = 0$).\n  - Für $j = 1,\\; k = 0$: **Set** ($q = 1$).\n  - Für $j = 1,\\; k = 1$: **Toggle** (wie T-Flip-Flop):\n    $$q_{\\text{neu}} = \\overline{q_{\\text{alt}}}$$\n- Die beim RS-Flip-Flop **illegale** Belegung entspricht hier einer **definierten Funktion**.\n\n---\n\n## Register\n\n### Grundidee\n\n- *Definition:* Ein **Register** ist eine parallele Anordnung von $n$ Speicherelementen (Flip-Flops) zur Speicherung eines **$n$-Bit-Datenworts**.\n- Wichtige Kenngröße: **Breite** $n$:\n  - z.B. $8$-, $16$-, $32$-, $64$-, $128$-Bit-Register.\n\n### Auffangregister\n\n- Zweck: **Zwischenspeicherung** von Datenworten.\n- Aufbau:\n  - $n$ taktflankengesteuerte Flip-Flops mit gemeinsamer **Clock** und **Enable** $e$.\n- Verhalten (Beispiel 4-Bit-Register):\n  - Eingänge: $d_3, d_2, d_1, d_0$.\n  - Ausgänge: $q_3, q_2, q_1, q_0$.\n  - $e = 1$: bei Taktflanke werden $d_i$ **parallel übernommen**:\n    $$q_i(t) = d_i(t_{\\text{Flanke}})$$\n  - $e = 0$: Ausgänge bleiben **konstant** → Datenwort ist gespeichert.\n\n---\n\n## Schieberegister\n\n### Seriell → Parallel\n\n- *Definition:* Ein **$n$-Bit-Schieberegister** hat:\n  - einen seriellen Eingang $\\text{in}$,\n  - $n$ parallele Ausgänge $q_{n-1}, \\dots, q_0$.\n- Aufbau:\n  - Kette von $n$ D-Flip-Flops, jeweils Ausgang eines Flip-Flops auf Eingang des nächsten.\n\n- Verhalten:\n  - Bei jedem Takt:\n    - aktueller Wert von $\\text{in}$ wird im ersten Flip-Flop gespeichert,\n    - alle gespeicherten Werte werden **um eine Position weitergeschoben**.\n- Anwendung:\n  - Umsetzung eines **seriellen Datenstroms** in ein **$n$-Bit-Datenwort**.\n\n### Schieberegister mit Parallel-Load\n\n- Erweiterung durch vorgeschalteten **2-zu-1-Multiplexer** an jedem Flip-Flop:\n  - Steuerleitung $s$:\n    - $s = 1$: Schiebeoperation (serielles Weiterreichen).\n    - $s = 0$: paralleles Laden eines Datenwortes.\n- Anwendung:\n  - Serielle Übertragung, aber **paralleles Auslesen** der Daten.\n\n---\n\n## Universalregister\n\n- *Definition:* Ein **Universalregister** vereint:\n  - Auffangregister-Funktion (parallel laden/halten),\n  - Schieberegister-Funktion (links/rechts schieben).\n- Beispiel 4-Bit-Universalregister:\n  - 4 flankengesteuerte D-Flip-Flops.\n  - An jedem Flip-Flop ein **4-zu-1-Multiplexer**.\n  - Gemeinsame Steuerleitungen $s_0, s_1$ zur Funktionswahl.\n- Typische Modi (abhängig vom Design):\n\n  | $s_1 s_0$ | Funktion                     |\n  |-----------|-----------------------------|\n  | 00        | Halten                      |\n  | 01        | Rechts schieben             |\n  | 10        | Links schieben              |\n  | 11        | Parallel laden              |\n\n---\n\n## Zähler\n\n### Allgemeines\n\n- Mit Registern lassen sich **Zähler** aufbauen.\n- Unterscheidungsmerkmale:\n  - **Schrittlänge**: Schrittweite (z.B. $+1$, variabel).\n  - **Implementierung**: asynchron (Ripple) oder synchron.\n  - **Zählrichtung**: vorwärts, rückwärts, bidirektional.\n  - **Zahlenformat**: z.B. Binär, BCD (*Binary Coded Decimal*).\n\n### Ringzähler\n\n- Realisierung: **rückgekoppeltes Schieberegister**.\n- Beispiel 4-Bit-Ringzähler:\n  - Folge: $1000,\\; 0100,\\; 0010,\\; 0001,\\; 1000,\\dots$\n  - Es ist stets **nur ein Bit = 1**, alle anderen $0$.\n- Initialisierung:\n  - Z.B. mit $1000$ (über paralleles Laden, $s = 0$).\n  - Danach Schiebebetrieb (z.B. $s = 1$).\n- Anwendung:\n  - Schrittweise **Aktivierung** von Aktionen:\n    - Jeder Ausgang $q_i$ steuert eine Aktion, die nur bei $q_i = 1$ ausgeführt wird.\n\n### Johnson-Zähler (Möbius-Zähler)\n\n- Ebenfalls Ringzähler, aber **invertierte** Rückkopplung.\n- Beispiel 4-Bit-Johnson-Zähler, Initialisierung mit $1000$:\n  - Folge:\n    $$1000,\\; 1100,\\; 1110,\\; 1111,\\; 0111,\\; 0011,\\; 0001,\\; 0000,\\; 1000,\\dots$$\n- Bietet mehr Zustände als ein einfacher Ringzähler bei gleicher Bitzahl.\n\n### Binärzähler\n\n- *Definition:* Ein **Binärzähler** erzeugt aufsteigende Binärzahlen.\n- Beispiel-Folge (hier niederwertigstes Bit links, nur konzeptionell):\n  - $0000, 1000, 0100, 1100, 0010, 1010, 0110, 1110, \\dots$\n- Realisierung:\n  - Mit Flip-Flops + Zusatzlogik.\n  - Niederwertigstes Bit $q_0$:\n    - wechselt bei **jedem Takt**:\n      $$q_0(t) = \\overline{q_0(t-1)}$$\n  - Höherwertige Bits wechseln abhängig von den Zuständen der niederwertigeren Bits.\n\n---\n\n## Vom Flip-Flop zum Schaltwerk\n\n- Durch **Rückkopplung** von Flip-Flops (Register) entsteht ein **Zustandsspeicher**.\n- *Schaltwerk* = **Schaltnetz** + **Zustandsspeicher**:\n  - Ausgänge hängen von **Eingaben** und **Zustand** ab.\n  - Zustand ändert sich abhängig von Eingaben.\n- Zur Beschreibung: **endliche Automaten** (Finite State Machines, FSM).\n\n---\n\n## Endliche Automaten\n\n### Definition\n\nEin (deterministischer) endlicher Automat ist ein Tupel mit:\n\n- endlicher Menge von **Eingabesymbolen** (Alphabet) $A$, $a_i \\in A$,\n- endlicher Menge von **Zuständen** $S$, $s_i \\in S$,\n- **Anfangszustand** $s_0 \\in S$,\n- **Zustandsübergangsfunktion**:\n  $$\\delta: S \\times A \\rightarrow S$$\n- optional:\n  - endliche Menge von **Ausgabesymbolen** $B$, $b_i \\in B$,\n  - **Ausgabefunktion** $\\lambda$ (Form hängt vom Automatentyp ab).\n\n- Bei deterministischen Automaten sind die Übergänge **eindeutig**:\n  - Für jedes $(s,a)$ existiert genau ein Folgezustand $\\delta(s,a)$.\n\n### Automatentypen (Huffmann-Normalform)\n\n- **Mealy-Automat**:\n  - Ausgabefunktion:\n    $$\\lambda: S \\times A \\rightarrow B$$\n  - Ausgabe hängt von **Zustand und Eingabe** ab.\n\n- **Moore-Automat**:\n  - Ausgabefunktion:\n    $$\\lambda: S \\rightarrow B$$\n  - Ausgabe hängt **nur vom Zustand** ab.\n\n---\n\n## Zustandsübergangsgraphen\n\n### Darstellung\n\n- Jeder Zustand $s_i \\in S$ als **Kreis**.\n- Anfangszustand $s_0$ mit **Pfeil** (Dreieck) markiert.\n- Zustandsübergänge:\n  - als **gerichtete Pfeile** zwischen Zuständen.\n  - Beschriftung:\n    - Eingabesymbol $a_m \\in A$,\n    - optional: Ausgabesymbol $b_n \\in B$ nach Schrägstrich:\n      $$a_m / b_n$$\n- Wenn kein Startzustand explizit definiert:\n  - Annahme: alle Speicherelemente sind initial $0$.\n\n### Beispiel: Ampelschaltung (vereinfacht)\n\n- Es wird eine Ampel für den **Autoverkehr** modelliert (Fußgängerampel ignoriert).\n- Eingabe:\n  - Ampelknopf:\n    - $a_0 = 0$: Knopf **nicht** gedrückt,\n    - $a_1 = 1$: Knopf **gedrückt**.\n- Anfangszustand:\n  - $s_0$: Ampel zeigt **Grün**.\n- Verhalten:\n  - Bei Knopfdruck ($a_1$): Ampel schaltet von Grün $\\rightarrow$ Gelb $\\rightarrow$ Rot.\n  - Nach ausreichender Zeit (Fußgänger überquert):\n    - Eingabe wechselt automatisch von $a_1$ nach $a_0$.\n    - Ampel schaltet von Rot $\\rightarrow$ Gelb-Rot $\\rightarrow$ Grün.\n\n- Mengen:\n  - Eingabesymbole:\n    $$A = \\{a_0, a_1\\} \\quad\\text{(binär kodiert mit }\\{0,1\\}\\text{)}$$\n  - Zustände (z.B.):\n    $$S = \\{s_0, s_1, s_2, s_3\\}$$\n  - Ausgabesymbole (Lichtsignale):\n    $$B = \\{b_0, b_1, b_2, b_3\\}$$\n    - binär kodiert mit $y_2 y_1 y_0 \\in \\{001, 010, 110, 100\\}$.\n\n- Anzahl möglicher Übergänge:\n  $$|S| \\cdot |A| = 4 \\cdot 2 = 8$$\n\n---\n\n## Beispiel: Ableitung eines Schaltwerks aus einem Automaten\n\nGegeben sind:\n\n- Zustandsbits $q_1, q_0$ (aktueller Zustand).\n- Eingabe $x_0$.\n- Ausgänge $y_2, y_1, y_0$.\n- Flip-Flop-Eingänge $d_1, d_0$ (für D-Flip-Flops).\n\n### Ausgabefunktion\n\n- Gegeben:\n\n  $$y_2 = q_1$$\n\n  $$y_1 = q_0 \\leftrightarrow q_1$$\n\n  $$y_0 = \\neg q_0 \\land \\neg q_1 = \\neg (q_0 \\lor q_1)$$\n\n- Erklärung:\n  - $y_2$ zeigt direkt das höherwertige Zustandsbit.\n  - $y_1$ ist das logische Äquivalenz (*XNOR*) von $q_0$ und $q_1$.\n  - $y_0$ ist genau dann $1$, wenn beide Zustandsbits $0$ sind.\n\n### Übergangsfunktion\n\n- Gegeben:\n\n  $$d_1 = q_0$$\n\n  $$d_0 = (\\neg q_1 \\land x_0) \\lor (\\neg q_1 \\land q_0) \\lor (q_0 \\land x_0)$$\n\n- Interpretation:\n  - $d_1$: nächstes höherwertiges Zustandsbit erhält den aktuellen Wert von $q_0$.\n  - $d_0$: Kombination aus aktuellen Zustandsbits und Eingabe $x_0$.\n\n- Diese Funktionen bestimmen:\n  - **Zustandsübergang**:\n    $$q_1^{+} = d_1,\\quad q_0^{+} = d_0$$\n  - **Ausgabe**:\n    $$y_2, y_1, y_0 \\text{ wie oben}$$\n\n---\n\n## Durchgerechnetes Beispiel (kurz)\n\n### Aufgabe\n\nGegeben sei ein D-Flip-Flop mit Eingang $d$ und Ausgang $q$. Es soll ein **T-Flip-Flop** realisiert werden, das bei $t = 1$ toggelt und bei $t = 0$ hält.\n\n### Lösungsschritte\n\n1. **Verhalten des T-Flip-Flops:**\n\n   - Für $t = 0$:\n     $$q^{+} = q$$\n   - Für $t = 1$:\n     $$q^{+} = \\neg q$$\n\n2. **Beziehung zum D-Flip-Flop:**\n\n   - D-Flip-Flop erfüllt:\n     $$q^{+} = d$$\n   - Also muss gelten:\n     $$d = q^{+} = \\begin{cases}\n       q, & t = 0\\\\\n       \\neg q, & t = 1\n     \\end{cases}$$\n\n3. **Logische Funktion für $d$:**\n\n   - Gesucht: $d(t,q)$ so, dass obige Fälle erfüllt sind.\n   - Ansatz:\n     $$d = (\\neg t \\land q) \\lor (t \\land \\neg q)$$\n   - Dies ist genau das **XOR** von $t$ und $q$:\n     $$d = t \\oplus q$$\n\n4. **Implementierung:**\n\n   - Eingang $d$ des D-Flip-Flops wird mit $t \\oplus q$ beschaltet.\n   - Damit verhält sich das D-Flip-Flop wie ein T-Flip-Flop.\n\n---\n\n## Merksätze\n\n- **Schaltnetz**: Ausgänge hängen nur von aktuellen Eingängen ab, **kein Zustand**.\n- **Schaltwerk**: Kombination aus Schaltnetz und Zustandsspeicher, Ausgänge **zustandsabhängig**.\n- **RS-Flip-Flop**:\n  - Speichert 1 Bit.\n  - Eingabe $r = s = 1$ (NOR-Version) ist **illegal** (führt zu Instabilität).\n- **D-Flip-Flop**:\n  - Speichert Datenfolgen, realisiert eine **Takt-Verzögerung**.\n  - Eingabe $d$ wird bei Taktflanke in $q$ übernommen.\n- **T-Flip-Flop**:\n  - $t = 1$ → **Toggle** von $q$.\n  - $t = 0$ → Zustand bleibt erhalten.\n- **JK-Flip-Flop**:\n  - Universell: kann RS-, D- und T-Verhalten nachbilden.\n  - $j = k = 1$ → Toggle (keine illegale Belegung).\n- **Register**:\n  - Parallele Anordnung von Flip-Flops zur Speicherung von **Datenwörtern**.\n- **Schieberegister**:\n  - Wandelt **seriell** eingehende Daten in **parallele** Daten (und umgekehrt).\n- **Ringzähler**:\n  - Es ist immer genau **ein Bit = 1**, rotiert durch die Register.\n- **Johnson-Zähler**:\n  - Invertierte Rückkopplung, erzeugt mehr Zustände als ein Ringzähler gleicher Breite.\n- **Endlicher Automat (FSM)**:\n  - Modelliert Schaltwerke mit endlich vielen Zuständen.\n  - Übergangsfunktion $\\delta$ und Ausgabefunktion $\\lambda$ definieren Verhalten.\n- **Mealy vs. Moore**:\n  - Mealy: Ausgabe hängt von **Zustand und Eingabe** ab.\n  - Moore: Ausgabe hängt **nur vom Zustand** ab.",
    "generatedAt": "2025-12-05T17:35:56.861Z"
  },
  {
    "id": "1764956204668-rmejqvr98",
    "scriptId": "1764951115310-v9s82wjqj",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Schaltnetze: Multiplexer, Demultiplexer und arithmetische Schaltungen\n\nKurze Einleitung: In diesem Abschnitt der Technischen Grundlagen der Informatik werden **Multiplexer**, **Demultiplexer** und grundlegende **arithmetische Schaltungen** (insbesondere Addition) behandelt. Ziel ist das Verständnis von Funktion, Realisierung und Einsatz als universelle Logikbausteine.\n\n---\n\n## 1. Motivation: Von der Wahrheitstabelle zur Schaltung\n\n### Modellieren – Minimieren – Synthetisieren\n\n- Logische Funktionen können über eine **Wahrheitstabelle** beschrieben werden.\n- Beispiel (drei Eingänge $a,b,c$ und Ausgang $y$):\n\n  | Index $i$ | $a$ | $b$ | $c$ | $y$ |\n  |-----------|-----|-----|-----|-----|\n  | 0         | 0   | 0   | 0   | 0   |\n  | 1         | 0   | 0   | 1   | 1   |\n  | 2         | 0   | 1   | 0   | 0   |\n  | 3         | 0   | 1   | 1   | 1   |\n  | 4         | 1   | 0   | 0   | 0   |\n  | 5         | 1   | 0   | 1   | 1   |\n  | 6         | 1   | 1   | 0   | 1   |\n  | 7         | 1   | 1   | 1   | 1   |\n\n- Vorgehen:\n  - **Modellieren**: Funktion durch Wahrheitstabelle oder Boolesche Gleichung beschreiben.\n  - **Minimieren**: Funktion mit z.B. KV-Diagrammen oder algebraisch vereinfachen.\n  - **Synthetisieren**: Minimierte Funktion mit Logikgattern (oder Multiplexern/Demultiplexern) realisieren.\n\n---\n\n## 2. Multiplexer (Mux)\n\n### 2.1 Definition und Grundidee\n\n- *Multiplexer*: **Schaltet von vielen Eingängen auf einen Ausgang.**\n- Ein $n$-zu-1-Multiplexer (kurz $n\\!:\\!1$ Mux) hat:\n  - $n$ **Dateneingänge**: $i_{n-1}, \\dots, i_0$\n  - $k = \\log_2(n)$ **Steuereingänge**: $s_{k-1}, \\dots, s_0$\n  - 1 **Ausgang**: $y$\n- Die Steuersignale wählen aus, welcher Dateneingang auf den Ausgang durchgeschaltet wird.\n\n---\n\n### 2.2 2:1-Multiplexer\n\n#### Funktionsbeschreibung\n\n- Eingänge: $a, b$ (Daten), $s$ (Steuersignal)\n- Ausgang: $y$\n- Verhalten:\n  - Wenn $s = 1$, dann $y = b$\n  - Wenn $s = 0$, dann $y = a$\n- Entspricht einer *if-then-else*-Anweisung:\n  $$\\text{if } (s) \\text{ then } y = b \\text{ else } y = a$$\n\n#### Wahrheitstabelle 2:1-Mux\n\n| Index $i$ | $a$ | $b$ | $s$ | $y$ |\n|-----------|-----|-----|-----|-----|\n| 0         | 0   | 0   | 0   | 0   |\n| 1         | 0   | 0   | 1   | 0   |\n| 2         | 0   | 1   | 0   | 0   |\n| 3         | 0   | 1   | 1   | 1   |\n| 4         | 1   | 0   | 0   | 1   |\n| 5         | 1   | 0   | 1   | 0   |\n| 6         | 1   | 1   | 0   | 1   |\n| 7         | 1   | 1   | 1   | 1   |\n\n#### Boolesche Funktion\n\nDer 2:1-Mux realisiert:\n$$\ny = \\overline{s}\\,a + s\\,b\n$$\n\n- $\\overline{s}$: Negation von $s$\n- $+$: ODER\n- Multiplikation: UND\n\n---\n\n### 2.3 Größere Multiplexer\n\n- **2:1-Mux**: $n = 2$ Dateneingänge\n- **4:1-Mux**: $n = 4$ Dateneingänge, $k = 2$ Steuereingänge\n- **8:1-Mux**: $n = 8$ Dateneingänge, $k = 3$ Steuereingänge\n\nAllgemein:\n- $n = 2^k$ Dateneingänge\n- $k = \\log_2(n)$ Steuersignale\n\n---\n\n### 2.4 Realisierung größerer MUX (zweistufige Logik)\n\n#### 4:1-Mux als zweistufige Logik\n\n- Steuersignale: $s_1, s_0$\n- Dateneingänge: $i_3, i_2, i_1, i_0$\n- Ausgang: $y$\n- Boolesche Funktion:\n$$\ny = \\overline{s_1}\\,\\overline{s_0}\\,i_0\n  + \\overline{s_1}\\,s_0\\,i_1\n  + s_1\\,\\overline{s_0}\\,i_2\n  + s_1\\,s_0\\,i_3\n$$\n\n- Struktur:\n  - 4 UND-Gatter (erste Stufe)\n  - 1 ODER-Gatter (zweite Stufe)\n\n#### 8:1-Mux als zweistufige Logik\n\n- Steuersignale: $s_2, s_1, s_0$\n- Dateneingänge: $i_7, \\dots, i_0$\n- Allgemein:\n$$\ny = \\sum_{j=0}^{7} m_j\\,i_j\n$$\nwobei $m_j$ der jeweilige Minterm der Steuersignale ist, z.B.\n- $m_0 = \\overline{s_2}\\,\\overline{s_1}\\,\\overline{s_0}$\n- $m_7 = s_2\\,s_1\\,s_0$\nusw.\n\n---\n\n### 2.5 Kaskadierung von Multiplexern\n\n#### Prinzip\n\n- Große Multiplexer können aus mehreren kleineren Multiplexern aufgebaut werden.\n- Beispiel: Ein 8:1-Mux kann aus mehreren 2:1- oder 4:1-Muxen kaskadiert werden.\n\n#### Vergleich: Kaskadierung vs. zweistufige Logik\n\n- **Zweistufige Logik**:\n  - Weniger Gatterstufen → **kleinere Gatterlaufzeiten**\n  - Benötigt allerdings Gatter mit **vielen Eingängen**.\n- **Kaskadierung**:\n  - Mehr Gatterstufen → etwas größere Laufzeit\n  - Benötigt insgesamt weniger **Eingänge** → **geringerer Flächenverbrauch**\n\nBeispiel 8:1-Mux:\n\n- Zweistufig:\n  - Anzahl der UND-Gatter: $8$\n  - Eingänge pro UND-Gatter: $\\log_2(8) + 1 = 4$\n  - Gesamtanzahl der Eingänge:\n    $$\n    8 \\cdot 4 = 32\n    $$\n- Kaskadiert:\n  - $2 \\cdot 4$ Gatter mit je 3 Eingängen\n  - $2$ Gatter mit je 2 Eingängen\n  - Gesamt:\n    $$\n    2 \\cdot 4 \\cdot 3 + 2 \\cdot 2 = 24 + 4 = 28\n    $$\n\n**Merke**: Flächenaufwand ist näherungsweise proportional zur Anzahl der Gattereingänge → **kaskadierte Lösung ist flächensparender**, zweistufige Logik ist schneller.\n\n---\n\n### 2.6 Multiplexer als universelle Logikbausteine\n\n- Ein $n\\!:\\!1$-Multiplexer kann **jede Boolesche Funktion** mit $k = \\log_2(n)$ Variablen implementieren.\n\n#### Vorgehen zur Funktionsrealisierung\n\n- Gegeben: Boolesche Funktion $f(x_{k-1}, \\dots, x_0)$\n- Setze:\n  - Steuersignale:\n    $$\n    s_{k-1}, \\dots, s_0 := x_{k-1}, \\dots, x_0\n    $$\n  - Dateneingänge $i_{n-1}, \\dots, i_0$:\n    - Für jede mögliche Belegung der Steuersignale (d.h. jeden Index $j$):\n      - $i_j = 1$, wenn $f$ für diese Belegung $=1$ ist\n      - $i_j = 0$, wenn $f$ für diese Belegung $=0$ ist\n\n**Ergebnis**: Der Multiplexer gibt für jede Belegung der Steuersignale genau den Funktionswert $f$ aus.\n\n---\n\n## 3. Demultiplexer (Demux)\n\n### 3.1 Definition und Grundidee\n\n- *Demultiplexer*: **Schaltet von einem Eingang auf viele Ausgänge.**\n- Struktur:\n  - 1 **Dateneingang**: $g$ (häufig *Enabler* genannt)\n  - $k$ **Steuereingänge**: $s_{k-1}, \\dots, s_0$\n  - $n = 2^k$ **Ausgänge**: $r_{n-1}, \\dots, r_0$\n\n**Funktion**:\n- Abhängig von den Steuersignalen wird der Eingang $g$ auf **genau einen** Ausgang $r_j$ geschaltet.\n- Alle anderen Ausgänge sind $0$.\n\n---\n\n### 3.2 Beispiele für Demultiplexer\n\n- **1:2-Demultiplexer**:\n  - $k = 1$, $n = 2$\n  - Steuersignal: $s_0$\n  - Ausgänge: $r_1, r_0$\n- **1:4-Demultiplexer**:\n  - $k = 2$, $n = 4$\n  - Steuersignale: $s_1, s_0$\n  - Ausgänge: $r_3, r_2, r_1, r_0$\n- Analog: 1:8, 1:16, …\n\n---\n\n### 3.3 Realisierung von Demultiplexern\n\n#### 1:2-Demultiplexer\n\n- Eingang: $g$\n- Steuersignal: $s$\n- Ausgänge: $r_1, r_0$\n\nBoolesche Funktionen:\n$$\nr_0 = \\overline{s}\\,g\n$$\n$$\nr_1 = s\\,g\n$$\n\n#### 1:4-Demultiplexer\n\n- Eingang: $g$\n- Steuersignale: $s_1, s_0$\n- Ausgänge: $r_3, r_2, r_1, r_0$\n\nAllgemein:\n$$\nr_j = m_j\\,g\n$$\nwobei $m_j$ der Minterm von $s_1,s_0$ ist, z.B.\n- $r_0 = \\overline{s_1}\\,\\overline{s_0}\\,g$\n- $r_1 = \\overline{s_1}\\,s_0\\,g$\n- $r_2 = s_1\\,\\overline{s_0}\\,g$\n- $r_3 = s_1\\,s_0\\,g$\n\n---\n\n### 3.4 Kaskadierung von Demultiplexern\n\n- Große Demultiplexer (z.B. 1:8, 1:16) können aus mehreren kleineren (z.B. 1:2 oder 1:4) aufgebaut werden.\n- Prinzip analog zur Kaskadierung von Multiplexern:\n  - Zuerst grobe Auswahl über einige Steuersignale\n  - Danach feinere Aufteilung über weitere Demultiplexer\n\n---\n\n### 3.5 Demultiplexer als universelle Logikbausteine\n\n- Ein 1:$n$-Demultiplexer kann **jede Boolesche Funktion** von $k = \\log_2(n)$ Variablen implementieren.\n\n#### Vorgehen\n\n- Gegeben: Funktion $f(x_{k-1}, \\dots, x_0)$\n- Setze:\n  - Steuersignale:\n    $$\n    s_{k-1}, \\dots, s_0 := x_{k-1}, \\dots, x_0\n    $$\n  - Eingang:\n    $$\n    g := 1\n    $$\n- Dann liegen an den Ausgängen $r_j$ genau die **Minterme** der Variablen $x_{k-1}, \\dots, x_0$ an:\n  - Für jede Belegung der Steuersignale ist genau ein Ausgang $r_j = 1$, alle anderen $0$.\n- Um $f$ zu erhalten:\n  - Verknüpfe alle Ausgänge $r_j$ mit einem ODER-Gatter, für die $f$ bei dieser Belegung $=1$ ist.\n\nFormel:\n$$\nf(x_{k-1}, \\dots, x_0) = \\bigvee_{j \\in J} r_j\n$$\nwobei $J$ die Menge der Indizes ist, für die $f=1$.\n\n---\n\n## 4. Arithmetische Schaltungen – Addition\n\n### 4.1 Motivation\n\n- Addition ist eine der **wichtigsten Operationen** in digitalen Systemen:\n  - Grundlage für Subtraktion, Inkrement, Multiplikation, Adressberechnung usw.\n- Orientierung an der **schriftlichen Addition** im Dezimalsystem, übertragen auf Dualzahlen.\n\nBeispiel:\n- Dezimal:\n  $$\n  13 + 5 = 18\n  $$\n- Dual:\n  $$\n  13_{10} = 1101_2,\\quad 5_{10} = 0101_2,\\quad 18_{10} = 10010_2\n  $$\n  Also:\n  $$\n  1101_2 + 0101_2 = 10010_2\n  $$\n\n- Die Addition erfolgt **bitweise von rechts nach links**, beginnend beim **niederwertigsten Bit** (Least Significant Bit, LSB).\n\n---\n\n### 4.2 Halbaddierer (Half Adder)\n\n#### Aufgabe\n\n- Addition **zweier einzelner Bits** $a$ und $b$ **ohne** Eingangstrage.\n- Ergebnis:\n  - **Summe** $s$\n  - **Übertrag** $c_{\\text{out}}$ (Carry-out)\n\n#### Wahrheitstabelle Halbaddierer\n\n| $a$ | $b$ | $s$ | $c_{\\text{out}}$ |\n|-----|-----|-----|------------------|\n| 0   | 0   | 0   | 0                |\n| 0   | 1   | 1   | 0                |\n| 1   | 0   | 1   | 0                |\n| 1   | 1   | 0   | 1                |\n\n#### Boolesche Funktionen\n\n- **Summe**:\n  $$\n  s = a \\oplus b\n  $$\n  (XOR-Verknüpfung)\n- **Übertrag**:\n  $$\n  c_{\\text{out}} = a \\cdot b\n  $$\n\n#### Bedeutung des Namens „Halbaddierer“\n\n- Er heißt **Halbaddierer**, weil der **Eingangstrage** (Carry-in) fehlt.\n- Für eine vollständige Bit-Addition in einer mehrstelligen Zahl benötigt man:\n  - 2 Summandenbits $a,b$\n  - 1 Eingangstrage $c_{\\text{in}}$\n- Der Halbaddierer berücksichtigt nur $a$ und $b$, **ohne** $c_{\\text{in}}$ → „halb“.\n\n---\n\n## 5. Beispielrechnung und Schaltungsbezug\n\n### 5.1 Beispiel: 1-Bit-Addition mit Halbaddierer\n\nGegeben: $a = 1$, $b = 1$\n\n1. Berechnung der Summe:\n   $$\n   s = a \\oplus b = 1 \\oplus 1 = 0\n   $$\n2. Berechnung des Übertrags:\n   $$\n   c_{\\text{out}} = a \\cdot b = 1 \\cdot 1 = 1\n   $$\n\nInterpretation:\n- $1 + 1 = 2_{10} = 10_2$\n- $s$ ist das niederwertige Bit, $c_{\\text{out}}$ das höherwertige Bit.\n\n---\n\n## 6. Merksätze\n\n- **Multiplexer**:\n  - Schalten **einen von vielen Eingängen** auf **einen Ausgang**.\n  - Ein $n\\!:\\!1$-Mux kann jede Funktion mit $k = \\log_2(n)$ Variablen realisieren.\n  - Implementierung: $y = \\overline{s}\\,a + s\\,b$ für den 2:1-Mux.\n\n- **Demultiplexer**:\n  - Schalten **einen Eingang** auf **einen von vielen Ausgängen**.\n  - Ein 1:$n$-Demux kann jede Funktion von $k = \\log_2(n)$ Variablen über Minterme + ODER-Gatter implementieren.\n\n- **Kaskadierung vs. zweistufige Logik**:\n  - Zweistufig: schnellere Schaltung, aber mehr/größere Gatter.\n  - Kaskadiert: weniger Eingänge insgesamt → geringerer Flächenverbrauch.\n\n- **Halbaddierer**:\n  - Führt die Addition **zweier Bits ohne Eingangstrage** aus.\n  - Summe: $s = a \\oplus b$\n  - Übertrag: $c_{\\text{out}} = a \\cdot b$\n  - Heißt „Halbaddierer“, weil der Eingangstrage $c_{\\text{in}}$ fehlt.",
    "generatedAt": "2025-12-05T17:36:44.668Z"
  },
  {
    "id": "1764956270446-mjsefnisc",
    "scriptId": "1764951112861-j56fii26f",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Schaltnetze: Multiplexer, Arithmetik und ALU\n\nKurzer Überblick:  \nIn diesen Notizen werden **Multiplexer/Demultiplexer**, **arithmetische Schaltungen** (Addition, Inkrement, Subtraktion, Multiplikation) und deren Zusammenspiel in der **ALU** systematisch zusammengefasst.\n\n---\n\n## Multiplexer\n\n### Definition\n\n*Ein Multiplexer (Mux)* ist eine Schaltung, die aus mehreren Dateneingängen **einen** Ausgang auswählt.\n\n- $n$ Dateneingänge: $i_{0}, i_{1}, \\dots, i_{n-1}$\n- $k$ Steuersignale: $s_{k-1}, \\dots, s_{0}$ mit $n = 2^{k}$\n- 1 Ausgang: $y$\n\n**Funktion:**  \nDas Steuersignal kodiert den Index des ausgewählten Eingangs.\n\n---\n\n### 2:1-Multiplexer\n\n#### Verhalten\n\nEingänge: $a, b$, Steuersignal $s$, Ausgang $y$:\n\n- Wenn $s = 1$, dann $y = b$\n- Wenn $s = 0$, dann $y = a$\n\n*Entspricht:*  \n```c\nif (s) y = b;\nelse   y = a;\n```\n\n#### Wahrheitstabelle\n\n| Index $i$ | $a$ | $b$ | $s$ | $y$ |\n|-----------|-----|-----|-----|-----|\n| 0         | 0   | 0   | 0   | 0   |\n| 1         | 0   | 0   | 1   | 0   |\n| 2         | 0   | 1   | 0   | 0   |\n| 3         | 0   | 1   | 1   | 1   |\n| 4         | 1   | 0   | 0   | 1   |\n| 5         | 1   | 0   | 1   | 0   |\n| 6         | 1   | 1   | 0   | 1   |\n| 7         | 1   | 1   | 1   | 1   |\n\n#### Boolesche Funktion\n\n$$\ny = \\overline{s}\\,a + s\\,b\n$$\n\n- $\\overline{s}\\,a$: wählt $a$, wenn $s = 0$\n- $s\\,b$: wählt $b$, wenn $s = 1$\n\n---\n\n### Allgemeiner $n$:1-Multiplexer\n\n- $n = 2^{k}$ Dateneingänge\n- $k$ Steuersignale\n\nTypische Varianten:\n- 2:1-Mux ($n=2$)\n- 4:1-Mux ($n=4$)\n- 8:1-Mux ($n=8$)\n\n---\n\n### Realisierung und Kaskadierung\n\n#### Zweistufige Logik\n\nFür einen $n$:1-Mux:\n\n- Erste Stufe: $n$ UND-Gatter, die jeweils ein Datensignal und eine bestimmte Kombination der Steuersignale verknüpfen\n- Zweite Stufe: ein ODER-Gatter, das alle Teilergebnisse zusammenfasst\n\nBeispiel 8:1-Mux, zweistufig:\n- 8 UND-Gatter mit jeweils $\\log_{2}(8) + 1 = 4$ Eingängen  \n  $\\Rightarrow$ insgesamt $8 \\cdot 4 = 32$ Eingänge\n\n#### Kaskadierung\n\nGroße Multiplexer können aus kleineren aufgebaut werden.\n\nBeispiel 8:1-Mux, kaskadiert:\n- $2 \\cdot 4$ UND-Gatter mit 3 Eingängen\n- $2$ UND-Gatter mit 2 Eingängen  \n  $\\Rightarrow$ $2 \\cdot 4 \\cdot 3 + 2 \\cdot 2 = 28$ Eingänge\n\n**Vergleich:**\n\n- **Zweistufige Logik**\n  - Vorteil: geringe Gatterlaufzeit (nur 2 Stufen)\n  - Nachteil: mehr Eingänge, größerer Flächenbedarf\n- **Kaskadierung**\n  - Vorteil: weniger Eingänge insgesamt, geringerer Flächenverbrauch\n  - Nachteil: höhere logische Tiefe, längere Laufzeit\n\n*Flächenaufwand $\\propto$ Anzahl der Gattereingänge*  \n$\\Rightarrow$ kaskadierte Lösung meist flächenökonomischer.\n\n---\n\n### Multiplexer als universelle Logikbausteine\n\n*Eigenschaft:*  \nEin $n$:1-Multiplexer kann **jede Boolesche Funktion** von $k = \\log_{2}(n)$ Variablen realisieren.\n\nVorgehen:\n\n- Variablen:\n  $$\n  x_{k-1}, \\dots, x_{0}\n  $$\n  werden als Steuersignale\n  $$\n  s_{k-1}, \\dots, s_{0}\n  $$\n  verwendet.\n- Dateneingänge $i_{0}, \\dots, i_{n-1}$ werden fest auf $0$ oder $1$ gelegt.\n- Durch passende Belegung der Dateneingänge wird die gewünschte Funktion implementiert (entspricht der Wahrheitstabelle).\n\n---\n\n## Demultiplexer\n\n### Definition\n\n*Ein Demultiplexer (Demux)* ist die inverse Funktion zum Multiplexer:\n\n- 1 Dateneingang: $g$ (oft *Enabler* genannt)\n- $k$ Steuersignale: $s_{k-1}, \\dots, s_{0}$\n- $n = 2^{k}$ Ausgänge: $r_{0}, \\dots, r_{n-1}$\n\n**Funktion:**\n\n- Abhängig von den Steuersignalen wird $g$ auf genau **einen** Ausgang geschaltet.\n- Alle anderen Ausgänge sind $0$.\n\n---\n\n### Typische Demultiplexer\n\n- 1:2-Demux\n- 1:4-Demux\n- 1:$2^{k}$-Demux\n\nRealisierung erfolgt analog zum Mux, nur „umgedreht“:\n- Eingangssignal $g$ wird mit Dekodierung der Steuersignale verknüpft.\n\n---\n\n### Demultiplexer als universelle Logikbausteine\n\nEin 1:$n$-Demultiplexer kann jede Funktion von $k = \\log_{2}(n)$ Variablen implementieren.\n\nVorgehen:\n\n- Variablen\n  $$\n  x_{k-1}, \\dots, x_{0}\n  $$\n  werden als Steuersignale\n  $$\n  s_{k-1}, \\dots, s_{0}\n  $$\n  verwendet.\n- Eingang $g$ wird auf $1$ gelegt.\n- An den Ausgängen $r_{i}$ liegen die *Minterme* der Steuervariablen an.\n- Durch ODER-Verknüpfung ausgewählter Ausgänge erhält man die gewünschte Funktion.\n\n---\n\n## Addition\n\n### Grundidee\n\nBinäre Addition orientiert sich an der schriftlichen Addition:\n\nBeispiel:\n- Dezimal: $13 + 5 = 18$\n- Binär:\n  $$\n  1101_{(2)} + 0101_{(2)} = 10010_{(2)}\n  $$\n\n- Addition erfolgt bitweise von rechts nach links (vom niederwertigsten Bit).\n- Wichtig: **Summe-Bit** und **Übertragsbit (Carry)**.\n\n---\n\n## Halbaddierer\n\n### Definition\n\n*Ein Halbaddierer* addiert zwei 1-Bit-Eingänge $a$ und $b$ **ohne** eingehenden Übertrag.\n\nEingänge:\n- $a, b \\in \\{0, 1\\}$\n\nAusgänge:\n- Summe $s$\n- Übertrag $c_{\\text{out}}$\n\n### Wahrheitstabelle\n\n| $a$ | $b$ | $s$ | $c_{\\text{out}}$ |\n|-----|-----|-----|------------------|\n| 0   | 0   | 0   | 0                |\n| 0   | 1   | 1   | 0                |\n| 1   | 0   | 1   | 0                |\n| 1   | 1   | 0   | 1                |\n\n### Boolesche Funktionen\n\n- Summe:\n  $$\n  s = a \\oplus b\n  $$\n- Übertrag:\n  $$\n  c_{\\text{out}} = a \\cdot b\n  $$\n\n*Bemerkung:*  \n„Halb“-Addierer, weil der eingehende Übertrag (*Carry-in*) noch fehlt.\n\n---\n\n## Volladdierer\n\n### Definition\n\n*Ein Volladdierer* addiert zwei 1-Bit-Eingänge $a, b$ **inklusive** eingehendem Übertrag $c_{\\text{in}}$.\n\nEingänge:\n- $a, b, c_{\\text{in}} \\in \\{0, 1\\}$\n\nAusgänge:\n- Summe $s$\n- Übertrag $c_{\\text{out}}$\n\n### Boolesche Funktionen\n\nSumme:\n$$\ns = a \\oplus b \\oplus c_{\\text{in}}\n$$\n\nÜbertrag (eine Form):\n$$\nc_{\\text{out}} = a b + a c_{\\text{in}} + b c_{\\text{in}}\n$$\n\nAlternative Form (mit *Propagate* und *Generate*, siehe unten):\n$$\nc_{\\text{out}} = g \\,\\lor\\, (p \\cdot c_{\\text{in}})\n$$\n\nmit\n$$\np = a \\oplus b \\quad\\text{(Propagate)}\n$$\n$$\ng = a \\cdot b \\quad\\text{(Generate)}\n$$\n\n---\n\n## Carry-Ripple-Addierer\n\n### Aufbau\n\n*Ein $n$-Bit Carry-Ripple-Addierer* besteht aus $n$ Volladdierern in Serie.\n\n- Eingänge:\n  - $a_{n-1}\\dots a_{0}$\n  - $b_{n-1}\\dots b_{0}$\n- Ausgänge:\n  - Summe $z_{n-1}\\dots z_{0}$\n  - Endübertrag $c_{n}$\n\nVerkettung:\n- $c_{0}$ ist meist $0$ (oder $1$ bei Inkrement).\n- $c_{\\text{out}}$ des $i$-ten Volladdierers wird zu $c_{\\text{in}}$ des $(i+1)$-ten.\n\n### Eigenschaften\n\n- **Laufzeit:** linear in der Bitbreite $n$  \n  $\\Rightarrow$ jeder Volladdierer wartet auf den Carry seines Vorgängers  \n  (Carry „rieselt“ durch die Kette).\n- **Flächenbedarf:**  \n  - pro Bit ein Volladdierer\n  - Anzahl der Gatter $\\propto n$ (linear)\n\n**Vorteile:**\n- Einfacher Aufbau\n- Flächenökonomisch (linearer Flächenbedarf)\n\n**Nachteile:**\n- Relativ langsam bei großen $n$\n\n---\n\n## Carry-Look-Ahead-Addierer (CLA)\n\n### Motivation\n\nZiel: Überträge **parallel** statt **seriell** berechnen, um die Laufzeit von der Bitbreite zu entkoppeln.\n\n- Jede Boolesche Funktion kann als zweistufiges Schaltnetz realisiert werden.\n- Idee: Übertragsbits $c_{1}, c_{2}, \\dots, c_{n}$ direkt aus $a_{i}, b_{i}$ und $c_{0}$ berechnen.\n\n---\n\n### Propagate- und Generate-Signale\n\nFür jedes Bit $i$:\n\n- *Propagate*:\n  $$\n  p_{i} = a_{i} \\oplus b_{i}\n  $$\n  „Dieses Bit **leitet** einen eingehenden Carry weiter.“\n\n- *Generate*:\n  $$\n  g_{i} = a_{i} \\cdot b_{i}\n  $$\n  „Dieses Bit **erzeugt** selbst einen Carry.“\n\nÜbertragsformel:\n$$\nc_{i+1} = g_{i} + p_{i} \\cdot c_{i}\n$$\n\n---\n\n### Rekursive Berechnung der Überträge\n\nDurch wiederholtes Einsetzen erhält man z.B.:\n- $c_{1} = g_{0} + p_{0} c_{0}$\n- $c_{2} = g_{1} + p_{1} c_{1} = g_{1} + p_{1}(g_{0} + p_{0} c_{0}) = g_{1} + p_{1} g_{0} + p_{1} p_{0} c_{0}$\n- usw.\n\nAllgemein:  \nJedes $c_{i}$ kann als zweistufige Funktion von $c_{0}$, $g_{j}$ und $p_{j}$ ($j < i$) dargestellt werden.\n\n**Konsequenz:**\n\n- Alle $c_{i}$ werden in einem separaten zweistufigen Netz berechnet.\n- Alle Volladdierer können *parallel* arbeiten.\n- Schaltungstiefe (logische Tiefe) wird (für gegebene Gruppierung) nahezu konstant.\n\n---\n\n### Eigenschaften CLA\n\n- **Vorteil:**\n  - Sehr schnell: Überträge werden parallel berechnet.\n  - Additionszeit nahezu unabhängig von der Wortbreite (für hier betrachtete Idealform).\n- **Nachteil:**\n  - Flächenintensiv: Flächenbedarf steigt stark (kubisch mit Bitbreite in der einfachen Form).\n  - Aufwendige Logik zur Übertragsberechnung.\n\n---\n\n### Vergleich: Carry-Ripple vs. Carry-Look-Ahead\n\n| Kriterium        | Carry-Ripple                     | Carry-Look-Ahead                 |\n|------------------|----------------------------------|----------------------------------|\n| Flächenbedarf    | linear in $n$                    | wächst stark (kubisch)          |\n| Geschwindigkeit  | langsam (serieller Carry)        | schnell (paralleler Carry)      |\n| Komplexität      | gering                           | hoch                             |\n\nWeitere Addierer-Varianten (nur Stichworte):\n- Conditional-Sum-Addierer\n- Präfix-Addierer\n\n---\n\n## Inkrementierer\n\n### Definition\n\n*Inkrementieren* bedeutet:  \n$$\na \\leftarrow a + 1\n$$\n\nBeispiele in Programmiersprachen:\n- $a = a + 1;$\n- $a++;$\n\n### Realisierung\n\n- Ein $n$-stelliger Inkrementierer kann durch ein $n$-stelliges Addierwerk umgesetzt werden:\n  - $b_{i} = 0$ für alle $i$\n  - Eingangsübertrag $c_{0} = 1$\n\n- Optimierung:\n  - Durch feste Verdrahtung ($b_{i}=0$) können Volladdierer durch passend beschaltete Halbaddierer ersetzt werden (z.B. beim Carry-Ripple-Addierer).\n\n---\n\n## Subtrahierer\n\n### Grundidee\n\nSubtraktion:\n$$\ny = a - b\n$$\nwird als Addition mit dem Zweierkomplement dargestellt:\n$$\ny = a + (-b)\n$$\n\nFür Zweierkomplement:\n- $-b$ wird als Zweierkomplement von $b$ gebildet.\n\n### Realisierung mit Addierer\n\nEin $n$-stelliger Subtrahierer kann mit einem $n$-stelligen Addiererwerk realisiert werden:\n\n- Zusätzliche Logik zur Bildung des Zweierkomplements von $b$:\n  - Steuerbit $n$ entscheidet, ob $b$ negiert wird.\n  - $n = 0$: Addition zweier positiver Zahlen\n  - $n = 1$: Addition mit negativer Zahl (Subtraktion)\n\nTypische Umsetzung:\n- XOR-Gatter pro Bit von $b$:\n  $$\n  b'_{i} = b_{i} \\oplus n\n  $$\n- Eingangsübertrag des niederwertigsten Volladdierers:\n  $$\n  c_{0} = n\n  $$\n\nErgebnis:\n- Wenn $n=1$, wird effektiv $a + (\\overline{b} + 1)$ berechnet, also $a - b$.\n\n**Overflow-Erkennung:**\n- Ausgang $v$ zeigt Überlauf (Overflow) an.\n\n---\n\n## Multiplikation\n\n### Prinzip der binären Multiplikation\n\nSchriftliche Multiplikation im Binärsystem:\n\n- Multiplikator: $a = a_{n-1} \\dots a_{0}$\n- Multiplikand: $b = b_{n-1} \\dots b_{0}$\n\nJedes Bit des Multiplikators steuert:\n- Wenn $a_{i} = 1$: addiere $b$ um $i$ Stellen nach links verschoben.\n- Wenn $a_{i} = 0$: addiere $0$.\n\nSomit:\n$$\na \\cdot b = \\sum_{i=0}^{n-1} a_{i} \\cdot (b \\ll i)\n$$\n\nVorzeichen:\n\n- Vorzeichenlose Zahlen: direkte Anwendung.\n- Vorzeichenbehaftete Zahlen (Einer-/Zweierkomplement):\n  - Umwandlung in Betrag-Vorzeichen-Form\n  - Multiplikation der Beträge\n  - Vorzeichen des Ergebnisses:\n    $$\n    \\text{sign}(a \\cdot b) = \\text{sign}(a) \\oplus \\text{sign}(b)\n    $$\n  - Rückumwandlung ins gewünschte Komplementformat.\n\n---\n\n## Matrixmultiplizierer\n\n### Struktur\n\nDer *Matrixmultiplizierer* bildet die schriftliche Multiplikation in Hardware nach.\n\nGegeben:\n- $a = a_{n-1} \\dots a_{0}$ (Multiplikator)\n- $b = b_{n-1} \\dots b_{0}$ (Multiplikand)\n\nAnordnung:\n\n- Es entsteht eine $n \\times (2n - 1)$-Matrix:\n  - In jeder Zeile: UND-Verknüpfungen $a_{j} b_{i}$ (Teilergebnisse)\n  - Spaltenweise Summation mit Addierern\n\nElemente:\n$$\nm_{i,j} = a_{j} \\cdot b_{i}\n$$\n\nJede Spalte wird durch ein Addierwerk (max. $n-1$ Volladdierer) aufaddiert.\n\n---\n\n### 4-Bit-Matrixmultiplizierer (Konzept)\n\nFür $a = a_{3}a_{2}a_{1}a_{0}$ und $b = b_{3}b_{2}b_{1}b_{0}$:\n\n- 16 UND-Gatter für alle Produkte $a_{j} b_{i}$.\n- Addierwerke organisieren die Summation entlang der Diagonalen (wie bei der schriftlichen Multiplikation).\n- Ergebnis hat bis zu 8 Bits: $p_{7} \\dots p_{0}$.\n\n---\n\n## Arithmetisch-logische Einheit (ALU)\n\n### Definition\n\n*Die ALU* (Arithmetic Logic Unit) führt elementare arithmetische und logische Operationen eines Prozessors aus.\n\n**Eingaben:**\n- Operanden: $a$, $b$ (jeweils Wortbreite z.B. 8, 16, 32, 64 Bit)\n- Steuerung: *Mode* (wählt Operation)\n\n**Ausgaben:**\n- Ergebnis: $y$\n- Statusinformationen: *Flags*\n\n---\n\n### Typische Operationen einer ALU\n\n- Arithmetische Operationen:\n  - Addition\n  - Subtraktion\n  - Multiplikation (oft in separater Einheit)\n- Logische Operationen:\n  - bitweises UND\n  - bitweises ODER\n  - bitweises XOR\n  - Invertierung\n\n- Vergleichsoperationen:\n  - Test auf Gleichheit, etc.\n\n---\n\n### Flag-Register (Statusregister)\n\nWichtige Flags:\n\n- **Carry-Flag (C):**\n  - Übertrag ist aufgetreten (bei Addition/Subtraktion).\n- **Overflow-Flag (V/O):**\n  - Ergebnis passt nicht in die vorgesehene Wortbreite (Überlauf im Zweierkomplement).\n- **Zero-Flag (Z):**\n  - Ergebnis ist $0$.\n- **Negative-Flag (N):**\n  - Ergebnis ist negativ (Vorzeichenbit = 1 im Zweierkomplement).\n\n---\n\n### Beispiel: 4-Bit-ALU aus 1-Bit-ALUs\n\n- Aufbau:\n  - 4 identische 1-Bit-ALUs werden kaskadiert.\n  - Carry-Ausgang jeder Stufe geht in den Carry-Eingang der nächsten.\n- Mode-Steuerung:\n  - Alle 1-Bit-ALUs erhalten denselben Mode.\n- Beispielhafte Operationen (pro Bit):\n  - Logisches UND: $y = a \\land b$\n  - Logisches ODER: $y = a \\lor b$\n  - Invertiertes $b$: $y = \\overline{b}$\n  - ODER mit invertiertem $b$: $y = a \\lor \\overline{b}$\n  - UND mit invertiertem $b$: $y = a \\land \\overline{b}$\n  - Addition: $y = a + b$ (mit Carry)\n  - Subtraktion: $y = a + (\\overline{b} + 1)$ (Addition mit invertiertem $b$ und angepasstem Carry-In)\n\n---\n\n## Durchgerechnetes Beispiel: 4-Bit-Addition mit Carry-Ripple\n\nGegeben:\n- $a = 1101_{(2)}$ (13)\n- $b = 0101_{(2)}$ (5)\n\nWir addieren mit einem 4-Bit-Carry-Ripple-Addierer, $c_{0} = 0$.\n\n| Stelle $i$ (LSB=0) | $a_{i}$ | $b_{i}$ | $c_{i}$ (in) | Summe $s_{i}$ | $c_{i+1}$ (out) |\n|--------------------|---------|---------|--------------|---------------|-----------------|\n| 0                  | 1       | 1       | 0            | $0$           | $1$             |\n| 1                  | 0       | 0       | 1            | $1$           | $0$             |\n| 2                  | 1       | 1       | 0            | $0$           | $1$             |\n| 3                  | 1       | 0       | 1            | $0$           | $1$             |\n\nErgebnis:\n- Summe-Bits (von MSB nach LSB): $s_{3}s_{2}s_{1}s_{0} = 0000$\n- Endübertrag: $c_{4} = 1$\n\nGesamt:\n$$\nc_{4}s_{3}s_{2}s_{1}s_{0} = 10010_{(2)} = 18\n$$\n\n---\n\n## Merksätze\n\n- **Multiplexer** wählen aus mehreren Eingängen **einen** Ausgang; **Demultiplexer** verteilen **einen** Eingang auf mehrere Ausgänge.\n- Ein $n$:1-Multiplexer kann jede Boolesche Funktion von $\\log_{2}(n)$ Variablen realisieren (Steuersignale = Variablen, Dateneingänge = Konstanten).\n- **Halbaddierer:** addiert 2 Bits ohne Carry-in,  \n  $s = a \\oplus b$, $c = a b$.\n- **Volladdierer:** addiert 2 Bits plus Carry-in,  \n  $s = a \\oplus b \\oplus c_{\\text{in}}$,  \n  $c_{\\text{out}} = a b + a c_{\\text{in}} + b c_{\\text{in}}$.\n- **Carry-Ripple-Addierer:** einfach, flächensparend, aber langsam (Laufzeit $\\propto n$).\n- **Carry-Look-Ahead-Addierer:** schnell (parallele Carry-Berechnung), aber flächenintensiv.\n- **Inkrementierer:** ist ein Addierer mit $b=0$ und $c_{0}=1$; kann mit vereinfachter Logik realisiert werden.\n- **Subtraktion** wird als Addition des Zweierkomplements umgesetzt: $a - b = a + (-b)$.\n- **Binäre Multiplikation** ist eine Kombination aus Verschieben und Addieren; Matrixmultiplizierer bilden die schriftliche Multiplikation in Hardware nach.\n- Die **ALU** bündelt arithmetische und logische Operationen; Flags liefern wichtige Statusinformationen (Carry, Overflow, Zero, Negative).",
    "generatedAt": "2025-12-05T17:37:50.446Z"
  },
  {
    "id": "1764956314772-16xno05vk",
    "scriptId": "1764951110310-ivro48b6m",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Zeitverhalten von Schaltsystemen, Hazards und Glitches\n\nKurze Übersicht über zeitliches Verhalten kombinatorischer Schaltungen, Gatterverzögerungen sowie Entstehung und Vermeidung von Hazards.\n\n---\n\n## 1. Zeitverhalten von Schaltnetzen\n\n### 1.1 Grundidee\n\n- Schaltnetze werden nicht nur funktional (Wahrheitstabelle), sondern auch **zeitlich** betrachtet.\n- *Signalverlauf*: Darstellung der Signalwerte in Abhängigkeit von der Zeit $t$.\n- Ziel: zeitliche **Kausalitäten** und **Folgen von Ereignissen** (Flanken, Verzögerungen) erkennen.\n\n---\n\n## 2. Logiksignale in der Praxis\n\n### 2.1 Nicht-ideale Rechtecksignale\n\nReale Logiksignale sind keine idealen Rechtecksignale:\n- Flanken werden durch jedes Gatter **abgeflacht / weicher**.\n- Signalübergänge benötigen endliche Zeit.\n\n### 2.2 Wichtige Zeitgrößen eines Signals\n\n- **Abfallzeit** (*fall time*) $t_F$  \n  *Definition*: Zeit, die ein Ausgang benötigt, um von HIGH nach LOW zu wechseln.\n\n- **Anstiegszeit** (*rise time*) $t_R$  \n  *Definition*: Zeit, die ein Ausgang benötigt, um von LOW nach HIGH zu wechseln.\n\n- **Pulsbreite** (*pulse width*) $t_{\\text{PULS}}$  \n  *Definition*: Dauer, für die ein Signal auf LOW bzw. HIGH bleibt.\n\n---\n\n## 3. Gatterverzögerung (Propagation Delay)\n\n### 3.1 Definition\n\n- Eine Änderung am Eingang eines Gatters wirkt sich erst nach einer **Verzögerungszeit** am Ausgang aus.\n- *Gatterverzögerung* (engl. *propagation delay*):\n  - für fallende Flanke: $t_{PHL}$\n  - für steigende Flanke: $t_{PLH}$\n\nAllgemein:\n- $t_{PHL}$: Zeit von Eingang HIGH→LOW bis Ausgang HIGH→LOW.\n- $t_{PLH}$: Zeit von Eingang LOW→HIGH bis Ausgang LOW→HIGH.\n\n### 3.2 Größenordnung\n\n- Typische Werte (technologieabhängig):\n  - ca. $100\\,\\text{ps}$ bis $100\\,\\text{ns}$.\n\n---\n\n## 4. Kurzzeitige Änderungen am Ausgang (Glitches)\n\n### 4.1 Beispielidee\n\nSchaltung:\n- Eingang $a$ geht direkt und über einen Inverter $\\overline{a}$ auf ein UND-Gatter:\n  $$y = a \\land \\overline{a}$$\n\nNach boolescher Algebra:\n- $$a \\land \\overline{a} = 0$$\n- Theoretisch: $y$ sollte **immer** $0$ sein.\n\nIn der Realität:\n- Durch die **Gatterverzögerung** des Inverters entsteht bei einer Flankenänderung von $a$ ein **kurzzeitiger HIGH-Impuls** am Ausgang $y$ (ein *Glitch*).\n\n---\n\n## 5. Hazards und Glitches\n\n### 5.1 Begriffe\n\n- **Glitch**  \n  *Definition*: Eine **nicht beabsichtigte** Signaländerung (kurzer Impuls) am Ausgang eines Logikgatters.\n\n- **Hazard**  \n  *Definition*: Eine **Konfiguration** in einer Schaltung, bei der ein Glitch auftreten **kann** (aber nicht muss).\n\n### 5.2 Ursachen\n\n- **Gatterverzögerungen** (*cell delay*).\n- **Laufzeitverzögerungen in Verbindungsleitungen** (*net delay*).\n- Unterschiedliche **Laufzeiten** auf verschiedenen Pfaden vom Eingang zum Ausgang.\n\n### 5.3 Kritikalität\n\n- Gefährlich, wenn Glitches:\n  - in nachfolgende Logik übernommen werden,\n  - z. B. Flipflops, Speicher oder weitere Gatter **falsch triggern**.\n\n---\n\n## 6. Klassifikation von Hazards\n\n### 6.1 Statischer Hazard\n\n- *Definition*: Ein Wechsel an einem Eingang führt zu einem **einmaligen, temporären** Wechsel des Ausgangs, obwohl der Ausgangswert **eigentlich konstant** bleiben sollte.\n\nArten:\n- **Statischer 0-Hazard**:  \n  Ausgang sollte $0$ bleiben, zeigt aber kurzzeitig $1$.\n- **Statischer 1-Hazard**:  \n  Ausgang sollte $1$ bleiben, zeigt aber kurzzeitig $0$.\n\n### 6.2 Dynamischer Hazard\n\n- *Definition*: Ein Wechsel an einem Eingang führt zu einem **mehrfachen** Wechsel des Ausgangs (z. B. $0 \\to 1 \\to 0 \\to 1$), bis sich der Ausgang stabilisiert.\n\nZusammenhang:\n- Dynamische Hazards entstehen oft aus **statischen Hazards** in Zwischensignalen.\n\n---\n\n## 7. Logik-Hazards vs. Funktions-Hazards\n\n### 7.1 Logik-Hazard\n\n- *Definition*: Ein Schaltnetz enthält einen **Logik-Hazard**, wenn der **alleinige** Signalwechsel **einer einzigen** Eingangsleitung zu einem Störimpuls führt.\n\nBedingungen:\n1. **Rekonvergenz**:\n   - Ein Signalzweig verzweigt sich und trifft später wieder an einem Gattereingang zusammen.\n2. **Laufzeitunterschiede**:\n   - Die verzweigten Signalwege haben unterschiedliche Verzögerungen.\n\n### 7.2 Funktions-Hazard\n\n- *Definition*: Ein Schaltnetz enthält einen **Funktions-Hazard**, wenn der **gleichzeitige** Wechsel **mehrerer** Eingangsleitungen zu einem Störimpuls führt.\n- Kann auch auftreten, wenn das Netz **frei von Logik-Hazards** ist.\n\n---\n\n## 8. Beispiele für Hazards\n\n### 8.1 Beispiel: Statischer Hazard\n\nGegeben sei:\n$$\ny = (a \\lor b) \\land (\\neg b \\lor c)\n$$\n\nAlgebraische Umformung (Distributivgesetz):\n\\[\n\\begin{aligned}\ny &= (a \\lor b) \\land (\\neg b \\lor c) \\\\\n  &= a\\neg b \\lor ac \\lor b\\neg b \\lor bc \\\\\n  &= a\\neg b \\lor ac \\lor bc\n\\end{aligned}\n\\]\n\nSetze $a = 0$ und $c = 0$:\n\\[\n\\begin{aligned}\ny &= (0 \\land \\neg b) \\lor (0 \\land 0) \\lor (b \\land 0) \\\\\n  &= 0 \\lor 0 \\lor 0 \\\\\n  &= 0\n\\end{aligned}\n\\]\n\n- **Funktional**: $y$ ist für $a=0, c=0$ immer $0$, unabhängig von $b$.\n- **Mit Verzögerungen**: Bei Änderung von $b$ kann durch unterschiedliche Pfadlängen ein kurzer Impuls (statischer 0-Hazard) auftreten.\n\n### 8.2 Beispiel: Dynamischer Hazard\n\n- Signal $y$ zeigt einen **dynamischen 1-Hazard**.\n- Ursache: Ein **statischer 0-Hazard** in einem Zwischensignal $v$.\n- Mehrfache Umschaltung von $y$, bis sich der Ausgang stabilisiert.\n\n---\n\n## 9. Konstruktion hazard-freier Schaltungen\n\n### 9.1 Vermeidung von Funktions-Hazards: Synchrones Design\n\n- Idee: **Glitches nicht weiterreichen**, indem man nur dann Werte übernimmt, wenn alle Signale **stabil** sind.\n- Umsetzung:\n  - Verwendung eines **Taktsignals**.\n  - Werte werden nur zu definierten Taktflanken in Speicherbausteine übernommen.\n- Ergebnis: **Synchrones Schaltungsdesign** reduziert die Wirkung von Funktions-Hazards.\n\n### 9.2 Vermeidung von Logik-Hazards: Zusätzliche Gatter\n\n- Ansatz:\n  - **Logik-Hazard-freie** Schaltung durch Hinzufügen **zusätzlicher Terme/Gatter**.\n  - Analyse mit **Karnaugh-Veitch-Diagramm (KV-Diagramm)**.\n\n#### 9.2.1 Beobachtung im KV-Diagramm\n\n- Hazards entstehen, wenn **Primterm-Blöcke nicht überlappen**.\n- Problem: Übergang zwischen zwei benachbarten $1$-Feldern, die **zu verschiedenen Blöcken** gehören.\n\n#### 9.2.2 Kriterium für Hazard-Freiheit\n\n*Eine Schaltfunktion ist gegen Logik-Hazards abgesichert, wenn:*\n\n- **Alle Paare benachbarter Einsfelder** im KV-Diagramm\n- **mindestens einem gemeinsamen Primblock** angehören.\n\nKonsequenz:\n- Man fügt **zusätzliche Primterme** hinzu, um **Überlappung** zu erzwingen.\n- Dies erzeugt oft ein **zusätzliches Gatter** in der Implementierung.\n\n---\n\n## 10. Übersichtstabelle wichtiger Begriffe\n\n| Begriff                | Bedeutung                                                                 |\n|------------------------|---------------------------------------------------------------------------|\n| $t_F$                  | Abfallzeit (HIGH $\\to$ LOW)                                              |\n| $t_R$                  | Anstiegszeit (LOW $\\to$ HIGH)                                            |\n| $t_{PHL}$              | Gatterverzögerung bei fallender Flanke                                   |\n| $t_{PLH}$              | Gatterverzögerung bei steigender Flanke                                  |\n| Glitch                 | Unbeabsichtigter kurzer Impuls am Ausgang                                |\n| Hazard                 | Konfiguration, in der ein Glitch auftreten kann                          |\n| Statischer 0-Hazard    | Ausgang sollte $0$ bleiben, zeigt kurzzeitig $1$                         |\n| Statischer 1-Hazard    | Ausgang sollte $1$ bleiben, zeigt kurzzeitig $0$                         |\n| Dynamischer Hazard     | Mehrfaches Umschalten des Ausgangs beim Übergang                         |\n| Logik-Hazard           | Hazard durch Wechsel **eines** Eingangs bei Rekonvergenz und Laufzeitdiff. |\n| Funktions-Hazard       | Hazard durch gleichzeitigen Wechsel **mehrerer** Eingänge                |\n\n---\n\n## 11. Merksätze\n\n- **Gatterverzögerungen** führen dazu, dass reale Schaltungen sich **zeitlich** anders verhalten als die reine boolesche Funktion.\n- Ein **Glitch** ist ein **kurzer, unerwünschter Impuls** am Ausgang; ein **Hazard** ist die zugrunde liegende **Konfiguration**, die diesen Impuls ermöglicht.\n- **Statische Hazards**: Ausgang sollte konstant bleiben, ändert sich aber kurzzeitig **einmal**.  \n  **Dynamische Hazards**: Ausgang ändert sich **mehrfach**, bevor er stabil ist.\n- **Logik-Hazards** entstehen durch **Rekonvergenz** und **unterschiedliche Laufzeiten** bei Änderung **eines** Eingangs.\n- **Funktions-Hazards** treten bei **gleichzeitigem Wechsel mehrerer Eingänge** auf und können auch bei logik-hazard-freien Schaltungen vorkommen.\n- Im **KV-Diagramm**: Eine Funktion ist logik-hazard-frei, wenn **alle benachbarten Einsfelder** in **mindestens einem gemeinsamen Block** enthalten sind.\n- **Synchrones Design** mit Taktsignalen hilft, die Auswirkungen von Glitches auf nachfolgende Stufen zu vermeiden.",
    "generatedAt": "2025-12-05T17:38:34.772Z"
  },
  {
    "id": "1764956374844-qpft2n7xx",
    "scriptId": "1764951108709-rm5qa958c",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Normalformen und Minimierung boolescher Funktionen\n\nKurze Übersicht über Minterme, Maxterme, Normalformen und KV-Diagramme zur Minimierung.\n\n---\n\n## Grundbegriffe der Booleschen Algebra\n\n### Literale und Monome\n\n- *Literal*: Variable oder negierte Variable  \n  Beispiele: $a$, $b$, $\\lnot c$, $\\overline{x}$\n\n- *Monom*: UND-Verknüpfung von Literalen  \n  Beispiele:\n  - $(a \\land b \\land \\lnot c) = ab\\overline{c}$\n  - $x y \\overline{z}$\n\n- *Schaltfunktion eines Monoms*:\n  - Ein Monom ist genau dann $1$, wenn\n    - alle nicht negierten Variablen $1$ sind und\n    - alle negierten Variablen $0$ sind.\n  - Beispiel: $\\,\\overline{x}y\\overline{z} = 1$ genau für $x = 0,\\ y = 1,\\ z = 0$.\n\n- *ODER-Verknüpfung von Monomen*:\n  - Boolescher Ausdruck $y = m_1 \\lor m_2 \\lor \\dots \\lor m_k$ ist $1$, wenn mindestens ein Monom $m_i$ zu $1$ evaluiert.\n  - Jede boolesche Funktion lässt sich als ODER von Monomen darstellen.\n\n---\n\n## Minterme und Maxterme\n\n### Minterm\n\n*Definition*:  \nGegeben sei eine boolesche Funktion\n$$\ny = f(x_n, \\dots, x_1, x_0).\n$$\nEin **Minterm** ist ein Monom, in dem **alle Variablen** $x_i$ genau einmal vorkommen (entweder negiert oder nicht negiert).\n\n- Ein Minterm evaluiert **genau für eine** bestimmte Belegung der Variablen zu $1$, sonst zu $0$.\n- Formell: Ein Minterm $m$ ist $1$, wenn\n  - für alle negierten Variablen $x_i = 0$,\n  - für alle nicht negierten Variablen $x_i = 1$.\n\nBeispiel (3 Variablen $x_2,x_1,x_0$):\n\n| Belegung $(x_2,x_1,x_0)$ | zugehöriger Minterm | Wert des Minterms |\n|--------------------------|---------------------|-------------------|\n| $(0,0,0)$                | $\\overline{x_2}\\,\\overline{x_1}\\,\\overline{x_0}$ | $1$ nur bei $(0,0,0)$ |\n| $(0,1,0)$                | $\\overline{x_2}\\,x_1\\,\\overline{x_0}$           | $1$ nur bei $(0,1,0)$ |\n\nAllgemein: Es gibt $2^n$ Minterme für $n$ Variablen.\n\n---\n\n### Maxterm\n\n*Definition*:  \nEin **Maxterm** ist eine ODER-Verknüpfung aller Variablen, wobei jede Variable genau einmal vorkommt (negiert oder nicht negiert).\n\n- Ein Maxterm evaluiert **genau für eine** bestimmte Belegung der Variablen zu $0$, sonst zu $1$.\n- Formell: Ein Maxterm $M$ ist $0$, wenn\n  - für alle negierten Variablen $x_i = 1$,\n  - für alle nicht negierten Variablen $x_i = 0$.\n\nBeispiel (3 Variablen $x_2,x_1,x_0$):\n\n| Belegung $(x_2,x_1,x_0)$ | zugehöriger Maxterm           | Wert des Maxterms |\n|--------------------------|--------------------------------|-------------------|\n| $(0,0,0)$                | $x_2 \\lor x_1 \\lor x_0$        | $0$ nur bei $(0,0,0)$ |\n| $(0,1,0)$                | $x_2 \\lor \\overline{x_1} \\lor x_0$ | $0$ nur bei $(0,1,0)$ |\n\nAuch hier: Es gibt $2^n$ Maxterme für $n$ Variablen.\n\n---\n\n## Disjunktive und konjunktive Normalform\n\n### Disjunktive Normalform (DNF)\n\n*Definition*:  \nEine **disjunktive Normalform (DNF)** ist eine ODER-Verknüpfung von Mintermen:\n$$\nf(x_n,\\dots,x_0) = \\bigvee_{i \\in I} m_i,\n$$\nwobei $m_i$ Minterme sind.\n\n- In der **kanonischen DNF** kommen **alle Minterme vor, für die $f=1$** ist.\n- Aus der Wahrheitstabelle:\n  - Für jede Zeile mit $y=1$ → zugehörigen Minterm bilden → alle per ODER verknüpfen.\n\nBeispiel (3 Variablen $x_2,x_1,x_0$):\n\n| Index $i$ | $x_2$ | $x_1$ | $x_0$ | $y$ |\n|-----------|-------|-------|-------|-----|\n| 0         | 0     | 0     | 0     | 0   |\n| 1         | 0     | 0     | 1     | 1   |\n| 2         | 0     | 1     | 0     | 1   |\n| 3         | 0     | 1     | 1     | 0   |\n| 4         | 1     | 0     | 0     | 1   |\n| 5         | 1     | 0     | 1     | 0   |\n| 6         | 1     | 1     | 0     | 0   |\n| 7         | 1     | 1     | 1     | 1   |\n\nZeilen mit $y=1$: $i=1,2,4,7$.\n\nZuordnung der Minterme:\n- $i=1$: $(0,0,1) \\Rightarrow \\overline{x_2}\\,\\overline{x_1}\\,x_0$\n- $i=2$: $(0,1,0) \\Rightarrow \\overline{x_2}\\,x_1\\,\\overline{x_0}$\n- $i=4$: $(1,0,0) \\Rightarrow x_2\\,\\overline{x_1}\\,\\overline{x_0}$\n- $i=7$: $(1,1,1) \\Rightarrow x_2\\,x_1\\,x_0$\n\n**Kanonische DNF:**\n$$\ny = \\overline{x_2}\\,\\overline{x_1}\\,x_0\n  \\;\\lor\\; \\overline{x_2}\\,x_1\\,\\overline{x_0}\n  \\;\\lor\\; x_2\\,\\overline{x_1}\\,\\overline{x_0}\n  \\;\\lor\\; x_2\\,x_1\\,x_0.\n$$\n\n---\n\n### Konjunktive Normalform (KNF)\n\n*Definition*:  \nEine **konjunktive Normalform (KNF)** ist eine UND-Verknüpfung von Maxtermen:\n$$\nf(x_n,\\dots,x_0) = \\bigwedge_{j \\in J} M_j,\n$$\nwobei $M_j$ Maxterme sind.\n\n- In der **kanonischen KNF** kommen **alle Maxterme vor, für die $f=0$** ist.\n- Aus der Wahrheitstabelle:\n  - Für jede Zeile mit $y=0$ → zugehörigen Maxterm bilden → alle per UND verknüpfen.\n\nBeispiel mit derselben Tabelle:\n\nZeilen mit $y=0$: $i=0,3,5,6$.\n\nZuordnung der Maxterme (Achtung: Maxterm ist $0$ bei der Belegung):\n\n- $i=0$: $(0,0,0)$  \n  Maxterm: $x_2 \\lor x_1 \\lor x_0$\n- $i=3$: $(0,1,1)$  \n  Maxterm: $x_2 \\lor \\overline{x_1} \\lor \\overline{x_0}$\n- $i=5$: $(1,0,1)$  \n  Maxterm: $\\overline{x_2} \\lor x_1 \\lor \\overline{x_0}$\n- $i=6$: $(1,1,0)$  \n  Maxterm: $\\overline{x_2} \\lor \\overline{x_1} \\lor x_0$\n\n**Kanonische KNF:**\n$$\ny = (x_2 \\lor x_1 \\lor x_0)\n\\land (x_2 \\lor \\overline{x_1} \\lor \\overline{x_0})\n\\land (\\overline{x_2} \\lor x_1 \\lor \\overline{x_0})\n\\land (\\overline{x_2} \\lor \\overline{x_1} \\lor x_0).\n$$\n\n---\n\n### Zusammenhang DNF ↔ KNF\n\n- DNF aus allen Mintermen mit $f=1$.\n- KNF aus allen Maxtermen mit $f=0$.\n- Umrechnung:\n  - DNF → KNF: Verwende die Maxterme, deren Indizes **nicht** in der Minterm-Menge liegen.\n  - KNF → DNF: Verwende die Minterme, deren Indizes **nicht** in der Maxterm-Menge liegen.\n\n---\n\n## Realisierung durch Logikgatter\n\n### DNF → Schaltkreis\n\n- Jeder Minterm $\\Rightarrow$ **UND-Gatter** mit $n$ Eingängen.\n- Variablen ggf. negieren (NOT-Gatter).\n- Alle UND-Ausgänge per **ODER-Gatter** zusammenführen.\n\nBeispiel:\n$$\ny = f(a,b,c) = a b \\overline{c}.\n$$\n\n- NOT-Gatter: Eingang $c$ → $\\overline{c}$.\n- UND-Gatter: Eingänge $a, b, \\overline{c}$ → liefert $ab\\overline{c}$.\n- Da nur ein Minterm: ODER-Stufe trivial (ein Eingang).\n\n---\n\n### KNF → Schaltkreis\n\n- Jeder Maxterm $\\Rightarrow$ **ODER-Gatter** mit $n$ Eingängen.\n- Variablen ggf. negieren (NOT-Gatter).\n- Alle ODER-Ausgänge per **UND-Gatter** zusammenführen.\n\nBeispiel (gleiche Funktion, in KNF dargestellt):  \n$y = f(a,b,c)$ wird als UND von Maxtermen realisiert; jeder Maxterm ist ein ODER-Gatter, deren Ausgänge in ein UND-Gatter gehen.\n\n---\n\n## Vereinigungstheorem und Minimierung\n\n### Vereinigungstheorem\n\n*Formulierung*:\n$$\n(a \\land \\lnot b) \\lor (a \\land b) = a.\n$$\n\n- Zwei Monome, die sich **nur in einer Variable** unterscheiden (einmal negiert, einmal nicht), können zu einem Monom ohne diese Variable zusammengefasst werden.\n\nAllgemeiner Merksatz:\n- Kommen in der $1$-Menge zwei Minterme vor, die sich nur in einer Variable unterscheiden, kann man diese Variable im resultierenden Monom weglassen.\n\nBeispiel:\n$$\ny = (\\lnot a \\land \\lnot b) \\lor (\\lnot a \\land b)\n= \\lnot a \\land (\\lnot b \\lor b)\n= \\lnot a.\n$$\n\n---\n\n### Begriffe für die Minimierung\n\n- *Gebundene Variable*: In zwei Belegungen hat die Variable denselben Wert.\n- *Freie Variable*: In zwei Belegungen hat die Variable unterschiedliche Werte.\n- *Benachbarte Belegungen*: Belegungen, die sich in **genau einer** freien Variable unterscheiden.\n\n**Regel**:  \nZwei Belegungen können durch **ein einziges Monom** repräsentiert werden, wenn sie benachbart sind (unterscheiden sich nur in einer Variable).  \nMehr als eine freie Variable → keine direkte Zusammenfassung möglich.\n\n---\n\n## Karnaugh-Veitch-Diagramme (KV-Diagramme)\n\n### Zweck\n\n- Grafische Methode zur **Vereinfachung** boolescher Funktionen.\n- Ziel: Aus einer DNF eine **minimale disjunktive Form** (DMF) gewinnen:\n  - minimale Anzahl von Monomen\n  - Monome selbst möglichst einfach (wenige Literale).\n\n---\n\n### Aufbau von KV-Diagrammen\n\n- Für $n$ Variablen: $2^n$ Zellen.\n- Jede Zelle $\\leftrightarrow$ genau eine Zeile der Wahrheitstabelle.\n- Anordnung in **Gray-Code-Reihenfolge**, sodass benachbarte Zellen sich in genau **einer Variable** unterscheiden.\n- Kanten sind benachbart (*warp-around*):\n  - linke und rechte Kante benachbart,\n  - obere und untere Kante benachbart.\n\nBeispiel: 4 Variablen $x_3,x_2,x_1,x_0$:\n\n- Zeilen: z.B. $x_3 x_2 \\in \\{00,01,11,10\\}$ (Gray-Code).\n- Spalten: $x_1 x_0 \\in \\{00,01,11,10\\}$.\n\nJede Zelle trägt:\n- Funktionswert $f$ (0 oder 1, ggf. don't care),\n- optional Index der Belegung (z.B. $(x_3x_2x_1x_0)$ als Binärzahl).\n\n---\n\n### Übertragung der Wahrheitstafel in das KV-Diagramm\n\nVorgehen:\n1. Wahrheitstafel vollständig aufstellen.\n2. Für jede Belegung $(x_n,\\dots,x_0)$:\n   - passende Zelle im KV-Diagramm finden (nach Gray-Code).\n   - Funktionswert $f$ in die Zelle eintragen:\n     - $1$ für $f=1$,\n     - $0$ für $f=0$,\n     - ggf. $X$ für *don't care*.\n\n---\n\n## Minimierung mit KV-Diagrammen\n\n### Blöcke und Implikanten\n\n- *Implikant*: Monom (bzw. Block im KV-Diagramm), das eine Untermenge der $1$-Menge (und evtl. don't cares) abdeckt.\n- *Block*: Rechteckiger Bereich von Zellen mit nur $1$ (und optional $X$).\n- Höhe und Breite eines Blocks sind **Zweierpotenzen**:\n  - $1,2,4,8,\\dots$ Zellen in jeder Richtung.\n- Blöcke dürfen sich **überlappen**.\n- Blöcke dürfen über die Ränder gehen (*warp-around*).\n\n**Arten von Implikanten:**\n\n- **Primimplikant**:\n  - Implikant, der nicht mehr mit einem benachbarten Implikanten zu einem größeren Block zusammengefasst werden kann.\n- **Essentieller Primimplikant**:\n  - Primimplikant, der **mindestens eine 1** abdeckt, die von **keinem anderen** Primimplikanten abgedeckt wird.\n  - Essentielle Primimplikanten **müssen** in der minimalen Überdeckung enthalten sein.\n- *Don't cares*:\n  - Dürfen verwendet werden, um größere Blöcke zu bilden.\n  - Zählen **nicht** dafür, ob ein Primimplikant essentiell ist.\n\n---\n\n### Vorgehensweise bei der Minimierung (mit KV)\n\n1. **Primimplikanten finden**\n   - Alle maximal großen Blöcke aus 1-en (und X) bilden:\n     - Blockgrößen: $1,2,4,8,\\dots$ Zellen.\n     - horizontal, vertikal, über Kanten hinweg.\n   - Jeder solcher maximaler Block entspricht einem Primimplikanten.\n\n2. **Essentielle Primimplikanten bestimmen**\n   - Für jede Zelle mit $1$ prüfen:\n     - Wenn sie nur in einem Primimplikanten enthalten ist → dieser ist essentiell.\n   - Alle essentiellen Primimplikanten in die Lösung übernehmen.\n   - Alle von ihnen abgedeckten 1-en streichen (als „erledigt“ markieren).\n\n3. **Restliche 1-en abdecken**\n   - Falls noch 1-en übrig sind:\n     - Wähle eine minimale Menge weiterer Primimplikanten, die diese abdeckt.\n     - Bevorzuge Primimplikanten mit großen Blöcken (vereinfachen den Ausdruck).\n\n4. **Booleschen Ausdruck ablesen**\n   - Für jeden verwendeten Block:\n     - Bestimme, welche Variablen in diesem Block **konstant** sind (0 oder 1).\n     - Jede konstante 1-Variable → nicht negiertes Literal.\n     - Jede konstante 0-Variable → negiertes Literal.\n     - Freie Variablen (wechseln im Block) → kommen **nicht** vor.\n   - Alle so gewonnenen Monome per ODER verknüpfen → minimale DNF (DMF).\n\n---\n\n## Durchgerechnetes Beispiel mit KV-Diagramm\n\n### Beispiel-Funktion (3 Variablen)\n\nGegeben sei die Funktion $y = f(a,b,c)$ mit:\n\n| $a$ | $b$ | $c$ | $y$ |\n|-----|-----|-----|-----|\n| 0   | 0   | 0   | 1   |\n| 0   | 0   | 1   | 0   |\n| 0   | 1   | 0   | 1   |\n| 0   | 1   | 1   | 0   |\n| 1   | 0   | 0   | 0   |\n| 1   | 0   | 1   | 0   |\n| 1   | 1   | 0   | 0   |\n| 1   | 1   | 1   | 1   |\n\n1. **Kanonische DNF aus der Wahrheitstafel**\n\nZeilen mit $y=1$:\n- $(a,b,c) = (0,0,0) \\Rightarrow \\overline{a}\\,\\overline{b}\\,\\overline{c}$\n- $(0,1,0) \\Rightarrow \\overline{a}\\,b\\,\\overline{c}$\n- $(1,1,1) \\Rightarrow a\\,b\\,c$\n\nKanonische DNF:\n$$\ny = \\overline{a}\\,\\overline{b}\\,\\overline{c}\n  \\;\\lor\\; \\overline{a}\\,b\\,\\overline{c}\n  \\;\\lor\\; a\\,b\\,c.\n$$\n\n2. **KV-Diagramm (3 Variablen)**\n\nOrdne z.B. $a$ als Zeilenvariable, $b,c$ als Spaltenvariablen (Gray-Code für $bc$: $00,01,11,10$):\n\n| $a \\backslash bc$ | $00$ | $01$ | $11$ | $10$ |\n|-------------------|------|------|------|------|\n| $a=0$             |  1   |  0   |  0   |  1   |\n| $a=1$             |  0   |  0   |  1   |  0   |\n\n3. **Blöcke bilden**\n\n- Obere Zeile: Zellen $(a=0,bc=00)$ und $(a=0,bc=10)$ sind **benachbart** (warp-around in Spalten).\n  - Block der Größe $2 \\times 1$ (horizontales Paar).\n  - In diesem Block:\n    - $a = 0$ konstant → $\\overline{a}$.\n    - $c = 0$ konstant (Spalten $00$ und $10$) → $\\overline{c}$.\n    - $b$ wechselt ($0 \\leftrightarrow 1$) → frei.\n  - Monom: $\\overline{a}\\,\\overline{c}$.\n\n- Untere Zeile: einzelne 1 bei $(a=1,bc=11)$:\n  - Kein größerer Block möglich → $1 \\times 1$ Block.\n  - Belegung: $a=1,\\ b=1,\\ c=1$.\n  - Monom: $a b c$.\n\n4. **Minimale DNF**\n\nMinimale disjunktive Form (DMF):\n$$\ny = \\overline{a}\\,\\overline{c} \\;\\lor\\; a b c.\n$$\n\nDiese ist kürzer als die kanonische DNF.\n\n---\n\n## Merksätze\n\n- **Minterm**: UND-Verknüpfung aller Variablen (jeder genau einmal, evtl. negiert), ist **1** für genau eine Belegung.\n- **Maxterm**: ODER-Verknüpfung aller Variablen (jeder genau einmal, evtl. negiert), ist **0** für genau eine Belegung.\n- **DNF**: ODER von Mintermen, die alle $f=1$-Belegungen abdecken.\n- **KNF**: UND von Maxtermen, die alle $f=0$-Belegungen abdecken.\n- **Vereinigungstheorem**: $(a \\land \\lnot b) \\lor (a \\land b) = a$ → Monome, die sich nur in einer Variable unterscheiden, können zusammengefasst werden.\n- **KV-Diagramm**:\n  - Benachbarte Zellen unterscheiden sich in genau **einer** Variable.\n  - Blöcke haben Größe $2^k$ Zellen.\n  - Blöcke dürfen sich überlappen und über Kanten gehen.\n- **Primimplikant**: maximaler Block (nicht weiter vergrößerbar).\n- **Essentieller Primimplikant**: deckt mindestens eine 1 ab, die kein anderer Primimplikant abdeckt → immer in der minimalen Lösung enthalten.\n- **Ziel der Minimierung**: möglichst wenige und möglichst einfache Monome in der disjunktiven Minimalform.",
    "generatedAt": "2025-12-05T17:39:34.844Z"
  },
  {
    "id": "1764956441881-ry123j6zc",
    "scriptId": "1764951106552-vqgbxcvya",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Normalformen und Minimierung – Quine-McCluskey-Verfahren\n\nKurzer Überblick:  \nThema sind **Minimierungsverfahren** für boolesche Funktionen mit Schwerpunkt auf dem **tabellarischen Quine-McCluskey-Verfahren** zur Bestimmung der disjunktiven Minimalform (DMF), insbesondere für Funktionen mit vielen Variablen.\n\n---\n\n## 1. Kernkonzepte (Recap)\n\n### Minterme und Maxterme\n\n- *Minterm* einer Funktion $f(x_1,\\dots,x_n)$:\n  - Ein Produktterm (AND-Verknüpfung) aller $n$ Variablen, jede in positiver oder negierter Form.\n  - Er ist genau für **eine** Belegung der Variablen $1$ und sonst $0$.\n  - Beispiel für $f(x_1,x_0)$:  \n    - $m_0 = \\overline{x_1}\\,\\overline{x_0}$  \n    - $m_1 = \\overline{x_1}\\,x_0$  \n    - $m_2 = x_1\\,\\overline{x_0}$  \n    - $m_3 = x_1\\,x_0$\n\n- *Maxterm*:\n  - Ein Summenterm (OR-Verknüpfung) aller $n$ Variablen, jede in positiver oder negierter Form.\n  - Er ist genau für **eine** Belegung $0$ und sonst $1$.\n\n---\n\n### Normalformen\n\n- **Disjunktive Normalform (DNF)**:\n  - Summe (ODER) von Produkten (UND) von Literalen.\n  - Allgemein:\n    $$f = \\bigvee_i m_i$$\n    wobei $m_i$ Minterme sind.\n\n- **Konjunktive Normalform (KNF)**:\n  - Produkt (UND) von Summen (ODER) von Literalen.\n  - Allgemein:\n    $$f = \\bigwedge_j M_j$$\n    wobei $M_j$ Maxterme sind.\n\n- **Disjunktive Minimalform (DMF)**:\n  - DNF mit minimaler Anzahl an Literalen/Termen, äquivalent zur Funktion.\n\n- **Konjunktive Minimalform (KMF)**:\n  - KNF mit minimaler Anzahl an Literalen/Termen, äquivalent zur Funktion.\n\n---\n\n### Implikanten und Primimplikanten\n\n- *Implikant*:\n  - Ein Produktterm $p$, der **nur dort 1 ist, wo auch $f=1$**.\n  - Formal: $p \\Rightarrow f$.\n\n- *Primimplikant*:\n  - Ein Implikant, der nicht mehr erweitert (vereinfacht) werden kann, ohne die Implikanten-Eigenschaft zu verlieren.\n  - Er deckt eine maximal große Gruppe von $1$-Belegungen ab.\n\n- *Essentieller Primimplikant*:\n  - Ein Primimplikant, der mindestens einen Minterm abdeckt, der von **keinem anderen** Primimplikanten abgedeckt wird.\n  - Muss in **jeder** Minimalform enthalten sein.\n\n---\n\n### Don’t Cares\n\n- *Don’t Care* ($d$):\n  - Belegungen, bei denen der Funktionswert egal ist (0 oder 1 möglich).\n  - Können bei der Minimierung als $1$ behandelt werden, um größere Implikanten zu bilden.\n  - Müssen **nicht** in der endgültigen Funktion als 1 realisiert werden.\n\n---\n\n## 2. Arten von Minimierungsverfahren\n\n- **Algebraische Verfahren**\n  - Vereinfachung mit Gesetzen der Booleschen Algebra.\n  - Beispiel:  \n    $$a \\cdot \\overline{b} + a \\cdot b = a$$\n\n- **Graphische Verfahren**\n  - Karnaugh-Veitch-Diagramme (KV-Diagramme).\n  - Gut bis ca. $5$–$6$ Variablen, danach unübersichtlich.\n\n- **Tabellarische Verfahren**\n  - Z. B. **Quine-McCluskey-Verfahren**.\n  - Gut für viele Variablen, einfach computerisierbar.\n\n---\n\n## 3. Quine-McCluskey-Verfahren – Überblick\n\n- Ziel: **Minimierung boolescher Funktionen** (hier: DMF).\n- Ausgangspunkt: **Wahrheitstabelle** bzw. Liste der Minterme, für die $f=1$ (inkl. Don’t Cares).\n- Prinzip ähnlich wie KV-Diagramm:\n  - Terme, die sich nur in **einer** Variablen unterscheiden, werden zusammengefasst.\n- Drei Phasen:\n  1. **Primimplikanten finden**\n  2. **Primimplikantentafel aufstellen**\n  3. **Überdeckungsproblem lösen**\n\n---\n\n## 4. Phase 1: Finden der Primimplikanten\n\n### Vereinigungstheorem\n\nZentrales Gesetz (für DNF-Minimierung):\n\n$$(a \\cdot \\overline{b}) + (a \\cdot b) = a$$\n\n- Zwei Terme, die sich nur im Literal $b$ bzw. $\\overline{b}$ unterscheiden, können zu einem einfacheren Term $a$ zusammengefasst werden.\n- Allgemein:  \n  - Wenn sich zwei Minterme in **genau einer** Variable unterscheiden, kann diese Variable „eliminiert“ werden.\n\n---\n\n### Implikanten-Ordnung\n\n- **Implikanten Ordnung 0**:\n  - Reine Minterme der Funktion (jeweils alle Variablen enthalten).\n- **Implikanten höherer Ordnung**:\n  - Entstehen durch Zusammenfassen von Implikanten niedrigerer Ordnung.\n  - Eine zusammengefasste Variable wird durch ein „Don’t Care“-Symbol (z. B. Strich oder $-$) ersetzt.\n\n---\n\n### 1. Quinesche Tabelle (Phase 1)\n\n1. Ausgangspunkt: alle Minterme (Indexmenge der $1$-Einträge der Wahrheitstabelle).\n2. Sortiere die Minterme nach der **Anzahl der Einsen** in ihrer Binärdarstellung.\n3. Fasse Minterme aus **benachbarten Gruppen** (z. B. mit $k$ und $k+1$ Einsen) zusammen, wenn sie sich in genau einem Bit unterscheiden.\n4. Markierungen:\n   - Implikanten, die zusammengefasst wurden: markiert (z. B. mit $\\rightarrow$).\n   - Implikanten, die **nicht** weiter zusammengefasst werden können: sind **Primimplikanten** (markiert z. B. mit $\\checkmark$).\n5. Wiederhole den Vorgang mit den neu gewonnenen Implikanten (höherer Ordnung), bis keine weitere Zusammenfassung möglich ist.\n\n**Ergebnis von Phase 1:**  \nMenge aller **Primimplikanten**.\n\n---\n\n## 5. Phase 2: Primimplikantentafel\n\n### 2. Quinesche Tabelle\n\n- **Zeilen**: alle in Phase 1 gefundenen **Primimplikanten**.\n- **Spalten**: alle **Minterme** $m_i$, für die $f=1$ (keine Don’t Cares).\n\nIn Feld $(\\text{Zeile }P_j,\\ \\text{Spalte }m_i)$:\n\n- Markierung (z. B. $\\circ$), wenn Primimplikant $P_j$ den Minterm $m_i$ **überdeckt**.\n\n---\n\n### Essentielle Primimplikanten\n\n- Ein Primimplikant ist **essentiell**, wenn er einen Minterm überdeckt, der in seiner Spalte **genau einmal** markiert ist.\n- Markierung (z. B. $\\bullet$) in der entsprechenden Zelle.\n\n**Vorgehen in Phase 2:**\n\n1. Alle essentiellen Primimplikanten bestimmen.\n2. Diese **müssen** in die endgültige DMF aufgenommen werden.\n3. Sind nach Auswahl der essentiellen Primimplikanten **alle** Minterme überdeckt:\n   - Algorithmus endet.\n   - DMF = Disjunktion aller essentiellen Primimplikanten.\n4. Sonst: weiter mit Phase 3.\n\n---\n\n## 6. Phase 3: Lösen des Überdeckungsproblems\n\nNach Auswahl der essentiellen Primimplikanten:\n\n1. **Zeilen** der essentiellen Primimplikanten aus der Tafel streichen.\n2. **Spalten** der von ihnen überdeckten Minterme streichen.\n3. Ergebnis ist eine **reduzierte Primimplikantentafel**.\n\n---\n\n### Vereinfachungsregeln\n\n- **Zeilenregel**:\n  - Existiert eine Zeile $z_i$ und eine Zeile $z_j$, so dass $z_j$ **alle** Minterme von $z_i$ und **weitere** abdeckt, dann:\n    - $z_i$ wird gestrichen.\n  - Decken zwei Zeilen **gleich viele** Minterme ab:\n    - Behalte die Zeile des Primimplikanten mit **weniger Literalen**.\n\n- **Spaltenregel**:\n  - Wenn ein Minterm $m_a$ immer überdeckt wird, sobald ein anderer Minterm $m_b$ überdeckt wird (d. h. alle Primimplikanten behandeln $m_a$ und $m_b$ gleich), kann eine der beiden Spalten gestrichen werden.\n  - Dient hauptsächlich der Übersichtlichkeit; ändert das Ergebnis nicht.\n\n---\n\n### Zyklische Überdeckungsprobleme\n\n- Fall: In der (reduzierten) Primimplikantentafel gibt es **keine** essentiellen Primimplikanten.\n- Folge:\n  - Es ist nicht eindeutig, welche Primimplikanten in die Lösung aufgenommen werden sollen.\n  - Man muss **alle möglichen Kombinationen** der verbleibenden Primimplikanten prüfen.\n  - Bei $k$ beteiligten Primimplikanten gibt es:\n    $$2^k$$\n    mögliche Kombinationen.\n- Gesucht ist die Kombination mit **minimalen Kosten** (z. B. minimale Anzahl Literale oder Terme).\n\n---\n\n## 7. Durchgerechnetes Beispiel\n\n### Aufgabenstellung\n\nGegeben ist die Wahrheitstabelle:\n\n| Index | $x_2$ | $x_1$ | $x_0$ | $y$ |\n|-------|-------|-------|-------|-----|\n| 0     | 0     | 0     | 0     | 1   |\n| 1     | 0     | 0     | 1     | 1   |\n| 2     | 0     | 1     | 0     | 0   |\n| 3     | 0     | 1     | 1     | 1   |\n| 4     | 1     | 0     | 0     | 0   |\n| 5     | 1     | 0     | 1     | 0   |\n| 6     | 1     | 1     | 0     | 1   |\n| 7     | 1     | 1     | 1     | 1   |\n\nGesucht:\n\n- Primimplikanten mit Quine-McCluskey.\n- Primimplikantentafel.\n- Disjunktive Minimalform von $y$.\n\n---\n\n### 7.1 Minterme bestimmen\n\n$y=1$ für Indexe:\n$$m_0, m_1, m_3, m_6, m_7$$\n\nZuordnung der Minterme (in Literalform):\n\n- $m_0 = \\overline{x_2}\\,\\overline{x_1}\\,\\overline{x_0}$\n- $m_1 = \\overline{x_2}\\,\\overline{x_1}\\,x_0$\n- $m_3 = \\overline{x_2}\\,x_1\\,x_0$\n- $m_6 = x_2\\,x_1\\,\\overline{x_0}$\n- $m_7 = x_2\\,x_1\\,x_0$\n\n---\n\n### 7.2 Phase 1 – Primimplikanten finden\n\n#### Schritt 1: Gruppierung nach Anzahl der Einsen\n\nBinärdarstellung von $(x_2 x_1 x_0)$:\n\n- $m_0: 000$ → $0$ Einsen\n- $m_1: 001$ → $1$ Eins\n- $m_3: 011$ → $2$ Einsen\n- $m_6: 110$ → $2$ Einsen\n- $m_7: 111$ → $3$ Einsen\n\nGruppen:\n\n- Gruppe 0 Einsen: $\\{m_0\\}$\n- Gruppe 1 Eins: $\\{m_1\\}$\n- Gruppe 2 Einsen: $\\{m_3, m_6\\}$\n- Gruppe 3 Einsen: $\\{m_7\\}$\n\n#### Schritt 2: Zusammenfassen benachbarter Gruppen\n\n- Gruppe 0 ↔ Gruppe 1:\n  - $m_0(000)$ und $m_1(001)$ unterscheiden sich nur in $x_0$:\n    - Zusammenfassung: $00-$  \n      $$\\overline{x_2}\\,\\overline{x_1}\\,\\overline{x_0} + \\overline{x_2}\\,\\overline{x_1}\\,x_0 = \\overline{x_2}\\,\\overline{x_1}$$\n    - Implikant: $I_1 = \\overline{x_2}\\,\\overline{x_1}$\n\n- Gruppe 1 ↔ Gruppe 2:\n  - $m_1(001)$ mit $m_3(011)$: unterscheiden sich in $x_1$ → zusammenfassbar:\n    - $0-1$ → $\\overline{x_2}\\,x_0$\n    - Implikant: $I_2 = \\overline{x_2}\\,x_0$\n  - $m_1(001)$ mit $m_6(110)$: unterscheiden sich in mehr als einer Variable → nicht zusammenfassbar.\n\n- Gruppe 2 ↔ Gruppe 3:\n  - $m_3(011)$ mit $m_7(111)$: unterscheiden sich in $x_2$:\n    - $-11$ → $x_1\\,x_0$\n    - Implikant: $I_3 = x_1\\,x_0$\n  - $m_6(110)$ mit $m_7(111)$: unterscheiden sich in $x_0$:\n    - $11-$ → $x_2\\,x_1$\n    - Implikant: $I_4 = x_2\\,x_1$\n\nMarkierung: $m_0, m_1, m_3, m_6, m_7$ wurden jeweils mindestens einmal zusammengefasst.\n\n#### Schritt 3: Weiteres Zusammenfassen prüfen\n\nNun die Implikanten $I_1, I_2, I_3, I_4$:\n\n- $I_1 = \\overline{x_2}\\,\\overline{x_1}$ (00-)\n- $I_2 = \\overline{x_2}\\,x_0$ (0-1)\n- $I_3 = x_1\\,x_0$ (-11)\n- $I_4 = x_2\\,x_1$ (11-)\n\nPrüfe Paarweise:\n\n- $I_1$ vs. $I_2$: Muster 00- und 0-1 → unterscheiden sich in $x_1$ und $x_0$ → **2 Unterschiede**, nicht zusammenfassbar.\n- $I_1$ vs. $I_3$: 00- vs -11 → **3 Unterschiede**, nicht zusammenfassbar.\n- $I_1$ vs. $I_4$: 00- vs 11- → **2 Unterschiede**, nicht zusammenfassbar.\n- $I_2$ vs. $I_3$: 0-1 vs -11 → **2 Unterschiede**, nicht zusammenfassbar.\n- $I_2$ vs. $I_4$: 0-1 vs 11- → **3 Unterschiede**, nicht zusammenfassbar.\n- $I_3$ vs. $I_4$: -11 vs 11- → **2 Unterschiede**, nicht zusammenfassbar.\n\nKein weiteres Zusammenfassen möglich.\n\n**Primimplikanten** sind daher:\n\n- $P_1 = \\overline{x_2}\\,\\overline{x_1}$\n- $P_2 = \\overline{x_2}\\,x_0$\n- $P_3 = x_1\\,x_0$\n- $P_4 = x_2\\,x_1$\n\n---\n\n### 7.3 Phase 2 – Primimplikantentafel\n\nSpalten: Minterme $\\{m_0, m_1, m_3, m_6, m_7\\}$.\n\n| Primimplikant | Form                     | $m_0$ | $m_1$ | $m_3$ | $m_6$ | $m_7$ |\n|---------------|--------------------------|:-----:|:-----:|:-----:|:-----:|:-----:|\n| $P_1$         | $\\overline{x_2}\\,\\overline{x_1}$ |  $\\circ$  |  $\\circ$  |   –   |   –   |   –   |\n| $P_2$         | $\\overline{x_2}\\,x_0$    |   –   |  $\\circ$  |  $\\circ$  |   –   |   –   |\n| $P_3$         | $x_1\\,x_0$               |   –   |   –   |  $\\circ$  |   –   |  $\\circ$  |\n| $P_4$         | $x_2\\,x_1$               |   –   |   –   |   –   |  $\\circ$  |  $\\circ$  |\n\nÜberdeckung im Detail:\n\n- $P_1 = \\overline{x_2}\\,\\overline{x_1}$:\n  - Deckt $m_0(000)$ und $m_1(001)$.\n- $P_2 = \\overline{x_2}\\,x_0$:\n  - Deckt $m_1(001)$ und $m_3(011)$.\n- $P_3 = x_1\\,x_0$:\n  - Deckt $m_3(011)$ und $m_7(111)$.\n- $P_4 = x_2\\,x_1$:\n  - Deckt $m_6(110)$ und $m_7(111)$.\n\n#### Essentielle Primimplikanten bestimmen\n\n- Spalte $m_0$: nur $P_1$ → $P_1$ ist essentiell.\n- Spalte $m_6$: nur $P_4$ → $P_4$ ist essentiell.\n- Spalte $m_1$: $P_1$ und $P_2$ → nicht eindeutig.\n- Spalte $m_3$: $P_2$ und $P_3$ → nicht eindeutig.\n- Spalte $m_7$: $P_3$ und $P_4$ → nicht eindeutig.\n\n**Essentiell:**\n- $P_1 = \\overline{x_2}\\,\\overline{x_1}$\n- $P_4 = x_2\\,x_1$\n\nDiese beiden werden in jedem Fall in die DMF übernommen.\n\nÜberdeckung durch essentielle Primimplikanten:\n\n- $P_1$ deckt: $m_0, m_1$\n- $P_4$ deckt: $m_6, m_7$\n\nNoch **nicht** überdeckt: $m_3$.\n\n---\n\n### 7.4 Phase 3 – Restüberdeckung\n\nReduzierte Tafel nach Streichen:\n\n- Streiche Zeilen von $P_1$ und $P_4$.\n- Streiche Spalten $m_0, m_1, m_6, m_7$.\n\nEs bleibt nur noch Spalte $m_3$ und die zugehörigen Primimplikanten $P_2$ und $P_3$:\n\n| Primimplikant | $m_3$ |\n|---------------|:-----:|\n| $P_2$         | $\\circ$ |\n| $P_3$         | $\\circ$ |\n\nBeide decken $m_3$ ab. Es gibt keinen weiteren Zwang (keine neuen essentiellen Primimplikanten).\n\nVergleiche Kosten (Anzahl Literale):\n\n- $P_2 = \\overline{x_2}\\,x_0$ → 2 Literale.\n- $P_3 = x_1\\,x_0$ → 2 Literale.\n\nBeide sind gleich „teuer“. Man kann **beliebig** einen von beiden wählen.\n\nWähle z. B. $P_2$.\n\n---\n\n### 7.5 Ergebnis: Disjunktive Minimalform\n\nEine mögliche **disjunktive Minimalform** für $y$ ist:\n\n$$\ny = \\overline{x_2}\\,\\overline{x_1} \\;\\vee\\; x_2\\,x_1 \\;\\vee\\; \\overline{x_2}\\,x_0\n$$\n\nAlternativ (gleicher Aufwand) wäre auch:\n\n$$\ny = \\overline{x_2}\\,\\overline{x_1} \\;\\vee\\; x_2\\,x_1 \\;\\vee\\; x_1\\,x_0\n$$\n\nBeide Ausdrücke sind **minimal** und äquivalent zur gegebenen Wahrheitstabelle.\n\n---\n\n## 8. Merksätze\n\n- **Minterm**: Produkt aller Variablen, genau für eine Belegung $1$.\n- **Maxterm**: Summe aller Variablen, genau für eine Belegung $0$.\n- **Primimplikant**: maximaler Implikant, nicht weiter zusammenfassbar.\n- **Essentieller Primimplikant**: deckt mindestens einen Minterm exklusiv; muss in jeder Minimalform vorkommen.\n- **Quine-McCluskey – Phasen**:\n  1. Primimplikanten durch wiederholtes Zusammenfassen finden.\n  2. Primimplikantentafel erstellen und essentielle Primimplikanten bestimmen.\n  3. Restliche Minterme mit minimaler Kombination von Primimplikanten überdecken.\n- **Vereinigungstheorem**:\n  $$(a \\cdot \\overline{b}) + (a \\cdot b) = a$$\n  Grundlage für das Zusammenfassen von Mintermen.\n- **Tabellarische Verfahren** (wie Quine-McCluskey) sind besonders geeignet für Funktionen mit **vielen Variablen**, im Gegensatz zu KV-Diagrammen.",
    "generatedAt": "2025-12-05T17:40:41.881Z"
  },
  {
    "id": "1764956465893-cv1x2h254",
    "scriptId": "1764951104590-7uug6rajw",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Boole’sche Algebra – Axiome und Theoreme\n\nKurze Übersicht über die grundlegenden Rechenregeln der booleschen Algebra, wie sie in der Digitaltechnik und theoretischen Informatik verwendet werden.\n\n---\n\n## 1. Grundbegriffe der booleschen Algebra\n\n### Definitionen\n\n- *Boolesche Variable*: Eine Variable $a$ mit möglichen Werten $0$ (falsch) oder $1$ (wahr).\n- *Operatoren*:\n  - **UND** (Konjunktion): $a \\land b$\n  - **ODER** (Disjunktion): $a \\lor b$\n  - **NICHT** (Negation): $\\lnot a$\n\n### Grundbedeutung\n\n- $a \\land b = 1$ genau dann, wenn **beide** $a$ und $b$ gleich $1$ sind.\n- $a \\lor b = 1$ genau dann, wenn **mindestens eine** der Variablen $1$ ist.\n- $\\lnot a = 1$ genau dann, wenn $a = 0$.\n\n---\n\n## 2. Axiome und Theoreme der booleschen Algebra\n\n### Übersichtstabelle\n\n| Nr. | Name                    | UND-Operator ($\\land$)                             | ODER-Operator ($\\lor$)                             |\n|-----|-------------------------|-----------------------------------------------------|----------------------------------------------------|\n| 1   | Identität               | $a \\land 1 = a$                                     | $a \\lor 0 = a$                                     |\n| 2   | Elimination             | $a \\land 0 = 0$                                     | $a \\lor 1 = 1$                                     |\n| 3   | Idempotenz              | $a \\land a = a$                                     | $a \\lor a = a$                                     |\n| 4   | Involution              | \\multicolumn{2}{c}{$\\lnot(\\lnot a) = a$}                                                               |\n| 5   | Inversion / Komplement  | $a \\land \\lnot a = 0$                               | $a \\lor \\lnot a = 1$                               |\n| 6   | Kommutativität          | $a \\land b = b \\land a$                             | $a \\lor b = b \\lor a$                              |\n| 7   | Assoziativität          | $(a \\land b) \\land c = a \\land (b \\land c)$         | $(a \\lor b) \\lor c = a \\lor (b \\lor c)$            |\n| 8   | Distributivität         | $a \\land (b \\lor c) = (a \\land b) \\lor (a \\land c)$ | $a \\lor (b \\land c) = (a \\lor b) \\land (a \\lor c)$ |\n| 9   | Vereinigung             | $(a \\lor b) \\land (a \\lor \\lnot b) = a$             | $(a \\land b) \\lor (a \\land \\lnot b) = a$           |\n| 10  | Absorption              | $a \\land (a \\lor b) = a$                            | $a \\lor (a \\land b) = a$                           |\n| 11  | Absorption 2            | $(a \\land \\lnot b) \\lor b = a \\lor b$               | $(a \\lor \\lnot b) \\land b = a \\land b$             |\n| 12  | Faktorisierung          | $(a \\lor b) \\land (\\lnot a \\lor c) = (a \\land c) \\lor (\\lnot a \\land b)$ | $(a \\land b) \\lor (\\lnot a \\land c) = (a \\lor c) \\land (\\lnot a \\lor b)$ |\n| 13  | Konsens                 | $(a \\lor b) \\land (b \\lor c) \\land (\\lnot a \\lor c) = (a \\lor b) \\land (\\lnot a \\lor c)$ | $(a \\land b) \\lor (b \\land c) \\lor (\\lnot a \\land c) = (a \\land b) \\lor (\\lnot a \\land c)$ |\n| 14  | De Morgan               | \\multicolumn{2}{c}{$\\lnot(a \\land b \\land \\dots) = \\lnot a \\lor \\lnot b \\lor \\dots$}      |\n|     |                         | \\multicolumn{2}{c}{$\\lnot(a \\lor b \\lor \\dots) = \\lnot a \\land \\lnot b \\land \\dots$}      |\n\n---\n\n## 3. Erläuterung der wichtigsten Gesetze\n\n### 3.1 Identität\n\n- $a \\land 1 = a$  \n  *1 wirkt als neutrales Element der UND-Verknüpfung.*\n\n- $a \\lor 0 = a$  \n  *0 wirkt als neutrales Element der ODER-Verknüpfung.*\n\n---\n\n### 3.2 Elimination\n\n- $a \\land 0 = 0$  \n  *UND mit 0 ist immer 0.*\n\n- $a \\lor 1 = 1$  \n  *ODER mit 1 ist immer 1.*\n\n---\n\n### 3.3 Idempotenz\n\n- $a \\land a = a$\n- $a \\lor a = a$\n\n*Mehrfaches Verknüpfen derselben Variable ändert den Wert nicht.*\n\n---\n\n### 3.4 Involution\n\n- $\\lnot(\\lnot a) = a$  \n\n*Doppelte Negation stellt den ursprünglichen Wert wieder her.*\n\n---\n\n### 3.5 Inversion / Komplement\n\n- $a \\land \\lnot a = 0$\n- $a \\lor \\lnot a = 1$\n\n*Eine Variable und ihr Komplement schließen sich aus bzw. ergänzen sich vollständig.*\n\n---\n\n### 3.6 Kommutativität\n\n- $a \\land b = b \\land a$\n- $a \\lor b = b \\lor a$\n\n*Die Reihenfolge der Operanden ist egal.*\n\n---\n\n### 3.7 Assoziativität\n\n- $(a \\land b) \\land c = a \\land (b \\land c)$\n- $(a \\lor b) \\lor c = a \\lor (b \\lor c)$\n\n*Klammerung kann bei gleichen Operatoren weggelassen/verschoben werden.*\n\n---\n\n### 3.8 Distributivität\n\n- $a \\land (b \\lor c) = (a \\land b) \\lor (a \\land c)$\n- $a \\lor (b \\land c) = (a \\lor b) \\land (a \\lor c)$\n\n*Entspricht dem Ausmultiplizieren bzw. Ausklammern.*\n\n---\n\n### 3.9 Absorption\n\n- $a \\land (a \\lor b) = a$\n- $a \\lor (a \\land b) = a$\n\n*Die komplexere Terme werden von $a$ „aufgesaugt“.*\n\n---\n\n### 3.10 De-Morgan-Gesetze\n\n- $\\lnot(a \\land b) = \\lnot a \\lor \\lnot b$\n- $\\lnot(a \\lor b) = \\lnot a \\land \\lnot b$\n\n*Negation kehrt UND/ODER um und negiert alle Operanden.*\n\n---\n\n## 4. Wahrheitstafeln zu Grundoperatoren\n\n### 4.1 UND ($\\land$)\n\n| $a$ | $b$ | $a \\land b$ |\n|-----|-----|-------------|\n| 0   | 0   | 0           |\n| 0   | 1   | 0           |\n| 1   | 0   | 0           |\n| 1   | 1   | 1           |\n\n### 4.2 ODER ($\\lor$)\n\n| $a$ | $b$ | $a \\lor b$ |\n|-----|-----|------------|\n| 0   | 0   | 0          |\n| 0   | 1   | 1          |\n| 1   | 0   | 1          |\n| 1   | 1   | 1          |\n\n### 4.3 NICHT ($\\lnot$)\n\n| $a$ | $\\lnot a$ |\n|-----|-----------|\n| 0   | 1         |\n| 1   | 0         |\n\n---\n\n## 5. Durchgerechnetes Beispiel (Vereinfachung)\n\n### Aufgabenstellung\n\nVereinfache den booleschen Ausdruck:\n$$\nf(a,b,c) = (a \\land b) \\lor (a \\land \\lnot b) \\,.\n$$\n\n### Schritt-für-Schritt-Lösung\n\n1. **Gemeinsamen Faktor erkennen**  \n   Beide Terme enthalten $a$:\n   $$\n   f = (a \\land b) \\lor (a \\land \\lnot b)\n   $$\n\n2. **Ausklammern von $a$ (Distributivität)**  \n   $$\n   f = a \\land (b \\lor \\lnot b)\n   $$\n\n3. **Verwendung des Komplementgesetzes**  \n   $b \\lor \\lnot b = 1$:\n   $$\n   f = a \\land 1\n   $$\n\n4. **Verwendung der Identität**  \n   $a \\land 1 = a$:\n   $$\n   f = a\n   $$\n\n**Ergebnis:**  \n$$\n(a \\land b) \\lor (a \\land \\lnot b) = a\n$$\n\nDies entspricht dem **Vereinigungs-Gesetz** (Nr. 9 in der Tabelle).\n\n---\n\n## 6. Merksätze\n\n- **Nur $0$ und $1$**: In der booleschen Algebra gibt es nur zwei Werte, alle Ausdrücke reduzieren letztlich auf Kombinationen von $0$, $1$ und Variablen.\n- **Wichtige „Tricks“**:\n  - Komplement: $x \\lor \\lnot x = 1$, $x \\land \\lnot x = 0$.\n  - Ausklammern und Ausmultiplizieren über Distributivität.\n  - Absorption verwenden, um überflüssige Terme zu entfernen.\n- **De Morgan immer parat haben**:\n  - $\\lnot(a \\land b) = \\lnot a \\lor \\lnot b$\n  - $\\lnot(a \\lor b) = \\lnot a \\land \\lnot b$\n- **Ziel bei Vereinfachungen**: Möglichst wenige Operatoren und Variablen, um Schaltungen und Ausdrücke minimal zu halten.",
    "generatedAt": "2025-12-05T17:41:05.893Z"
  },
  {
    "id": "1764956513902-61fgygfu6",
    "scriptId": "1764951102727-lcmjkix0u",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Boolesche Algebra und Schaltalgebra\n\nKurzeinführung in die logischen Grundlagen digitaler Schaltungen und boolescher Funktionen.\n\n---\n\n## Einordnung und Motivation\n\n- **Boolesche Algebra** formalisiert die Verknüpfung von Aussagen (Aussagenlogik).\n- Grundlage zur:\n  - Beschreibung und Analyse digitaler Schaltungen\n  - Konstruktion von CPUs, Speichern und digitalen Systemen\n- Es gibt nur zwei Wahrheitswerte:\n  - $0$ (*falsch*)\n  - $1$ (*wahr*)\n\nDiese Werte lassen sich als Bitwerte oder als Stromzustände interpretieren.\n\n---\n\n## Boolesche Algebra (allgemein)\n\n### Definition (Huntingtonsche Axiome)\n\n*Eine Boolesche Algebra* ist ein Tripel $(B, \\bullet, \\circ)$, bestehend aus:\n\n- einer nichtleeren Menge $B$\n- zwei binären Operationen\n  - $\\bullet : B \\times B \\to B$\n  - $\\circ : B \\times B \\to B$\n\nEs existieren Elemente $e, n \\in B$ (Einselement, Nullelement), so dass für alle $a,b,c \\in B$ gilt:\n\n1. **Kommutativität**\n   - $a \\bullet b = b \\bullet a$\n   - $a \\circ b = b \\circ a$\n\n2. **Distributivität**\n   - $a \\bullet (b \\circ c) = (a \\bullet b) \\circ (a \\bullet c)$\n   - $a \\circ (b \\bullet c) = (a \\circ b) \\bullet (a \\circ c)$\n\n3. **Neutrale Elemente**\n   - $a \\bullet e = a$\n   - $a \\circ n = a$\n\n4. **Inversion (Komplement)**\n   - Es gibt zu jedem $a \\in B$ ein $a^{-1} \\in B$ mit\n     - $a \\bullet a^{-1} = n$\n     - $a \\circ a^{-1} = e$\n\n---\n\n## Schaltalgebra (konkrete Boolesche Algebra)\n\n### Korrespondenz\n\n| Boolesche Algebra | Schaltalgebra |\n|-------------------|---------------|\n| $B$               | $\\{0,1\\}$     |\n| $\\bullet$         | $\\land$ (UND) |\n| $\\circ$           | $\\lor$ (ODER) |\n| $n$               | $0$           |\n| $e$               | $1$           |\n| $a^{-1}$          | $\\lnot a$     |\n\nDamit ist $(\\{0,1\\}, \\land, \\lor)$ mit der Negation $\\lnot$ eine Boolesche Algebra.\n\n### Grundoperationen\n\n1. **Konjunktion (UND)**: $a \\land b$\n\n   | $a$ | $b$ | $a \\land b$ |\n   |-----|-----|-------------|\n   | 0   | 0   | 0           |\n   | 0   | 1   | 0           |\n   | 1   | 0   | 0           |\n   | 1   | 1   | 1           |\n\n2. **Disjunktion (ODER)**: $a \\lor b$\n\n   | $a$ | $b$ | $a \\lor b$ |\n   |-----|-----|------------|\n   | 0   | 0   | 0          |\n   | 0   | 1   | 1          |\n   | 1   | 0   | 1          |\n   | 1   | 1   | 1          |\n\n3. **Negation (NICHT)**: $\\lnot a$\n\n   | $a$ | $\\lnot a$ |\n   |-----|-----------|\n   | 0   | 1         |\n   | 1   | 0         |\n\n### Huntingtonsche Axiome in der Schaltalgebra\n\n1. **Kommutativität**\n   - $a \\land b = b \\land a$\n   - $a \\lor b = b \\lor a$\n\n2. **Distributivität**\n   - $a \\land (b \\lor c) = (a \\land b) \\lor (a \\land c)$\n   - $a \\lor (b \\land c) = (a \\lor b) \\land (a \\lor c)$\n\n3. **Neutrale Elemente**\n   - $a \\land 1 = a$\n   - $a \\lor 0 = a$\n\n4. **Inversion**\n   - $a \\land \\lnot a = 0$\n   - $a \\lor \\lnot a = 1$\n\n---\n\n## Boolesche Funktionen\n\n### Definition\n\n*Eine boolesche Funktion* ist eine Abbildung\n$$\ny = f(x_1, x_2, \\dots, x_n), \\quad x_i \\in \\{0,1\\}\n$$\n\n- $n$ = *Stelligkeit* der Funktion\n- $x_1, \\dots, x_n$ = *freie Variablen*\n- $y$ = *abhängige Variable*\n\n**Beispiele:**\n\n- Negation: $y = \\lnot x_1$ (Stelligkeit $1$)\n- Konjunktion: $y = x_1 \\land x_2$ (Stelligkeit $2$)\n- Disjunktion: $y = x_1 \\lor x_2$ (Stelligkeit $2$)\n\n### Anzahl möglicher boolescher Funktionen\n\n- Für $n$ Eingangsvariablen gibt es $2^n$ mögliche Belegungen.\n- Für jede Belegung kann der Funktionswert $0$ oder $1$ sein.\n- **Anzahl boolescher Funktionen**:\n  $$\n  \\text{Anzahl} = 2^{2^n}\n  $$\n- Für $n = 2$:\n  $$\n  2^{2^2} = 2^4 = 16\n  $$\n  → Es gibt 16 verschiedene boolesche Funktionen zweier Variablen.\n\n---\n\n## Boolesche Ausdrücke und Nicht-Eindeutigkeit\n\n- Eine boolesche Funktion kann durch viele verschiedene Ausdrücke beschrieben werden.\n- Beispiel: **XOR** (Antivalenz) mit $y = x_1 \\oplus x_2$:\n\n  - $$y = (\\lnot x_1 \\land x_2) \\lor (x_1 \\land \\lnot x_2)$$\n  - $$y = (x_1 \\lor x_2) \\land \\lnot (x_1 \\land x_2)$$\n\nDiese Ausdrücke sind äquivalent, beschreiben aber dieselbe Funktion.\n\n---\n\n## Axiome und wichtige Theoreme der Booleschen Algebra\n\n### Grundaxiome (in Schaltalgebra-Notation)\n\n1. **Identität (neutrale Elemente)**\n   - $a \\land 1 = a$\n   - $a \\lor 0 = a$\n\n2. **Elimination**\n   - $a \\land 0 = 0$\n   - $a \\lor 1 = 1$\n\n3. **Idempotenz**\n   - $a \\land a = a$\n   - $a \\lor a = a$\n\n4. **Involution**\n   - $\\lnot (\\lnot a) = a$\n\n5. **Inversion / Komplement**\n   - $a \\land \\lnot a = 0$\n   - $a \\lor \\lnot a = 1$\n\n6. **Kommutativität**\n   - $a \\land b = b \\land a$\n   - $a \\lor b = b \\lor a$\n\n7. **Assoziativität**\n   - $(a \\land b) \\land c = a \\land (b \\land c)$\n   - $(a \\lor b) \\lor c = a \\lor (b \\lor c)$\n\n8. **Distributivität**\n   - $a \\land (b \\lor c) = (a \\land b) \\lor (a \\land c)$\n   - $a \\lor (b \\land c) = (a \\lor b) \\land (a \\lor c)$\n\n### Wichtige Theoreme\n\n9. **Vereinigung**\n   - $(a \\lor b) \\land (a \\lor \\lnot b) = a$\n   - $(a \\land b) \\lor (a \\land \\lnot b) = a$\n\n10. **Absorption**\n    - $a \\land (a \\lor b) = a$\n    - $a \\lor (a \\land b) = a$\n\n11. **Absorption 2**\n    - $(a \\land \\lnot b) \\lor b = a \\lor b$\n    - $(a \\lor \\lnot b) \\land b = a \\land b$\n\n12. **Faktorisierung**\n    - $(a \\lor b) \\land (\\lnot a \\lor c) = (a \\land c) \\lor (\\lnot a \\land b)$\n    - $(a \\land b) \\lor (\\lnot a \\land c) = (a \\lor c) \\land (\\lnot a \\lor b)$\n\n13. **Konsens**\n    - $(a \\lor b) \\land (b \\lor c) \\land (\\lnot a \\lor c) = (a \\lor b) \\land (\\lnot a \\lor c)$\n    - $(a \\land b) \\lor (b \\land c) \\lor (\\lnot a \\land c) = (a \\land b) \\lor (\\lnot a \\land c)$\n\n14. **De-Morgan-Gesetze**\n    - $$\\lnot (a \\land b \\land \\dots) = \\lnot a \\lor \\lnot b \\lor \\dots$$\n    - $$\\lnot (a \\lor b \\lor \\dots) = \\lnot a \\land \\lnot b \\land \\dots$$\n\n---\n\n## De-Morgan-Gesetze (einfacher Fall)\n\n1. $$\\lnot (a \\land b) = \\lnot a \\lor \\lnot b$$\n2. $$\\lnot (a \\lor b) = \\lnot a \\land \\lnot b$$\n\n**Wahrheitstafel-Beispiel für $\\lnot(a \\land b) = \\lnot a \\lor \\lnot b$:**\n\n| $a$ | $b$ | $a \\land b$ | $\\lnot(a \\land b)$ | $\\lnot a$ | $\\lnot b$ | $\\lnot a \\lor \\lnot b$ |\n|-----|-----|-------------|--------------------|-----------|-----------|-------------------------|\n| 0   | 0   | 0           | 1                  | 1         | 1         | 1                       |\n| 0   | 1   | 0           | 1                  | 1         | 0         | 1                       |\n| 1   | 0   | 0           | 1                  | 0         | 1         | 1                       |\n| 1   | 1   | 1           | 0                  | 0         | 0         | 0                       |\n\nSpalten $\\lnot(a \\land b)$ und $\\lnot a \\lor \\lnot b$ sind identisch → Gleichheit bewiesen.\n\n---\n\n## Weitere logische Operatoren\n\n### Implikation und inverse Implikation\n\n- **Implikation**: $a \\to b$\n  $$\n  a \\to b = \\lnot a \\lor b\n  $$\n- **Inverse Implikation**: $a \\leftarrow b$\n  $$\n  a \\leftarrow b = \\lnot b \\lor a\n  $$\n\n### Äquivalenz und Antivalenz\n\n- **Äquivalenz**: $a \\leftrightarrow b$\n  $$\n  a \\leftrightarrow b = (\\lnot a \\land \\lnot b) \\lor (a \\land b)\n  $$\n  Wahr, wenn $a$ und $b$ den gleichen Wert haben.\n\n- **Antivalenz (XOR)**: $a \\leftrightarrow\\!\\!\\!\\!\\!\\! / \\; b$ (oft $a \\oplus b$)\n  $$\n  a \\oplus b = (\\lnot a \\land b) \\lor (a \\land \\lnot b)\n  $$\n  Wahr, wenn $a$ und $b$ unterschiedliche Werte haben.\n\n### NAND (Sheffer-Funktion) und NOR (Peirce-Funktion)\n\n- **NAND**:\n  $$\n  a \\uparrow b = \\lnot (a \\land b)\n  $$\n- **NOR**:\n  $$\n  a \\downarrow b = \\lnot (a \\lor b)\n  $$\n\n**Wichtig:**  \nDie Operatorensysteme $\\{\\lnot, \\land, \\lor\\}$, nur NAND oder nur NOR sind jeweils *vollständig* → alle booleschen Funktionen lassen sich daraus aufbauen.\n\n---\n\n## Operatoren nach DIN 66000\n\n| Symbol | Name                     | Beispiel          | Sprechweise      |\n|--------|--------------------------|-------------------|------------------|\n| $\\lnot$| Negation (NOT)           | $y = \\lnot a$     | nicht $a$        |\n| $\\land$| Konjunktion (AND)        | $y = a \\land b$   | $a$ und $b$      |\n| $\\lor$ | Disjunktion (OR)         | $y = a \\lor b$    | $a$ oder $b$     |\n| $\\to$  | Implikation              | $y = a \\to b$     | $a$ impliziert $b$ |\n| $\\leftrightarrow$ | Äquivalenz    | $y = a \\leftrightarrow b$ | $a$ äquivalent $b$ |\n| $\\oplus$ | Antivalenz (XOR)      | $y = a \\oplus b$  | $a$ xor $b$      |\n| $\\uparrow$ | NAND                 | $y = a \\uparrow b$| $a$ nand $b$     |\n| $\\downarrow$ | NOR                | $y = a \\downarrow b$| $a$ nor $b$   |\n\n---\n\n## Literale, Monome und DNF-Idee\n\n### Definitionen\n\n- *Literal*: Variable oder negierte Variable  \n  Beispiele: $a$, $b$, $\\lnot c$, $\\lnot x$.\n\n- *Monom*: UND-Verknüpfung von Literalen  \n  Beispiele:\n  - $a \\land b \\land \\lnot c$\n  - $\\lnot f \\land \\lnot e \\land \\lnot d$\n  - $x \\land y \\land \\lnot z$\n\n### Eigenschaft eines Monoms\n\nEin Monom ist genau dann $1$, wenn **alle** seine Literale passend belegt sind:\n\n- jede Variable im Monom: Wert $1$\n- jede negierte Variable im Monom: Wert $0$\n\nBeispiel:  \nMonom $\\lnot x \\land y \\land \\lnot z$ ist nur dann $1$, wenn\n$$\nx = 0,\\quad y = 1,\\quad z = 0\n$$\n\n### ODER von Monomen\n\nEin Ausdruck der Form\n$$\ny = M_1 \\lor M_2 \\lor \\dots \\lor M_k\n$$\nmit Monomen $M_i$ ist genau dann $1$, wenn mindestens ein $M_i$ den Wert $1$ hat.\n\nBeispiel:\n$$\ny = (\\lnot x \\land y \\land \\lnot z) \\lor (x \\land \\lnot y \\land z)\n$$\n\n- $y = 1$ für $(x,y,z) = (0,1,0)$ **oder** $(1,0,1)$\n\nDamit kann jede boolesche Funktion als ODER von Monomen dargestellt werden (Disjunktive Normalform).\n\n---\n\n## Auswertung und Beweise mit Wahrheitstabellen\n\n### Vorrangregeln (DIN)\n\n- Stärkste Bindung: $\\lnot$\n- Mittlere Bindung: $\\land, \\lor, \\uparrow, \\downarrow$\n- Schwächste Bindung: $\\to, \\leftrightarrow, \\oplus$\n- $\\land$ und $\\lor$ werden *linksassoziativ* ausgewertet.\n- Klammern können die Reihenfolge explizit festlegen.\n\n### Beweis durch vollständige Wahrheitstafel\n\nBeispiel: **Vereinigungstheorem**\n$$\n(x \\land y) \\lor (x \\land \\lnot y) = x\n$$\n\n| $x$ | $y$ | $x \\land y$ | $x \\land \\lnot y$ | $(x \\land y) \\lor (x \\land \\lnot y)$ | $x$ |\n|-----|-----|-------------|-------------------|---------------------------------------|----|\n| 0   | 0   | 0           | 0                 | 0                                     | 0  |\n| 0   | 1   | 0           | 0                 | 0                                     | 0  |\n| 1   | 0   | 0           | 1                 | 1                                     | 1  |\n| 1   | 1   | 1           | 0                 | 1                                     | 1  |\n\nSpalten identisch → Gleichheit bewiesen.\n\n---\n\n## Beweis durch Umformung (algebraisch)\n\n### Beispiel 1: Vereinigungstheorem\n\nZu zeigen:\n$$\n(x \\land y) \\lor (x \\land \\lnot y) = x\n$$\n\n**Umformung:**\n1. $ (x \\land y) \\lor (x \\land \\lnot y)$  \n   Anwenden der Distributivität:\n   $$\n   = x \\land (y \\lor \\lnot y)\n   $$\n2. Komplementgesetz $y \\lor \\lnot y = 1$:\n   $$\n   = x \\land 1\n   $$\n3. Identität $x \\land 1 = x$:\n   $$\n   = x\n   $$\n\n### Beispiel 2: Vereinfachung eines Ausdrucks\n\nZu vereinfachen:\n$$\n(x \\oplus y) \\lor (x \\leftrightarrow y)\n$$\n\n1. XOR und Äquivalenz auflösen:\n   $$\n   x \\oplus y = (\\lnot x \\land y) \\lor (x \\land \\lnot y)\n   $$\n   $$\n   x \\leftrightarrow y = (\\lnot x \\land \\lnot y) \\lor (x \\land y)\n   $$\n2. Gesamtausdruck:\n   $$\n   (x \\oplus y) \\lor (x \\leftrightarrow y)\n   = (\\lnot x \\land y) \\lor (x \\land \\lnot y) \\lor (\\lnot x \\land \\lnot y) \\lor (x \\land y)\n   $$\n3. Gruppieren (Kommutativität, Assoziativität):\n   $$\n   = [(\\lnot x \\land y) \\lor (\\lnot x \\land \\lnot y)] \\lor [(x \\land \\lnot y) \\lor (x \\land y)]\n   $$\n4. Distributivität:\n   $$\n   = \\lnot x \\land (y \\lor \\lnot y) \\;\\; \\lor \\;\\; x \\land (\\lnot y \\lor y)\n   $$\n5. Komplementgesetze $y \\lor \\lnot y = 1$:\n   $$\n   = \\lnot x \\land 1 \\;\\; \\lor \\;\\; x \\land 1\n   $$\n6. Identität $a \\land 1 = a$:\n   $$\n   = \\lnot x \\lor x\n   $$\n7. Komplementgesetz:\n   $$\n   = 1\n   $$\n\n**Ergebnis:** Der Ausdruck $(x \\oplus y) \\lor (x \\leftrightarrow y)$ ist immer $1$ (allgemeingültig).\n\n---\n\n## Tipps zur Vereinfachung boolescher Ausdrücke\n\n- Von *innen nach außen* (innerste Klammern zuerst) vereinfachen.\n- Klammerpaare ggf. farblich/visuell markieren.\n- Reihenfolge der zu prüfenden Regeln:\n  1. **Absorption**\n  2. **Absorption 2**\n  3. **Vereinigung**\n  4. **Distributivität** erst einsetzen, wenn keine andere Vereinfachung möglich ist (Distributivität verlängert Ausdrücke oft zunächst).\n\n---\n\n## Beispiel: Schaltkreis und Formel\n\nGegeben sei die Wahrheitstafel (XOR):\n\n| $s_1$ | $s_2$ | $l$ |\n|-------|-------|-----|\n| 0     | 0     | 0   |\n| 0     | 1     | 1   |\n| 1     | 0     | 1   |\n| 1     | 1     | 0   |\n\n**Zu bestimmender Schaltkreis / Ausdruck:**\n\n- Lampe $l$ leuchtet genau dann, wenn *genau einer* der Schalter geschlossen ist:\n  $$\n  l = ( \\lnot s_1 \\land s_2 ) \\lor ( s_1 \\land \\lnot s_2 )\n  $$\n\n**Interpretation als Schaltung:**\n\n- Zwei UND-Gatter:\n  - Eingang 1: $\\lnot s_1$ und $s_2$\n  - Eingang 2: $s_1$ und $\\lnot s_2$\n- Ausgänge der UND-Gatter in ein ODER-Gatter führen.\n\n---\n\n## Merksätze\n\n- **Nur zwei Werte**: Boolesche Algebra arbeitet ausschließlich mit $0$ und $1$.\n- **Vollständiges Operatorensystem**: $\\{\\lnot, \\land, \\lor\\}$ reicht aus, um jede boolesche Funktion darzustellen.\n- **Anzahl Funktionen**: Für $n$ Variablen gibt es $2^{2^n}$ boolesche Funktionen.\n- **De-Morgan**: Negation verteilt sich über $\\land$ und $\\lor$, dabei werden sie vertauscht.\n- **NAND und NOR** sind jeweils allein schon funktional vollständig.\n- **Vereinfachen**: Immer zuerst Absorptions- und Komplementgesetze prüfen, Distributivität zuletzt.\n- **Monome + ODER**: Jede boolesche Funktion lässt sich als ODER von Monomen schreiben (Disjunktive Normalform).",
    "generatedAt": "2025-12-05T17:41:53.902Z"
  },
  {
    "id": "1764956607140-jf80zo42y",
    "scriptId": "1764951100473-0ckey5ykb",
    "moduleId": "1764928329062-tl6e8rrrf",
    "content": "# Darstellung von Zahlen und Zeichen in der Informatik\n\nKurze Übersicht: Es geht um Zahlensysteme, Umwandlungen, Computerzahlen (Ganz- und Gleitkommazahlen) sowie die Codierung von Zeichen (ASCII, ISO 8859, Unicode, UTF).\n\n---\n\n## Zahlensysteme und einfache Zahlendarstellungen\n\n### Strichsysteme und Grundidee von Zahlen\n\n- *Kardinalzahlen*: *Zahlen zum Zählen*, z.B. „23 Kühe“.\n- *Ordinalzahlen*: *Zahlen zur Ordnung*, z.B. „1., 2., 3.“.\n- **Strichsysteme**: Darstellung durch Wiederholung eines Zeichens (|||||).\n  - Praktisch nur für kleine Zahlen.\n  - Addition ergibt sich natürlich durch Zusammenlegen der Striche.\n\n---\n\n## Römisches Zahlensystem\n\n### Symbole und Werte\n\n| Symbol | Wert |\n|--------|------|\n| I      | 1    |\n| V      | 5    |\n| X      | 10   |\n| L      | 50   |\n| C      | 100  |\n| D      | 500  |\n| M      | 1000 |\n\n### Regeln\n\n- **Wiederholung**:\n  - I, X, C: höchstens dreimal hintereinander.\n  - M: beliebig oft.\n  - V, L, D: dürfen nicht wiederholt werden.\n- **Addition**:\n  - Gleiche Symbole nebeneinander werden addiert: z.B. III = $1+1+1=3$.\n  - Kleineres Symbol rechts vom größeren: Werte werden addiert.\n    - VI = $5+1=6$.\n- **Subtraktion**:\n  - Kleineres Symbol links vom größeren: Werte werden subtrahiert.\n    - IV = $5-1=4$, IX = $10-1=9$.\n  - I darf nur vor V und X stehen.\n  - X darf nur vor L und C stehen.\n  - C darf nur vor D und M stehen.\n\n**Beispiel:**\n- XXXIX $= 30 + (10-1) = 39$\n- DCCC $= 500 + 300 = 800$\n\n**Merksatz:**  \n**Römische Zahlen** sind ein **Additions-/Subtraktionssystem**, kein Stellenwertsystem.\n\n---\n\n## Stellenwertsysteme (b-adische Darstellung)\n\n### Allgemeine Darstellung\n\nEine Zahl $Z$ zur Basis $b$ mit Ziffern $a_i \\in \\{0,1,\\dots,b-1\\}$:\n\n$$\nZ = a_n b^n + a_{n-1} b^{n-1} + \\dots + a_1 b^1 + a_0 b^0\n$$\n\n- **Dezimalsystem**: Basis $b = 10$, Ziffern $0,\\dots,9$.\n- Jede Stelle hat einen **Stellenwert** $b^k$.\n\n**Beispiel (Dezimal):**  \nZahl $156309$:\n$$\n156309 = 1\\cdot 10^5 + 5\\cdot 10^4 + 6\\cdot 10^3 + 3\\cdot 10^2 + 0\\cdot 10^1 + 9\\cdot 10^0\n$$\n\n### Wichtige Basen in der Informatik\n\n- **Dualsystem** (Binär): $b=2$, $a_i\\in\\{0,1\\}$.\n- **Oktalsystem**: $b=8$, $a_i\\in\\{0,\\dots,7\\}$.\n- **Hexadezimalsystem**: $b=16$, $a_i\\in\\{0,\\dots,9,\\text{A},\\dots,\\text{F}\\}$.\n\n---\n\n## Dualzahlen (Binärzahlen)\n\n### Bedeutung in der Informatik\n\n- Basis $b=2$ mit Symbolen 0 und 1.\n- Physikalische Umsetzung:\n  - 0: „kein Strom“\n  - 1: „Strom fließt“\n- **Bit**: eine Binärstelle.\n- **Byte**: $8$ Bit.\n\n### Beispiel: Binär nach Dezimal\n\nZahl $(01001101)_2$:\n\n$$\n(01001101)_2 = 0\\cdot 2^7 + 1\\cdot 2^6 + 0\\cdot 2^5 + 0\\cdot 2^4 + 1\\cdot 2^3 + 1\\cdot 2^2 + 0\\cdot 2^1 + 1\\cdot 2^0\n$$\n$$\n= 0 + 64 + 0 + 0 + 8 + 4 + 0 + 1 = 77 = (77)_{10}\n$$\n\n---\n\n## Zweierpotenzen\n\nWichtige Potenzen von $2$:\n\n| $2^n$ | Wert  | $2^n$ | Wert   |\n|-------|-------|-------|--------|\n| $2^0$ | 1     | $2^8$ | 256    |\n| $2^1$ | 2     | $2^9$ | 512    |\n| $2^2$ | 4     | $2^{10}$ | 1024 |\n| $2^3$ | 8     | $2^{11}$ | 2048 |\n| $2^4$ | 16    | $2^{12}$ | 4096 |\n| $2^5$ | 32    | $2^{13}$ | 8192 |\n| $2^6$ | 64    | $2^{14}$ | 16384 |\n| $2^7$ | 128   | $2^{15}$ | 32768 |\n\n**Merksatz:**  \nDie ersten **10 Zweierpotenzen** ($2^0$ bis $2^9$) sollte man **auswendig** kennen.\n\n---\n\n## Oktal- und Hexadezimalzahlen\n\n### Umrechnung nach Dezimal\n\n- Oktal $(115)_8$:\n  $$\n  (115)_8 = 1\\cdot 8^2 + 1\\cdot 8^1 + 5\\cdot 8^0 = 64 + 8 + 5 = 77\n  $$\n- Hexadezimal $(4D)_{16}$:\n  $$\n  (4D)_{16} = 4\\cdot 16^1 + 13\\cdot 16^0 = 64 + 13 = 77\n  $$\n\n### Zusammenhang mit Binärzahlen\n\nJede Hexadezimalziffer entspricht **4 Bits**, jede Oktalziffer **3 Bits**.\n\n| Dezimal | Hex | Oktal | Binär  |\n|---------|-----|-------|--------|\n| 0       | 0   | 0     | 0000   |\n| 1       | 1   | 1     | 0001   |\n| 2       | 2   | 2     | 0010   |\n| 3       | 3   | 3     | 0011   |\n| 4       | 4   | 4     | 0100   |\n| 5       | 5   | 5     | 0101   |\n| 6       | 6   | 6     | 0110   |\n| 7       | 7   | 7     | 0111   |\n| 8       | 8   | 10    | 1000   |\n| 9       | 9   | 11    | 1001   |\n| 10      | A   | 12    | 1010   |\n| 11      | B   | 13    | 1011   |\n| 12      | C   | 14    | 1100   |\n| 13      | D   | 15    | 1101   |\n| 14      | E   | 16    | 1110   |\n| 15      | F   | 17    | 1111   |\n\n**Merksatz:**  \n- **4 Bit = 1 Hex-Ziffer**  \n- **3 Bit = 1 Oktal-Ziffer**\n\n---\n\n## Rationale Zahlen in b-adischer Darstellung\n\n### Allgemeine Form\n\nFür Basis $b$:\n\n$$\nZ = \\sum_{i=m}^{n} a_i b^i = a_n b^n + \\dots + a_1 b^1 + a_0 b^0 + a_{-1} b^{-1} + a_{-2} b^{-2} + \\dots\n$$\n\n- Vorkommastellen: Exponenten $i \\ge 0$.\n- Nachkommastellen: Exponenten $i < 0$.\n\n### Beispiel Dezimal\n\n$$\n913{,}64 = 9\\cdot 10^2 + 1\\cdot 10^1 + 3\\cdot 10^0 + 6\\cdot 10^{-1} + 4\\cdot 10^{-2}\n$$\n\n### Beispiel Binär\n\n$$\n(11{,}101)_2 = 1\\cdot 2^1 + 1\\cdot 2^0 + 1\\cdot 2^{-1} + 0\\cdot 2^{-2} + 1\\cdot 2^{-3}\n$$\n$$\n= 2 + 1 + 0{,}5 + 0 + 0{,}125 = 3{,}625 = (3{,}625)_{10}\n$$\n\n**Merksatz:**  \nNachkommastellen verwenden **negative Exponenten** der Basis.\n\n---\n\n## Dezimalpräfixe und Zweierpotenzen\n\n### Zehnerpräfixe\n\n| Potenz | Präfix | Symbol |\n|--------|--------|--------|\n| $10^3$ | Kilo   | k      |\n| $10^6$ | Mega   | M      |\n| $10^9$ | Giga   | G      |\n| $10^{12}$ | Tera | T    |\n| $10^{15}$ | Peta | P    |\n| $10^{18}$ | Exa  | E    |\n| $10^{21}$ | Zetta | Z   |\n| $10^{24}$ | Yotta | Y   |\n\nAnalog negative Potenzen (Milli, Mikro, Nano, ...).\n\n### Zweierpotenzen und Präfixe\n\n| Zweierpotenz | „Binäres“ Präfix | Wert (ungefähr)       |\n|--------------|------------------|------------------------|\n| $2^{10}$     | 1 K              | $\\approx 10^3$        |\n| $2^{20}$     | 1 M              | $\\approx 10^6$        |\n| $2^{30}$     | 1 G              | $\\approx 10^9$        |\n\n**Merksatz:**  \nIn der Informatik sind **$2^{10}\\approx 10^3$**, **$2^{20}\\approx 10^6$**, **$2^{30}\\approx 10^9$** wichtige Näherungen.\n\n---\n\n## Umwandlung zwischen Zahlensystemen\n\n### Horner-Schema: Zahl zur Basis $b$ nach Dezimal\n\nAllgemeine Darstellung:\n\n$$\nn = (\\dots(((a_n b + a_{n-1})b + a_{n-2})b + \\dots + a_1)b + a_0\n$$\n\n- Berechnung durch **iteratives Multiplizieren und Addieren**.\n\n### Algorithmus: Dezimal nach Basis $b$ (Ganzzahlen)\n\nGegeben $x_{10}$, gesucht Darstellung zur Basis $b$:\n\n1. Teile: $x / b = y$ Rest $z$.\n2. Setze $x := y$.\n3. Wiederhole, bis $x = 0$.\n4. Die **Reste in umgekehrter Reihenfolge** sind die Ziffern zur Basis $b$.\n\n### Beispiel: Dezimal $\\rightarrow$ Hexadezimal\n\n$23521_{10}$ nach Basis $b=16$:\n\n- $23521 / 16 = 1470$ Rest $1$\n- $1470 / 16 = 91$ Rest $14 = \\text{E}$\n- $91 / 16 = 5$ Rest $11 = \\text{B}$\n- $5 / 16 = 0$ Rest $5$\n\nZahl: $(5\\text{BE}1)_{16}$.\n\n### Beispiel: Dezimal $\\rightarrow$ Binär\n\n$6485_{10}$:\n\n- Folge von Divisionen durch $2$, Reste von unten nach oben:\n- Ergebnis: $(1100101010101)_2$.\n\n---\n\n## Umwandlung rationaler Zahlen\n\n### Vorgehen\n\n- **Vorkommateil**: wie bei Ganzzahlen (Division durch Basis).\n- **Nachkommateil** $x$ (mit $0 \\le x < 1$):\n\nAlgorithmus für Basis $b$:\n\n1. $x \\cdot b = y$ mit ganzzahligem Überlauf $z = \\lfloor y \\rfloor$.\n2. Neuer Nachkommaanteil: $x := y - z$.\n3. Wiederholen, bis $x=0$ oder genügend Stellen.\n4. Die Überläufe $z$ in **Berechnungsreihenfolge** sind die Nachkommastellen.\n\n### Beispiel: $0{,}6875_{10}$ nach Binär\n\n- $0{,}6875\\cdot 2 = 1{,}375 \\Rightarrow z_1 = 1$, $x=0{,}375$\n- $0{,}375\\cdot 2 = 0{,}75 \\Rightarrow z_2 = 0$, $x=0{,}75$\n- $0{,}75\\cdot 2 = 1{,}5 \\Rightarrow z_3 = 1$, $x=0{,}5$\n- $0{,}5\\cdot 2 = 1{,}0 \\Rightarrow z_4 = 1$, $x=0$\n\nErgebnis:\n$$\n(0{,}6875)_{10} = (0{,}1011)_2\n$$\n\n### Beispiel: $0{,}1_{10}$ nach Binär (periodisch)\n\n- $0{,}1\\cdot 2 = 0{,}2$\n- $0{,}2\\cdot 2 = 0{,}4$\n- $0{,}4\\cdot 2 = 0{,}8$\n- $0{,}8\\cdot 2 = 1{,}6$\n- $0{,}6\\cdot 2 = 1{,}2$\n- $0{,}2\\cdot 2 = 0{,}4$ (Periode beginnt)\n\n**Merksatz:**  \nViele **endliche Dezimalbrüche** werden im Binärsystem **periodisch**, z.B. $0{,}1_{10}$.\n\n---\n\n## Computerzahlen: Ganzzahlen\n\n### Feste Bitanzahl\n\n- Computer verwenden eine **feste Anzahl von Bits**.\n- Folge:\n  - **Begrenzter Wertebereich**.\n  - **Begrenzte Genauigkeit**.\n\n### Vorzeichenlose ganze Zahlen\n\n| Bytes | Bits | Wertebereich                     | C#-Typ  |\n|-------|------|----------------------------------|---------|\n| 1     | 8    | $[0; 255]$                      | `byte`  |\n| 2     | 16   | $[0; 65535]$                    | `ushort`|\n| 4     | 32   | $[0; 4294967295]$               | `uint`  |\n| 8     | 64   | $[0; 18446744073709551615]$     | `ulong` |\n\n**Merksatz:**  \nVorzeichenlose $n$-Bit-Zahl: Wertebereich $[0; 2^n - 1]$.\n\n---\n\n## Speicherordnung: Big-Endian vs. Little-Endian\n\n- **Endianness**: Reihenfolge, in der Bytes im Speicher abgelegt werden.\n\n- **Little-Endian**:\n  - Niedrigstwertiges Byte zuerst.\n  - x86-Architekturen (Intel, AMD).\n\n- **Big-Endian**:\n  - Höchstwertiges Byte zuerst.\n  - z.B. MIPS, SPARC, PowerPC, Java VM.\n\n**Merksatz:**  \nLittle-Endian: „kleines Ende zuerst“; Big-Endian: „großes Ende zuerst“.\n\n---\n\n## Addition von Dualzahlen\n\n### Grundregeln\n\n- $0 + 0 = 0$\n- $0 + 1 = 1$\n- $1 + 0 = 1$\n- $1 + 1 = 0$ mit Übertrag $1$\n- $1 + 1 + 1 = 1$ mit Übertrag $1$\n\n### Beispiel\n\n$$\n0101_2 = 5,\\quad 0110_2 = 6\n$$\n\nAddition:\n\n\\[\n\\begin{aligned}\n&0101 \\\\\n+&0110 \\\\\n\\hline\n&11011 \\quad (\\text{mit Übertrag}) \\\\\n\\end{aligned}\n\\]\n\nErgebnis (ohne Übertrag in fester Bitbreite) z.B. $99$ im Beispiel der Folie.\n\n### Überlauf\n\n- **Überlauf** tritt auf, wenn das Ergebnis **nicht** in die gegebene Bitanzahl passt.\n- Beispiel (4 Bit):\n\n$$\n1011_2 = 11,\\quad 0110_2 = 6\n$$\n$$\n1011_2 + 0110_2 = 1\\,0001_2\n$$\n\n- Die fünfte Stelle ist Überlauf → nicht darstellbar mit 4 Bit.\n\n**Merksatz:**  \nÜberlauf = Ergebnis außerhalb des **darstellbaren Zahlenbereichs**.\n\n---\n\n## Vorzeichenbehaftete ganze Zahlen\n\n### Varianten\n\n- **Betrags-Vorzeichendarstellung**\n- **Einerkomplement**\n- **Zweierkomplement** (in der Praxis Standard)\n\nBewertungskriterien:\n- *Symmetrie* des Wertebereichs.\n- *Eindeutigkeit* (jede Zahl genau ein Bitmuster).\n- *Arithmetik* (einfache Implementierung von +, −).\n\n---\n\n### Betrags-Vorzeichendarstellung\n\n- Höchstwertiges Bit = **Vorzeichenbit**:\n  - $0$: positiv\n  - $1$: negativ\n- Restliche Bits = Betrag.\n\n**Wertebereich (n Bit):**\n$$\n[-(2^{n-1}-1);\\; +(2^{n-1}-1)]\n$$\n\n**Problem 1: Arithmetik**\n\n- Normale Addition funktioniert nicht direkt, Vorzeichen muss gesondert behandelt werden.\n\n**Problem 2: Nicht-eindeutig**\n\n- Null ist doppelt:\n  - $+0 = 0000\\dots0$\n  - $-0 = 1000\\dots0$\n\n**Merksatz:**  \nBetrags-Vorzeichen ist **symmetrisch**, aber **nicht eindeutig** und arithmetisch unhandlich.\n\n---\n\n### Einerkomplement\n\n- Negative Zahl = **bitweises Komplement** der positiven Darstellung.\n\nBeispiel (4 Bit):\n- $+5 = 0101$\n- $-5 = 1010$ (alle Bits invertiert)\n\n**Wertebereich (n Bit):**\n$$\n[-(2^{n-1}-1);\\; +(2^{n-1}-1)]\n$$\n\n**Eigenschaften:**\n\n- Symmetrischer Bereich.\n- **Nicht eindeutig**:\n  - $+0 = 0000$, $-0 = 1111$.\n- Addition:\n  1. Normale Binäraddition.\n  2. Falls Überlauf (Carry aus MSB), diesen **zum Ergebnis addieren** (Übertragsaddition).\n\n**Merksatz:**  \nEinerkomplement: einfache Negation (Bit-Invertierung), aber **doppelte Null** und **Übertragsaddition** nötig.\n\n---\n\n### Zweierkomplement\n\n- Bildung einer negativen Zahl $-x$:\n  1. Einerkomplement von $x$ bilden.\n  2. $1$ addieren.\n\nFormel:\n$$\n-x = \\overline{x} + 1\n$$\n(wobei $\\overline{x}$ das Bitkomplement ist)\n\n**Wertebereich (n Bit):**\n$$\n[-2^{n-1};\\; +(2^{n-1}-1)]\n$$\n\nBeispiel (4 Bit):\n\n| Dezimal | Binär (Zweierkomplement) |\n|---------|---------------------------|\n| 0       | 0000                      |\n| 1       | 0001                      |\n| 2       | 0010                      |\n| 3       | 0011                      |\n| 4       | 0100                      |\n| 5       | 0101                      |\n| 6       | 0110                      |\n| 7       | 0111                      |\n| -1      | 1111                      |\n| -2      | 1110                      |\n| -3      | 1101                      |\n| -4      | 1100                      |\n| -5      | 1011                      |\n| -6      | 1010                      |\n| -7      | 1001                      |\n| -8      | 1000                      |\n\n**Eigenschaften:**\n\n- **Eindeutig**: Null nur einmal.\n- Normale Binäraddition kann verwendet werden.\n- Subtraktion: $a-b = a + (-b)$.\n\n**Überlaufbedingung:**\n\n- Überlauf, wenn Ergebnis **außerhalb** des Bereichs $[-2^{n-1};2^{n-1}-1]$ liegt.\n- Typisch: Addition zweier positiver Zahlen ergibt negatives Bitmuster oder umgekehrt.\n\n**Inverse-Eigenschaft:**\n\nZweimaliges Anwenden des Zweierkomplements liefert wieder die Ausgangszahl:\n$$\nx \\xrightarrow{\\text{2er-Komplement}} -x \\xrightarrow{\\text{2er-Komplement}} x\n$$\n\n**Merksatz:**  \nZweierkomplement ist **Standarddarstellung** für vorzeichenbehaftete Ganzzahlen.\n\n---\n\n### Java-Typen mit Zweierkomplement\n\n| Bytes | Bits | Wertebereich                          | Typ   |\n|-------|------|---------------------------------------|-------|\n| 1     | 8    | $[-128;127]$                         | `byte`|\n| 2     | 16   | $[-32768;32767]$                     | `short`|\n| 4     | 32   | $[-2147483648;2147483647]$           | `int` |\n| 8     | 64   | $[-9223372036854775808;9223372036854775807]$ | `long` |\n\n---\n\n## Vorzeichenbehaftete rationale Zahlen\n\nZwei wichtige Darstellungen:\n\n- **Festkommazahlen**\n- **Gleitkommazahlen** (Floating Point, IEEE 754)\n\n---\n\n## Festkommazahlen\n\n### Aufbau\n\n- Ein Bit: Vorzeichen $s$.\n- $n-1$ Bits: Mantisse (Betrag).\n- Aufteilung:\n  - $k$ Bits für Vorkommastellen.\n  - $j = (n-1)-k$ Bits für Nachkommastellen.\n\nDarstellung (ohne Vorzeichenbit):\n\n$$\nW = \\sum_{i=0}^{k-1} a_i 2^i + \\sum_{i=1}^{j} b_i 2^{-i}\n$$\n\n### Eigenschaften\n\n- **Äquidistantes Zahlenformat**: Abstand zwischen zwei darstellbaren Zahlen ist konstant (z.B. $2^{-j}$).\n- Guter **fester Genauigkeitsbereich**, z.B. in:\n  - Digitaler Signalverarbeitung.\n  - Finanz-/Buchhaltungssoftware.\n\n- Nachteil:\n  - Nur begrenzter Ausschnitt der reellen Zahlen.\n  - Viele Zahlen (z.B. $\\pi$, $\\tfrac{1}{3}$) nicht exakt darstellbar → Rundungsfehler.\n\n**Merksatz:**  \nFestkomma: **konstante Schrittweite**, aber **begrenzter Wertebereich**.\n\n---\n\n## Gleitkommazahlen\n\n### Motivation\n\n- Zahlen sehr unterschiedlicher Größenordnung:\n  - Lichtgeschwindigkeit: $\\approx 2{,}998 \\cdot 10^8\\ \\text{m/s}$.\n  - Elektronenmasse: $\\approx 9{,}11\\cdot 10^{-31}\\ \\text{kg}$.\n- Wissenschaftliche Schreibweise:\n  $$\n  x = m \\cdot 10^e\n  $$\n  mit **Mantisse** $m$ und **Exponent** $e$.\n\n### Binäre Gleitkommadarstellung\n\nAnalog:\n$$\nx = m \\cdot 2^e\n$$\n\nTypischer Aufbau (Beispiel $n=16$):\n\n- 1 Bit: Vorzeichen $s$.\n- 5 Bit: Exponent (bzw. Charakteristik $c$).\n- 10 Bit: Mantisse $m$.\n\n### Charakteristik\n\nUm negative Exponenten darzustellen:\n\n- Statt $e$ wird **Charakteristik** $c$ gespeichert:\n  $$\n  c = e + k\n  $$\n- $k$ ist die Konstante, meist:\n  - Für Bereich $[-15;16]$ gilt $k = 15$.\n\nRückrechnung:\n$$\ne = c - k\n$$\n\n### Normalisierung\n\nProblem: Dieselbe Zahl kann mit verschiedenen Kombinationen von Mantisse und Exponent dargestellt werden.\n\n**Lösung: Normalisierung**\n\n- **Vorkommanormalisierung** (üblich in IEEE 754):\n  - Mantisse so skalieren, dass **erste Vorkommastelle** ungleich $0$ ist:\n    $$\n    x = \\pm 1{,}\\text{(Binärbruch)} \\cdot 2^e\n    $$\n- **Nachkommanormalisierung**:\n  - Erste Nachkommastelle ungleich $0$.\n\nDurch Normalisierung wird Darstellung **eindeutig** (bis auf Rundung).\n\n---\n\n## IEEE 754 Gleitkommazahlen\n\n### Grundstruktur (vereinfacht)\n\n- **Single Precision (float, 32 Bit)**:\n  - 1 Bit: Vorzeichen $s$.\n  - 8 Bit: Exponent (Charakteristik $c$).\n  - 23 Bit: Mantisse $m$.\n- **Double Precision (double, 64 Bit)**:\n  - 1 Bit: Vorzeichen $s$.\n  - 11 Bit: Exponent.\n  - 52 Bit: Mantisse.\n\n**Wertebereich (ungefähr):**\n\n| Typ   | Bits | Wertebereich                               |\n|-------|------|--------------------------------------------|\n| float | 32   | $\\pm 1{,}4\\cdot 10^{-45}$ bis $\\pm 3{,}4\\cdot 10^{38}$ |\n| double| 64   | $\\pm 4{,}9\\cdot 10^{-324}$ bis $\\pm 1{,}8\\cdot 10^{308}$ |\n\n### Spezielle Exponenten (Charakteristik $c$)\n\n| $c$              | Mantisse $m$ | Bedeutung (32 Bit)                      |\n|------------------|--------------|-----------------------------------------|\n| $c = 0$          | $m=0$        | $\\pm 0$                                 |\n| $c = 0$          | $m\\neq 0$    | Denormalisierte Zahlen                  |\n| $c = 255$ (alle 1) | $m=0$      | $\\pm \\infty$                            |\n| $c = 255$        | $m\\neq 0$    | NaN (*Not a Number*)                   |\n| sonst            | beliebig     | Normale Zahl: $(−1)^s \\cdot 1{,}m \\cdot 2^{c-\\text{Bias}}$ |\n\n(Bias z.B. $127$ bei float, $1023$ bei double.)\n\n### Textnotation\n\n- Schreibweise: `52.21e-2` oder `52.21E-2`\n  - Bedeutet: $52{,}21 \\cdot 10^{-2}$.\n\n**Merksätze:**\n\n- IEEE 754 ist der **Standard** für Gleitkommazahlen.\n- **float** und **double** sind die üblichen Typen.\n- Es gibt **Sonderwerte**: $\\pm 0$, $\\pm \\infty$, NaN.\n\n---\n\n## Codierung von Zeichen\n\n### Grundidee\n\n- Jedes Zeichen wird als **Binärmuster** gespeichert.\n- Mit $n$ Bits sind $2^n$ verschiedene Zeichen möglich.\n\nBeispiele:\n- 7 Bit: $2^7 = 128$ Zeichen (ASCII).\n- 8 Bit: $2^8 = 256$ Zeichen (ISO 8859).\n- 16 Bit: $2^{16} = 65536$ Zeichen (Unicode BMP).\n\n---\n\n## ASCII\n\n- *American Standard Code for Information Interchange*.\n- 7-Bit-Codierung (128 Zeichen).\n- Speicherung meist in 1 Byte (höchstes Bit = 0).\n\n- Enthält:\n  - 95 druckbare Zeichen (Buchstaben, Ziffern, Satzzeichen).\n  - 33 Steuerzeichen (z.B. Zeilenumbruch).\n\nWichtige Steuerzeichen:\n- **LF (Line Feed)**: Zeilenvorschub, ASCII $(0A)_{16}$.\n- **CR (Carriage Return)**: Wagenrücklauf, ASCII $(0D)_{16}$.\n\n**Beispiel:**\n- Buchstabe `A`:\n  - ASCII-Code: $(41)_{16}$.\n  - Binär: $(01000001)_2$.\n\n---\n\n## ISO 8859\n\n- Nutzt das volle Byte (8 Bit) → 256 Zeichen.\n- **15 verschiedene Varianten** für unterschiedliche Sprachen.\n\nBeispiele:\n- ISO 8859-1: Westeuropäisch (Latin-1), enthält `ä`, `ö`, `ü`, `ß`.\n- ISO 8859-5: Kyrillisch.\n- ISO 8859-6: Arabisch.\n- usw.\n\n**Problem:**  \nSender und Empfänger müssen **dieselbe ISO-Variante** verwenden, sonst falsche Zeichen.\n\n---\n\n## Unicode\n\n### Ziel\n\n- Eine **einheitliche Codierung** für (nahezu) alle Schriftzeichen der Welt.\n- Standard: **Unicode / ISO 10646**.\n\n### Aufbau\n\n- Unicode ist in **Ebenen (planes)** organisiert:\n  - 17 Ebenen, darstellbar durch 5 Bits.\n  - Jede Ebene hat $2^{16} = 65536$ Codepunkte.\n- Insgesamt: $17 \\cdot 2^{16}$ mögliche Codepunkte.\n- Ein Unicode-Codepunkt benötigt **21 Bit**.\n\n- Wichtigste Ebene:\n  - **Basic Multilingual Plane (BMP)**, Ebene 0:\n    - Enthält die meisten aktuell verwendeten Zeichen.\n\n- Notation:\n  - `U+XXXX` (Hexadezimal, mindestens 4 Stellen).\n  - Beispiel: `U+1300C` für eine ägyptische Hieroglyphe.\n\n### Kompatibilität\n\n- Die ersten 7 Bits von Unicode entsprechen **ASCII**.\n- Die ersten 8 Bits entsprechen **ISO 8859-1 (Latin-1)**.\n\n**Merksatz:**  \nUnicode ist ein **universeller Zeichensatz**, nicht eine konkrete Byte-Kodierung.\n\n---\n\n## UTF (Unicode Transformation Formats)\n\n### Ziel\n\n- Unicode-Codepunkte (21 Bit) in **Bytes** kodieren.\n\n### Varianten\n\n- **UTF-32**:\n  - Jedes Zeichen in 32 Bit (4 Byte).\n  - Einfach, aber speicherineffizient.\n\n- **UTF-16**:\n  - Zeichen der BMP: 16 Bit (2 Byte).\n  - Zeichen außerhalb BMP: 2×16 Bit (Surrogatpaare).\n\n- **UTF-8**:\n  - Variable Länge:\n    - ASCII (erste 128 Zeichen): 1 Byte.\n    - Weitere Zeichen: 2–4 Byte.\n  - **Rückwärtskompatibel zu ASCII**:\n    - Ein Text mit nur ASCII-Zeichen ist gleichzeitig gültiges UTF-8.\n\n**Merksätze:**\n\n- UTF-8 ist heute der **Quasi-Standard** im Internet.\n- UTF-8: **platzsparend für westliche Texte**, universell einsetzbar.\n- UTF-16: häufig in internen Repräsentationen (z.B. Windows, Java).\n\n---\n\n## Wichtige Merksätze (kompakt)\n\n- **Stellenwertsystem**: Zahl $Z = \\sum a_i b^i$ mit Basis $b$.\n- **Dualsystem**: Basis 2, jede Stelle = 1 Bit.\n- **Hex/Oktal**: kompakte Schreibweise für Binär; 4 bzw. 3 Bit pro Ziffer.\n- **Rationale Zahlen**: Nachkommastellen durch negative Exponenten.\n- **Umwandlung**:\n  - Ganzzahl: wiederholte Division (Dezimal → Basis $b$).\n  - Nachkomma: wiederholte Multiplikation (Dezimal → Basis $b$).\n- **Vorzeichenlose $n$-Bit-Zahl**: $[0;2^n-1]$.\n- **Zweierkomplement**:\n  - Wertebereich: $[-2^{n-1};2^{n-1}-1]$.\n  - Negation: Bitkomplement + 1.\n  - Standard für Ganzzahlen.\n- **Festkomma**: konstanter Schritt, begrenzter Ausschnitt der Reellen.\n- **Gleitkomma (IEEE 754)**:\n  - $x = (-1)^s \\cdot m \\cdot 2^e$.\n  - float (32 Bit), double (64 Bit).\n  - Sonderwerte: $\\pm 0$, $\\pm \\infty$, NaN.\n- **ASCII**: 7 Bit, 128 Zeichen.\n- **ISO 8859-x**: 8 Bit, sprachspezifische Erweiterungen.\n- **Unicode**: universeller Zeichensatz (21 Bit).\n- **UTF-8**: variable Länge, ASCII-kompatibel, Standard im Web.",
    "generatedAt": "2025-12-05T17:43:27.140Z"
  }
]