[
  {
    "id": "1764888891935-bxirjvz07",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886676211-ne0hkjf5l",
    "question": "Aufgabe 1 (Grundlagen Quine-McCluskey, 3 Variablen)\n\nGegeben ist die Boolesche Funktion f(a, b, c) mit folgender Wertetabelle (Minterme, bei denen f = 1 ist):\n\n- f(a, b, c) = 1 für die Minterme mit Dezimalindizes: 1, 2, 3, 5\n\nDie Zuordnung der Indizes zu den Variablen sei:\n- 0: a=0, b=0, c=0\n- 1: a=0, b=0, c=1\n- 2: a=0, b=1, c=0\n- 3: a=0, b=1, c=1\n- 4: a=1, b=0, c=0\n- 5: a=1, b=0, c=1\n- 6: a=1, b=1, c=0\n- 7: a=1, b=1, c=1\n\nAufgaben:\n1. Bestimmen Sie alle Primimplikanten der Funktion f mit dem Verfahren von Quine–McCluskey.\n2. Erstellen Sie die Primimplikantentafel.\n3. Geben Sie die disjunktive Minimalform von f an.",
    "solution": "1. Schritt: Auflisten der Minterme (0. Ordnung)\n\nWir schreiben die Minterme in Binärdarstellung (a b c):\n- m1: 0 0 1\n- m2: 0 1 0\n- m3: 0 1 1\n- m5: 1 0 1\n\n2. Schritt: Gruppierung nach der Anzahl der Einsen\n\nAnzahl der Einsen in (a b c):\n- Gruppe 1 Eins:\n  - m1: 0 0 1 (1 Eins)\n  - m2: 0 1 0 (1 Eins)\n- Gruppe 2 Einsen:\n  - m3: 0 1 1 (2 Einsen)\n  - m5: 1 0 1 (2 Einsen)\n\n3. Schritt: Bilden von Implikanten 1. Ordnung (Vergleich benachbarter Gruppen)\n\nWir vergleichen nur Minterme, die sich in genau einem Bit unterscheiden.\n\nVergleiche aus Gruppe 1 ↔ Gruppe 2:\n- m1 (0 0 1) und m3 (0 1 1): unterscheiden sich nur im Bit b → Implikant I1:\n  - 0 - 1  (a=0, c=1, b beliebig)\n- m1 (0 0 1) und m5 (1 0 1): unterscheiden sich in a und b → kein Implikant\n- m2 (0 1 0) und m3 (0 1 1): unterscheiden sich nur im Bit c → Implikant I2:\n  - 0 1 -  (a=0, b=1, c beliebig)\n- m2 (0 1 0) und m5 (1 0 1): unterscheiden sich in allen drei Bits → kein Implikant\n\nMarkierung, welche Minterme verwendet wurden:\n- m1 wird in I1 verwendet\n- m2 wird in I2 verwendet\n- m3 wird in I1 und I2 verwendet\n- m5 wurde in keiner Kombination verwendet → m5 ist selbst ein Primimplikant (0 0 1 mit a=1, b=0, c=1 → 1 0 1)\n\nSomit haben wir Implikanten 1. Ordnung:\n- I1: 0 - 1  (aus m1, m3)\n- I2: 0 1 -  (aus m2, m3)\n\n4. Schritt: Prüfen, ob sich I1 und I2 weiter kombinieren lassen\n\nVergleich I1 (0 - 1) mit I2 (0 1 -):\n- I1: 0 - 1\n- I2: 0 1 -\nSie unterscheiden sich in zwei Positionen (b und c), daher keine weitere Kombination möglich.\n\n5. Schritt: Auflisten aller Primimplikanten\n\nPrimimplikanten sind alle Implikanten, die nicht mehr weiter kombinierbar sind und mindestens einen Minterm abdecken:\n- PI1: 0 - 1  (deckt m1, m3)\n- PI2: 0 1 -  (deckt m2, m3)\n- PI3: 1 0 1  (Minterm m5 alleine, nicht kombinierbar)\n\nIn Variablenform (a, b, c, Überstrich = Negation):\n- 0 - 1 → ā c\n- 0 1 - → ā b\n- 1 0 1 → a b̄ c\n\n6. Schritt: Primimplikantentafel\n\nZeilen: Primimplikanten\nSpalten: Minterme {1, 2, 3, 5}\n\n            m1   m2   m3   m5\nPI1: ā c    ●         ●\nPI2: ā b          ●   ●\nPI3: a b̄ c                 ●\n\nAbdeckung der Minterme:\n- m1 wird nur von PI1 abgedeckt → PI1 ist essenzieller Primimplikant\n- m2 wird nur von PI2 abgedeckt → PI2 ist essenzieller Primimplikant\n- m3 wird von PI1 und PI2 abgedeckt (bereits durch essenzielle PIs abgedeckt)\n- m5 wird nur von PI3 abgedeckt → PI3 ist essenzieller Primimplikant\n\nAlle drei Primimplikanten sind essenziell.\n\n7. Schritt: Disjunktive Minimalform\n\nf(a, b, c) = ā c ∨ ā b ∨ a b̄ c\n\nEs gibt keine kürzere Summe von Produkten, die alle Minterme 1, 2, 3 und 5 abdeckt, daher ist dies die disjunktive Minimalform.",
    "difficulty": "easy",
    "createdAt": "2025-12-04T22:54:51.935Z",
    "completed": false
  },
  {
    "id": "1764888891935-qugp0vlll",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886676211-ne0hkjf5l",
    "question": "Aufgabe 2 (4 Variablen, inklusive Don't-Cares)\n\nEine digitale Schaltung mit vier Eingangsvariablen x3, x2, x1, x0 soll minimiert werden. Die Funktion f(x3, x2, x1, x0) sei durch die folgenden Minterme (f = 1) und Don't-Cares d definiert:\n\n- f = 1 für die Dezimalindizes: 1, 3, 4, 5, 7, 12\n- Don't-Cares für die Dezimalindizes: 0, 6, 13\n- Für alle anderen Indizes sei f = 0.\n\nDie Binärzuordnung ist wie im Kursmaterial:\n- Index i entspricht der Binärdarstellung von (x3 x2 x1 x0).\n\nAufgaben:\n1. Bestimmen Sie alle Primimplikanten mit dem Verfahren von Quine–McCluskey unter Berücksichtigung der Don't-Cares.\n2. Erstellen Sie die Primimplikantentafel (nur für die Minterme mit f = 1, nicht für die Don't-Cares).\n3. Bestimmen Sie eine disjunktive Minimalform von f.",
    "solution": "1. Schritt: Auflisten der Minterme und Don't-Cares (0. Ordnung)\n\nMinterme (f = 1):\n- m1:  0001\n- m3:  0011\n- m4:  0100\n- m5:  0101\n- m7:  0111\n- m12: 1100\n\nDon't-Cares (d):\n- d0:  0000\n- d6:  0110\n- d13: 1101\n\nFür die Bildung von Implikanten werden Minterme und Don't-Cares gemeinsam verwendet.\n\n2. Schritt: Gruppierung nach Anzahl der Einsen\n\nWir zählen die Einsen in den 4-Bit-Worten.\n\nGruppe 0 Einsen:\n- d0: 0000\n\nGruppe 1 Eins:\n- m1: 0001\n- m4: 0100\n\nGruppe 2 Einsen:\n- m3: 0011\n- m5: 0101\n- d6: 0110\n- m12:1100\n\nGruppe 3 Einsen:\n- m7: 0111\n- d13:1101\n\nGruppe 4 Einsen: (keine)\n\n3. Schritt: Bilden der Implikanten 1. Ordnung\n\nVergleiche nur benachbarte Gruppen (Unterschied in genau einem Bit):\n\nGruppe 0 ↔ Gruppe 1:\n- d0 (0000) mit m1 (0001):\n  → 000- (I1)  (deckt {0,1})\n- d0 (0000) mit m4 (0100):\n  → 0-00 (I2) (deckt {0,4})\n\nGruppe 1 ↔ Gruppe 2:\n- m1 (0001) mit m3 (0011):\n  → 00-1 (I3) (deckt {1,3})\n- m1 (0001) mit m5 (0101):\n  → 0-01 (I4) (deckt {1,5})\n- m1 (0001) mit d6 (0110): unterscheidet sich in 3 Bits → kein Implikant\n- m1 (0001) mit m12 (1100): unterscheidet sich in 3 Bits → kein Implikant\n\n- m4 (0100) mit m3 (0011): 0100 vs 0011 → 3 Bits unterschiedlich → kein Implikant\n- m4 (0100) mit m5 (0101):\n  → 010- (I5) (deckt {4,5})\n- m4 (0100) mit d6 (0110):\n  → 01-0 (I6) (deckt {4,6})\n- m4 (0100) mit m12 (1100):\n  → -100 (I7) (deckt {4,12})\n\nGruppe 2 ↔ Gruppe 3:\n- m3 (0011) mit m7 (0111):\n  → 0-11 (I8) (deckt {3,7})\n- m3 (0011) mit d13 (1101): 0011 vs 1101 → 3 Bits unterschiedlich → kein Implikant\n\n- m5 (0101) mit m7 (0111):\n  → 011- (I9) (deckt {5,7})\n- m5 (0101) mit d13 (1101):\n  → -101 (I10) (deckt {5,13})\n\n- d6 (0110) mit m7 (0111):\n  → 011- (I9) (I9 deckt auch {6,7}, bereits vorhanden)\n- d6 (0110) mit d13 (1101): 0110 vs 1101 → 4 Bits unterschiedlich → kein Implikant\n\n- m12 (1100) mit m7 (0111): 1100 vs 0111 → 4 Bits unterschiedlich → kein Implikant\n- m12 (1100) mit d13 (1101):\n  → 110- (I11) (deckt {12,13})\n\nMarkierte (benutzte) Minterme/Don't-Cares: 0,1,3,4,5,6,7,12,13\nAlle wurden in mindestens einem Implikanten 1. Ordnung verwendet.\n\n4. Schritt: Implikanten 2. Ordnung\n\nNun kombinieren wir die Implikanten 1. Ordnung, die sich nur in einem Bit unterscheiden.\n\nBeispiele (systematisch nach Muster):\n\n- I3: 00-1 (1,3) und I4: 0-01 (1,5):\n  00-1\n  0-01\n  → unterscheiden sich in zwei Positionen → keine Kombination\n\n- I3: 00-1 (1,3) und I1: 000- (0,1):\n  00-1\n  000-\n  → unterscheiden sich in zwei Positionen → keine Kombination\n\n- I4: 0-01 (1,5) und I2: 0-00 (0,4):\n  0-01\n  0-00\n  → unterscheiden sich in einer Position (x0) → I12: 0-0- (deckt {0,1,4,5})\n\n- I5: 010- (4,5) und I6: 01-0 (4,6):\n  010-\n  01-0\n  → unterscheiden sich in zwei Positionen → keine Kombination\n\n- I5: 010- (4,5) und I8: 0-11 (3,7): zu verschieden → keine Kombination\n\n- I6: 01-0 (4,6) und I9: 011- (5,7):\n  01-0\n  011-\n  → unterscheiden sich in zwei Positionen → keine Kombination\n\n- I7: -100 (4,12) und I11: 110- (12,13):\n  -100\n  110-\n  → unterscheiden sich in zwei Positionen → keine Kombination\n\n- I8: 0-11 (3,7) und I9: 011- (5,7):\n  0-11\n  011-\n  → unterscheiden sich in zwei Positionen → keine Kombination\n\n- I9: 011- (5,7 & 6,7) und I10: -101 (5,13):\n  011-\n  -101\n  → unterscheiden sich in drei Positionen → keine Kombination\n\n- I10: -101 (5,13) und I11: 110- (12,13):\n  -101\n  110-\n  → unterscheiden sich in zwei Positionen → keine Kombination\n\n- I1: 000- und I3: 00-1 hatten wir schon geprüft; kein weiterer Kandidat ergibt eine 2. Ordnung außer I12.\n\nEs entsteht nur ein Implikant 2. Ordnung:\n- I12: 0-0- (deckt {0,1,4,5})\n\n5. Schritt: Bestimmung der Primimplikanten\n\nPrimimplikanten sind alle Implikanten, die nicht mehr weiter kombinierbar sind und mindestens einen relevanten Minterm (f=1) abdecken.\n\nNicht weiter kombinierbar:\n- I8: 0-11 (3,7)\n- I9: 011- (5,7,6)\n- I10: -101 (5,13)\n- I11: 110- (12,13)\n- I12: 0-0- (0,1,4,5)\n\nAndere 1.-Ordnung-Implikanten, die vollständig durch 2.-Ordnung-Implikanten überdeckt sind, werden nicht mehr benötigt.\n\nRelevanz (wir betrachten nur Minterme mit f=1: 1,3,4,5,7,12):\n- I8: 0-11 → deckt 3 (0011) und 7 (0111)  → beide sind f=1 → relevant\n- I9: 011- → deckt 5 (0101), 7 (0111) und 6 (0110, d) → Minterme 5 und 7 sind f=1 → relevant\n- I10: -101 → deckt 5 (0101) und 13 (1101, d) → Minterm 5 ist f=1 → relevant\n- I11: 110- → deckt 12 (1100) und 13 (1101, d) → Minterm 12 ist f=1 → relevant\n- I12: 0-0- → deckt 0 (d), 1 (0001), 4 (0100), 5 (0101) → Minterme 1,4,5 sind f=1 → relevant\n\n6. Schritt: Primimplikantentafel\n\nSpalten: Minterme mit f=1 → {1,3,4,5,7,12}\nZeilen: Primimplikanten {I8, I9, I10, I11, I12}\n\n           1   3   4   5   7   12\nI8: 0-11       ●           ●\nI9: 011-           ●   ●\nI10:-101           ●\nI11:110-                      ●\nI12:0-0-   ●       ●   ●\n\n7. Schritt: Essenzielle Primimplikanten\n\nWir suchen Spalten, in denen genau ein „●“ steht:\n- Minterm 1: nur von I12 abgedeckt → I12 essenziell\n- Minterm 3: nur von I8 abgedeckt → I8 essenziell\n- Minterm 4: nur von I12 abgedeckt (bereits essenziell)\n- Minterm 5: von I9, I10, I12 abgedeckt → nicht eindeutig\n- Minterm 7: von I8 und I9 abgedeckt → nicht eindeutig\n- Minterm 12: nur von I11 abgedeckt → I11 essenziell\n\nEssenzielle Primimplikanten: I8, I11, I12.\n\nAbgedeckte Minterme durch diese essenziellen PIs:\n- I12 (0-0-): 1,4,5 (und 0 als d)\n- I8  (0-11): 3,7\n- I11 (110-): 12 (und 13 als d)\n\nDamit sind alle Minterme {1,3,4,5,7,12} bereits abgedeckt; I9 und I10 werden nicht benötigt.\n\n8. Schritt: Disjunktive Minimalform\n\nWir schreiben die Primimplikanten in Variablenform (x3 x2 x1 x0, Überstrich = Negation):\n- I12: 0-0- → x3 = 0, x1 = 0, x2 und x0 beliebig → x̄3 x̄1\n- I8: 0-11 → x3 = 0, x1 = 1, x0 = 1, x2 beliebig → x̄3 x1 x0\n- I11: 110- → x3 = 1, x2 = 1, x1 beliebig, x0 = 0 → x3 x2 x̄0\n\nDamit ergibt sich die disjunktive Minimalform:\n\nf(x3, x2, x1, x0) = x̄3 x̄1 ∨ x̄3 x1 x0 ∨ x3 x2 x̄0\n\nDiese Form deckt alle geforderten Minterme ab und nutzt die Don't-Cares zur Vergrößerung der Implikanten.",
    "difficulty": "medium",
    "createdAt": "2025-12-04T22:54:51.935Z",
    "completed": false
  },
  {
    "id": "1764888891935-hax9uxyr3",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886676211-ne0hkjf5l",
    "question": "Aufgabe 3 (Vollständige Minimierung wie im Kursbeispiel, 4 Variablen)\n\nEine Schaltung mit vier Eingangsvariablen x3, x2, x1, x0 ist durch folgende Wertetabelle gegeben (wie im Vorlesungsbeispiel):\n\nIndex: x3 x2 x1 x0 | y\n0:     0  0  0  0 | 0\n1:     0  0  0  1 | 1\n2:     0  0  1  0 | 1\n3:     0  0  1  1 | 1\n4:     0  1  0  0 | 0\n5:     0  1  0  1 | 0\n6:     0  1  1  0 | 1\n7:     0  1  1  1 | 1\n8:     1  0  0  0 | 1\n9:     1  0  0  1 | 1\n10:    1  0  1  0 | 0\n11:    1  0  1  1 | 0\n12:    1  1  0  0 | 0\n13:    1  1  0  1 | 0\n14:    1  1  1  0 | 0\n15:    1  1  1  1 | 1\n\nAufgaben:\n1. Bestimmen Sie alle Primimplikanten der Funktion y(x3, x2, x1, x0) mit dem Verfahren von Quine–McCluskey.\n2. Erstellen Sie die vollständige Primimplikantentafel.\n3. Ermitteln Sie daraus die reduzierte Primimplikantentafel.\n4. Geben Sie die disjunktive Minimalform von y an und erläutern Sie kurz, warum keine kürzere Form möglich ist.",
    "solution": "1. Schritt: Minterme mit y = 1\n\nWir listen alle Indizes, bei denen y = 1 ist:\n- M = {1, 2, 3, 6, 7, 8, 9, 15}\n\nBinärdarstellung (x3 x2 x1 x0):\n- 1:  0001\n- 2:  0010\n- 3:  0011\n- 6:  0110\n- 7:  0111\n- 8:  1000\n- 9:  1001\n- 15: 1111\n\n2. Schritt: Gruppierung nach Anzahl der Einsen\n\nAnzahl der Einsen:\n- 1 Eins:\n  - 1: 0001\n  - 2: 0010\n  - 8: 1000\n\n- 2 Einsen:\n  - 3: 0011\n  - 6: 0110\n  - 9: 1001\n\n- 3 Einsen:\n  - 7: 0111\n\n- 4 Einsen:\n  - 15:1111\n\n3. Schritt: Implikanten 1. Ordnung\n\nVergleich benachbarter Gruppen:\n\nGruppe (1 Eins) ↔ (2 Einsen):\n- 1 (0001) mit 3 (0011):  → 00-1  (deckt {1,3})\n- 1 (0001) mit 6 (0110):  → unterscheiden sich in 3 Bits → kein Implikant\n- 1 (0001) mit 9 (1001):  → -001  (deckt {1,9})\n\n- 2 (0010) mit 3 (0011):  → 001-  (deckt {2,3})\n- 2 (0010) mit 6 (0110):  → 0-10  (deckt {2,6})\n- 2 (0010) mit 9 (1001):  → unterscheiden sich in 4 Bits → kein Implikant\n\n- 8 (1000) mit 3 (0011):  → unterscheiden sich in 3 Bits → kein Implikant\n- 8 (1000) mit 6 (0110):  → unterscheiden sich in 3 Bits → kein Implikant\n- 8 (1000) mit 9 (1001):  → 100-  (deckt {8,9})\n\nGruppe (2 Einsen) ↔ (3 Einsen):\n- 3 (0011) mit 7 (0111):  → 0-11  (deckt {3,7})\n- 6 (0110) mit 7 (0111):  → 011-  (deckt {6,7})\n- 9 (1001) mit 7 (0111):  → unterscheiden sich in 3 Bits → kein Implikant\n\nGruppe (3 Einsen) ↔ (4 Einsen):\n- 7 (0111) mit 15 (1111): → -111  (deckt {7,15})\n\nImplikanten 1. Ordnung (wie im Kursmaterial):\n- (1,3):  00-1\n- (1,9):  -001\n- (2,3):  001-\n- (2,6):  0-10\n- (3,7):  0-11\n- (6,7):  011-\n- (7,15): -111\n- (8,9):  100-\n\n4. Schritt: Implikanten 2. Ordnung\n\nWir suchen Kombinationen der 1.-Ordnung-Implikanten, die sich nur in einem Bit unterscheiden.\n\nIm Kursbeispiel entsteht genau ein Implikant 2. Ordnung:\n- (2,3) = 001- und (6,7) = 011- unterscheiden sich nur in Bit x2:\n\n  001-\n  011-\n  → 0-1- (deckt {2,3,6,7})\n\nWir nennen ihn:\n- (2,3,6,7): 0-1-\n\nWeitere Kombinationen führen zu keinen neuen 2.-Ordnung-Implikanten.\n\n5. Schritt: Bestimmung der Primimplikanten\n\nPrimimplikanten sind alle Implikanten, die nicht mehr weiter kombinierbar sind und mindestens einen Minterm abdecken.\n\nAus dem Kursmaterial sind die Primimplikanten:\n- PI1: (2,3,6,7): 0-1-   → x̄3 x1\n- PI2: (1,3):     00-1   → x̄3 x̄2 x0\n- PI3: (1,9):     -001   → x̄2 x̄1 x0\n- PI4: (7,15):    -111   → x2 x1 x0\n- PI5: (8,9):     100-   → x3 x̄2 x̄1\n\n6. Schritt: Primimplikantentafel\n\nSpalten: Minterme mit y=1 → {1,2,3,6,7,8,9,15}\nZeilen: Primimplikanten {PI1,…,PI5}\n\nWir tragen ein, welche Primimplikanten welche Minterme abdecken:\n\n           1   2   3   6   7   8   9   15\nPI1:0-1-       ●   ●   ●   ●               (2,3,6,7)\nPI2:00-1   ●       ●                         (1,3)\nPI3:-001   ●                       ●         (1,9)\nPI4:-111                       ●       ●     (7,15)\nPI5:100-                   ●   ●           (8,9)\n\n7. Schritt: Essenzielle Primimplikanten\n\nWir suchen Spalten mit genau einem „●“:\n- Minterm 2: nur durch PI1 abgedeckt → PI1 essenziell\n- Minterm 6: nur durch PI1 abgedeckt → PI1 essenziell (bestätigt)\n- Minterm 8: nur durch PI5 abgedeckt → PI5 essenziell\n- Minterm 15: nur durch PI4 abgedeckt → PI4 essenziell\n\nNach Auswahl der essenziellen Primimplikanten PI1, PI4, PI5 sind bereits abgedeckt:\n- Durch PI1 (0-1-): 2,3,6,7\n- Durch PI4 (-111): 7,15\n- Durch PI5 (100-): 8,9\n\nAbgedeckte Minterme: {2,3,6,7,8,9,15}\n\nEs bleibt noch Minterm 1 übrig.\n\n8. Schritt: Reduzierte Primimplikantentafel\n\nWir entfernen alle vollständig abgedeckten Minterme und alle Zeilen, die nur diese betreffen.\n\nÜbrig bleibt nur Minterm 1 und die Primimplikanten, die ihn abdecken:\n\n       1\nPI2:  ●   (x̄3 x̄2 x0)\nPI3:  ●   (x̄2 x̄1 x0)\n\nWir müssen mindestens einen dieser Primimplikanten wählen, um Minterm 1 abzudecken.\n\nDie reduzierte Primimplikantentafel (0. Iteration) im Kursbeispiel wählt:\n- PI2: (1,3): 00-1  → x̄3 x̄2 x0\n\nDann sind alle Minterme abgedeckt.\n\n9. Schritt: Disjunktive Minimalform\n\nAus den ausgewählten Primimplikanten:\n- Essenzielle: PI1, PI4, PI5\n- Zusätzlich gewählt: PI2\n\nIn Variablenform:\n- PI1: 0-1- → x̄3 x1\n- PI2: 00-1 → x̄3 x̄2 x0\n- PI4: -111 → x2 x1 x0\n- PI5: 100- → x3 x̄2 x̄1\n\nDamit lautet die disjunktive Minimalform:\n\ny(x3, x2, x1, x0) = x̄3 x1 ∨ x̄3 x̄2 x0 ∨ x2 x1 x0 ∨ x3 x̄2 x̄1\n\n10. Begründung der Minimalität\n\n- Alle essenziellen Primimplikanten (PI1, PI4, PI5) müssen zwingend enthalten sein, da sie jeweils mindestens einen Minterm exklusiv abdecken.\n- Ohne PI1 wären die Minterme 2 und 6 nicht abgedeckt.\n- Ohne PI4 wäre Minterm 15 nicht abgedeckt.\n- Ohne PI5 wäre Minterm 8 nicht abgedeckt.\n- Zusätzlich ist mindestens einer der Primimplikanten PI2 oder PI3 nötig, um Minterm 1 abzudecken. Die Wahl von genau einem dieser beiden führt bereits zu einer vollständigen Abdeckung; einen davon wegzulassen ist nicht möglich.\n\nSomit ist jede gültige Abdeckung durch Primimplikanten mindestens von der Form:\n- {PI1, PI4, PI5} ∪ {PI2 oder PI3}\n\nDiese Menge enthält immer genau 4 Primimplikanten. Eine Realisierung mit weniger als 4 Primimplikanten ist daher nicht möglich, weshalb die angegebene disjunktive Form minimal ist.",
    "difficulty": "medium",
    "createdAt": "2025-12-04T22:54:51.935Z",
    "completed": false
  },
  {
    "id": "1764888891935-u5uw1m64b",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886676211-ne0hkjf5l",
    "question": "Aufgabe 4 (Schaltungsentwurf und Minimierung, praxisnah)\n\nSie sollen eine Logikschaltung für ein Zugangssystem entwerfen. Es gibt vier Binäreingänge:\n- x3: \"Admin-Karte erkannt\" (1 = ja, 0 = nein)\n- x2: \"Mitarbeiter-Karte erkannt\" (1 = ja, 0 = nein)\n- x1: \"PIN korrekt\" (1 = ja, 0 = nein)\n- x0: \"Zeitfenster gültig\" (1 = ja, 0 = nein)\n\nDie Ausgangsvariable y soll 1 werden, wenn der Zugang gewährt wird. Die Systemanforderungen sind:\n1. Ein Admin (x3=1) erhält immer Zugang, wenn das Zeitfenster gültig ist (x0=1), unabhängig von x2 und x1.\n2. Ein Mitarbeiter (x2=1, x3=0) erhält Zugang nur, wenn die PIN korrekt ist (x1=1) und das Zeitfenster gültig ist (x0=1).\n3. Ohne gültige Karte (x3=0 und x2=0) darf nie Zugang gewährt werden.\n\na) Erstellen Sie aus diesen Anforderungen zunächst die Wertetabelle für y(x3, x2, x1, x0).\n\nb) Leiten Sie daraus die Minterme (Dezimalindizes) ab, für die y = 1 ist.\n\nc) Bestimmen Sie mit dem Verfahren von Quine–McCluskey eine disjunktive Minimalform für y.\n\nHinweis: Sie dürfen direkt mit den Mintermen aus Teil (b) in das Quine–McCluskey-Verfahren einsteigen.",
    "solution": "a) Wertetabelle aufstellen\n\nWir interpretieren die Anforderungen:\n1. Admin-Zugang: x3=1 und x0=1 → y=1, egal wie x2 und x1 sind.\n2. Mitarbeiter-Zugang: x3=0, x2=1, x1=1, x0=1 → y=1.\n3. Sonst y=0.\n\nWir schreiben alle 16 Kombinationen (Index = Binärwert von x3 x2 x1 x0):\n\nIndex | x3 x2 x1 x0 | y | Begründung\n0     | 0  0  0  0  | 0 | keine Karte, Zeitfenster ungültig\n1     | 0  0  0  1  | 0 | keine Karte, Zeitfenster gültig → keine Karte → kein Zugang\n2     | 0  0  1  0  | 0 | keine Karte\n3     | 0  0  1  1  | 0 | keine Karte\n4     | 0  1  0  0  | 0 | Mitarbeiterkarte, aber Zeitfenster ungültig\n5     | 0  1  0  1  | 0 | Mitarbeiterkarte, PIN falsch\n6     | 0  1  1  0  | 0 | Mitarbeiterkarte, Zeitfenster ungültig\n7     | 0  1  1  1  | 1 | Mitarbeiter: x2=1, PIN=1, Zeitfenster=1 → Zugang\n8     | 1  0  0  0  | 0 | Adminkarte, aber Zeitfenster ungültig\n9     | 1  0  0  1  | 1 | Admin + Zeitfenster gültig\n10    | 1  0  1  0  | 0 | Admin, aber Zeitfenster ungültig\n11    | 1  0  1  1  | 1 | Admin + Zeitfenster gültig\n12    | 1  1  0  0  | 0 | Admin, Zeitfenster ungültig\n13    | 1  1  0  1  | 1 | Admin + Zeitfenster gültig\n14    | 1  1  1  0  | 0 | Admin, Zeitfenster ungültig\n15    | 1  1  1  1  | 1 | Admin + Zeitfenster gültig\n\nb) Minterme mit y = 1\n\nAus der Tabelle:\n- y = 1 für Indizes: 7, 9, 11, 13, 15\n\nBinärdarstellung:\n- 7:  0111\n- 9:  1001\n- 11: 1011\n- 13: 1101\n- 15: 1111\n\nc) Quine–McCluskey-Minimierung\n\n1. Gruppierung nach Anzahl der Einsen\n\nAnzahl der Einsen in x3 x2 x1 x0:\n- 3 Einsen:\n  - 7:  0111\n  - 11: 1011\n  - 13: 1101\n\n- 2 Einsen:\n  - 9:  1001\n\n- 4 Einsen:\n  - 15: 1111\n\n(Man kann auch streng nach aufsteigender Anzahl gruppieren: 2,3,4 Einsen.)\n\n2. Implikanten 1. Ordnung\n\nGruppe (2 Einsen) ↔ (3 Einsen):\n- 9 (1001) mit 7 (0111): 1001 vs 0111 → unterscheiden sich in 3 Bits → kein Implikant\n- 9 (1001) mit 11 (1011):\n  → 10-1  (deckt {9,11})\n- 9 (1001) mit 13 (1101):\n  → 1-01  (deckt {9,13})\n\nGruppe (3 Einsen) ↔ (4 Einsen):\n- 7 (0111) mit 15 (1111):\n  → -111  (deckt {7,15})\n- 11 (1011) mit 15 (1111):\n  → 1-11  (deckt {11,15})\n- 13 (1101) mit 15 (1111):\n  → 11-1  (deckt {13,15})\n\n3. Implikanten 2. Ordnung\n\nWir versuchen, 1.-Ordnung-Implikanten zu kombinieren, die sich in einem Bit unterscheiden.\n\nBetrachten wir:\n- A: 10-1 (9,11)\n- B: 1-01 (9,13)\n- C: -111 (7,15)\n- D: 1-11 (11,15)\n- E: 11-1 (13,15)\n\nMögliche Kombinationen:\n- D (1-11) und E (11-1):\n  1-11\n  11-1\n  → 1--1 (deckt {11,13,15})\n\nWeitere sinnvolle Kombinationen:\n- A (10-1) und E (11-1):\n  10-1\n  11-1\n  → 1--1 (deckt {9,11,13,15})\n\nDamit erhalten wir einen größeren Implikanten:\n- F: 1--1 (deckt {9,11,13,15})\n\nC (-111) kann mit F (1--1) nicht weiter kombiniert werden, da sich in mehr als einem Bit etwas ändert (C hat x3 variabel, F hat x2 und x1 variabel, aber andere Positionen der Striche).\n\n4. Primimplikanten bestimmen\n\nNicht weiter kombinierbar und relevant (decken Minterme mit y=1 ab):\n- F: 1--1 (deckt {9,11,13,15})\n- C: -111 (deckt {7,15})\n\nAndere 1.-Ordnung-Implikanten sind durch F und C überdeckt und werden nicht mehr benötigt.\n\nIn Variablenform:\n- F: 1--1 → x3=1, x0=1, x2 und x1 beliebig → x3 x0\n- C: -111 → x2=1, x1=1, x0=1, x3 beliebig → x2 x1 x0\n\n5. Primimplikantentafel\n\nMinterme mit y=1: {7, 9, 11, 13, 15}\n\n           7   9   11  13  15\nF: 1--1        ●   ●   ●   ●\nC: -111   ●               ●\n\n- Minterm 7 wird nur von C abgedeckt → C essenziell\n- Die übrigen Minterme 9,11,13,15 werden von F abgedeckt → F essenziell\n\nEs werden genau diese beiden Primimplikanten benötigt.\n\n6. Disjunktive Minimalform\n\ny(x3, x2, x1, x0) = x3 x0 ∨ x2 x1 x0\n\nInterpretation:\n- x3 x0: Adminkarte + Zeitfenster gültig (unabhängig von x1 und x2)\n- x2 x1 x0: Mitarbeiterkarte + PIN korrekt + Zeitfenster gültig\n\nDies entspricht genau den ursprünglichen Anforderungen und nutzt nur zwei Produktterme, was minimal ist (da zwei logisch unabhängige Zugangsszenarien existieren, die nicht weiter zusammengefasst werden können).",
    "difficulty": "hard",
    "createdAt": "2025-12-04T22:54:51.935Z",
    "completed": false
  },
  {
    "id": "1764888891935-eligprabt",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886676211-ne0hkjf5l",
    "question": "Aufgabe 5 (Vergleich Quine–McCluskey vs. Karnaugh-Diagramm, Reflexionsaufgabe)\n\nEine Boolesche Funktion g(x3, x2, x1, x0) sei durch die Minterme g=1 für die Indizes {0,1,2,5,8,9,10,13} gegeben.\n\na) Bestimmen Sie mit dem Quine–McCluskey-Verfahren eine disjunktive Minimalform von g.\n\nb) Skizzieren Sie ein Karnaugh-Diagramm (K-Map) für diese Funktion (4 Variablen) und zeigen Sie, wie Sie über Gruppierungen zur gleichen Minimalform gelangen.\n\nc) Diskutieren Sie kurz (2–3 Sätze), in welchen praktischen Situationen Sie eher Quine–McCluskey und in welchen eher Karnaugh-Diagramme verwenden würden.",
    "solution": "a) Quine–McCluskey-Minimierung\n\n1. Minterme auflisten\n\nMinterme mit g=1: {0,1,2,5,8,9,10,13}\n\nBinär (x3 x2 x1 x0):\n- 0: 0000\n- 1: 0001\n- 2: 0010\n- 5: 0101\n- 8: 1000\n- 9: 1001\n- 10:1010\n- 13:1101\n\n2. Gruppierung nach Anzahl der Einsen\n\nAnzahl der Einsen:\n- 0 Einsen:\n  - 0: 0000\n\n- 1 Eins:\n  - 1: 0001\n  - 2: 0010\n  - 8: 1000\n\n- 2 Einsen:\n  - 5: 0101\n  - 9: 1001\n  - 10:1010\n\n- 3 Einsen:\n  - 13:1101\n\n3. Implikanten 1. Ordnung\n\nGruppe 0 ↔ 1 Eins:\n- 0 (0000) mit 1 (0001): → 000-\n- 0 (0000) mit 2 (0010): → 00-0\n- 0 (0000) mit 8 (1000): → -000\n\nGruppe 1 ↔ 2 Einsen:\n- 1 (0001) mit 5 (0101): → 0-01\n- 1 (0001) mit 9 (1001): → -001\n- 1 (0001) mit 10(1010): unterscheiden sich in 3 Bits → kein Implikant\n\n- 2 (0010) mit 5 (0101): unterscheiden sich in 3 Bits → kein Implikant\n- 2 (0010) mit 9 (1001): unterscheiden sich in 4 Bits → kein Implikant\n- 2 (0010) mit 10(1010): → 1-10\n\n- 8 (1000) mit 5 (0101): unterscheiden sich in 3 Bits → kein Implikant\n- 8 (1000) mit 9 (1001): → 100-\n- 8 (1000) mit 10(1010): → 10-0\n\nGruppe 2 ↔ 3 Einsen:\n- 5 (0101) mit 13(1101): → -101\n- 9 (1001) mit 13(1101): → 1-01\n- 10(1010) mit 13(1101): unterscheiden sich in 3 Bits → kein Implikant\n\n4. Implikanten 2. Ordnung\n\nBetrachten wir die 1.-Ordnung-Implikanten, die sich nur in einem Bit unterscheiden:\n\n- 000- (0,1) und 00-0 (0,2):\n  000-\n  00-0\n  → 00-- (deckt {0,1,2,?}) → tatsächlich {0,1,2,3}, aber 3 ist kein Minterm; dennoch ist der Implikant zulässig.\n\n- 100- (8,9) und 10-0 (8,10):\n  100-\n  10-0\n  → 10-- (deckt {8,9,10,11})\n\n- 0-01 (1,5) und -001 (1,9):\n  0-01\n  -001\n  → - -01 (zu viele Unterschiede, hier Vorsicht: sie unterscheiden sich in x3 und x2 → 2 Bits → keine Kombination)\n\n- 1-10 (2,10) und 10-0 (8,10):\n  1-10\n  10-0\n  → 1--0 (deckt {2,10,?}) hier Vorsicht: 1-10 = {2,10}, 10-0 = {8,10}; Kombination ist zulässig:\n  1-10\n  10-0\n  → 1--0 (deckt {2,8,10,?})\n\nUm die Lösung übersichtlich zu halten, nutzen wir hier einen schnelleren Weg: Wir prüfen direkt, welche größeren Gruppen sinnvoll sind, indem wir auf die Minterme schauen.\n\nBeobachtung in den Mintermen:\n- {0,1,2} liegen alle in der Form 00-- (x3=0, x2=0, x1 und x0 beliebig zwischen 0 und 1, aber 3 ist nicht in M).\n  → Implikant P1: 00-- → x̄3 x̄2 (deckt 0,1,2,3; relevant sind 0,1,2)\n\n- {8,9,10} liegen alle in der Form 10-- (x3=1, x2=0, x1 und x0 beliebig; 11 ist nicht in M).\n  → Implikant P2: 10-- → x3 x̄2 (deckt 8,9,10,11; relevant sind 8,9,10)\n\n- {5,13} liegen in der Form -101 (x2=1, x0=1, x3 beliebig, x1=0 oder 1?)\n  5:  0101\n  13: 1101\n  → -101 → x2=1, x0=1, x3 beliebig, x1=0? Nein, x1=0 bei 5 und x1=0 bei 13? Tatsächlich:\n  - 5:  0 1 0 1\n  - 13: 1 1 0 1\n  x2=1, x1=0, x0=1, x3 beliebig → -101 ist korrekt → x2 x̄1 x0\n\nDamit erhalten wir drei große Implikanten:\n- P1: 00--  → x̄3 x̄2\n- P2: 10--  → x3 x̄2\n- P3: -101  → x2 x̄1 x0\n\n5. Primimplikantentafel\n\nMinterme: {0,1,2,5,8,9,10,13}\n\n           0   1   2   5   8   9   10  13\nP1:x̄3 x̄2  ●   ●   ●\nP2:x3 x̄2               ●   ●   ●\nP3:x2 x̄1 x0      ●           ●       ●\n\nAbdeckung:\n- 0,1,2 werden nur von P1 abgedeckt → P1 essenziell\n- 8,9,10 werden nur von P2 abgedeckt → P2 essenziell\n- 5,13 werden nur von P3 abgedeckt → P3 essenziell\n\nAlle drei Primimplikanten sind essenziell; keiner kann entfallen.\n\n6. Disjunktive Minimalform\n\ng(x3, x2, x1, x0) = x̄3 x̄2 ∨ x3 x̄2 ∨ x2 x̄1 x0\n\nb) Karnaugh-Diagramm (K-Map)\n\nWir wählen die Standardanordnung:\n- Zeilen: x3 x2 ∈ {00, 01, 11, 10}\n- Spalten: x1 x0 ∈ {00, 01, 11, 10}\n\nEintragen der 1en (Minterme):\n- 0 (0000): Zeile 00, Spalte 00\n- 1 (0001): Zeile 00, Spalte 01\n- 2 (0010): Zeile 00, Spalte 10\n- 5 (0101): Zeile 01, Spalte 01\n- 8 (1000): Zeile 10, Spalte 00\n- 9 (1001): Zeile 10, Spalte 01\n- 10(1010): Zeile 10, Spalte 10\n- 13(1101): Zeile 11, Spalte 01\n\nGruppierungen:\n- Vierergruppe oben links: (0,1,2,?)\n  - Tatsächlich 0,1,2 und (theoretisch 3, aber 3 ist 0 → Gruppe von 3 ist nicht zulässig; wir bilden zwei Zweiergruppen oder eine 4er-Gruppe über Wrap-Around mit anderen 1en.)\n  Besser:\n  - Gruppe G1: {0,1} (Zeile 00, Spalten 00 und 01) und {0,2} (Zeile 00, Spalten 00 und 10) zusammen ergeben effektiv x̄3 x̄2 (entspricht P1).\n\n- Vierergruppe unten links: {8,9,10,(11)}\n  - 8,9,10 und 11 (11 ist 0) → ähnlich wie oben. Tatsächlich bilden wir zwei Zweiergruppen:\n  - {8,9} und {8,10}, was wieder zu x3 x̄2 (P2) führt.\n\n- Zweiergruppe {5,13} (beide in Spalte 01, Zeilen 01 und 11):\n  - das ergibt -101 → x2 x̄1 x0 (P3).\n\nDie so gefundenen Terme stimmen mit P1, P2, P3 überein.\n\nc) Kurze Diskussion\n\n- Quine–McCluskey eignet sich besonders für eine systematische, algorithmische Minimierung, vor allem bei vielen Variablen und wenn eine Implementierung in Software (z.B. in CAD-Tools) benötigt wird. Es ist formal und maschinenfreundlich.\n- Karnaugh-Diagramme sind bei 3–4 (max. 5–6) Variablen sehr anschaulich und intuitiv, da Gruppierungen visuell erkennbar sind. Sie eignen sich gut für manuelle Vereinfachungen in Übungen, Klausuren und im frühen Entwurfsstadium, werden aber bei mehr Variablen schnell unübersichtlich.",
    "difficulty": "hard",
    "createdAt": "2025-12-04T22:54:51.935Z",
    "completed": false
  },
  {
    "id": "1764888988966-xuh7luld7",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886675579-wnj03njbm",
    "question": "Aufgabe 1 (Einstieg, Quine-McCluskey-Grundidee)\n\nGegeben ist die boolesche Funktion f mit den Variablen x₁ und x₀. Die Funktion sei durch folgende Wertetabelle definiert:\n\nx₁ x₀ | f\n0  0  | 0\n0  1  | 1\n1  0  | 1\n1  1  | 1\n\na) Schreiben Sie f als Summe von Mintermen (disjunktive Normalform ohne Minimierung).\n\nb) Führen Sie einen Minimierungsschritt nach dem Verfahren von Quine-McCluskey durch, indem Sie alle Minterme nach der Anzahl der Einsen in der Binärdarstellung gruppieren und kombinierbare Paare finden.\n\nc) Geben Sie die minimale disjunktive Form von f an.",
    "solution": "a) Zunächst bestimmen wir die Minterme, für die f = 1 gilt.\n\nAus der Wertetabelle:\n- Für x₁x₀ = 01 ist f = 1 → Minterm m₁ = ¬x₁ ∧ x₀\n- Für x₁x₀ = 10 ist f = 1 → Minterm m₂ = x₁ ∧ ¬x₀\n- Für x₁x₀ = 11 ist f = 1 → Minterm m₃ = x₁ ∧ x₀\n\nDie nicht-minimierte disjunktive Normalform (DNF) lautet:\n\nf(x₁, x₀) = ¬x₁x₀ + x₁¬x₀ + x₁x₀\n\n(„+“ steht hier für ODER, die Konjunktion wird durch Aneinanderreihung geschrieben.)\n\nb) Quine-McCluskey – erster Schritt: Gruppierung nach Anzahl der Einsen in der Binärdarstellung der Minterm-Indizes.\n\nWir nummerieren die Minterme nach ihrem Binärwert (x₁x₀):\n- m₁: 01 (eine 1)\n- m₂: 10 (eine 1)\n- m₃: 11 (zwei 1en)\n\nGruppen:\n- Gruppe 1 (eine 1): m₁ (01), m₂ (10)\n- Gruppe 2 (zwei 1en): m₃ (11)\n\nNun suchen wir kombinierbare Paare, die sich nur in einem Bit unterscheiden:\n\nVergleiche:\n- m₁ (01) und m₃ (11): unterscheiden sich im höchsten Bit → kombinierbar → ergibt: -1 (‚-‘ bedeutet: Variable fällt weg)\n  • 01 vs. 11 → x₁ wechselt 0→1, x₀ bleibt 1 → gemeinsame Form: x₀\n- m₂ (10) und m₃ (11): unterscheiden sich im niedrigsten Bit → kombinierbar → ergibt: 1-\n  • 10 vs. 11 → x₀ wechselt 0→1, x₁ bleibt 1 → gemeinsame Form: x₁\n\nm₁ und m₂ (01 vs. 10) unterscheiden sich in beiden Bits → nicht kombinierbar.\n\nPrimimplikanten-Kandidaten aus der Kombination:\n- P₁: x₀ (aus 01 und 11)\n- P₂: x₁ (aus 10 und 11)\n\nc) Bestimmung der minimalen disjunktiven Form.\n\nDie Funktion f ist 1 für die Minterme 01, 10, 11. Prüfen wir, ob P₁ und P₂ alle abdecken:\n- P₁ = x₀ deckt 01 und 11 ab.\n- P₂ = x₁ deckt 10 und 11 ab.\n\nDamit sind alle Einsen abgedeckt. Wir können f also schreiben als:\n\nf(x₁, x₀) = x₀ + x₁\n\nDies ist bereits minimal, da nur noch zwei Literale verwendet werden und keine weitere Zusammenfassung möglich ist.\n\nEndergebnis:\n\n- Nicht-minimierte DNF: f = ¬x₁x₀ + x₁¬x₀ + x₁x₀\n- Minimale disjunktive Form: f = x₁ + x₀",
    "difficulty": "easy",
    "createdAt": "2025-12-04T22:56:28.966Z",
    "completed": false
  },
  {
    "id": "1764888988966-z0aqy80ku",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886675579-wnj03njbm",
    "question": "Aufgabe 2 (Anwendung des Quine-McCluskey-Verfahrens für 3 Variablen)\n\nGegeben ist eine boolesche Funktion f mit den Variablen x₂, x₁ und x₀. Die Funktion ist durch folgende Wertetabelle definiert:\n\nx₂ x₁ x₀ | f\n0  0  0  | 0\n0  0  1  | 1\n0  1  0  | 1\n0  1  1  | 1\n1  0  0  | 0\n1  0  1  | 1\n1  1  0  | 1\n1  1  1  | 0\n\na) Geben Sie die Liste der Minterme an, für die f = 1 gilt (in Dezimalindizes und als Produktterme).\n\nb) Führen Sie das Quine-McCluskey-Verfahren zur Bestimmung der Primimplikanten durch (Gruppierung, Kombination, Ermittlung der Primimplikanten).\n\nc) Erstellen Sie die Primimplikantentafel und bestimmen Sie daraus eine minimale disjunktive Form von f.",
    "solution": "a) Bestimmung der Minterme (f = 1):\n\nWir interpretieren (x₂x₁x₀) als Binärzahl mit x₂ als MSB.\n\nAus der Tabelle:\n- 0 0 1 → Index 1 → f = 1 → m₁: ¬x₂ ∧ ¬x₁ ∧ x₀\n- 0 1 0 → Index 2 → f = 1 → m₂: ¬x₂ ∧ x₁ ∧ ¬x₀\n- 0 1 1 → Index 3 → f = 1 → m₃: ¬x₂ ∧ x₁ ∧ x₀\n- 1 0 1 → Index 5 → f = 1 → m₅: x₂ ∧ ¬x₁ ∧ x₀\n- 1 1 0 → Index 6 → f = 1 → m₆: x₂ ∧ x₁ ∧ ¬x₀\n\nMinterm-Liste (dezimale Indizes): {1, 2, 3, 5, 6}\n\nb) Quine-McCluskey-Verfahren\n\nSchritt 1: Gruppierung nach Anzahl der Einsen in der Binärdarstellung.\n\nBinär (x₂x₁x₀):\n- m₁: 001 → 1 Eins\n- m₂: 010 → 1 Eins\n- m₃: 011 → 2 Einsen\n- m₅: 101 → 2 Einsen\n- m₆: 110 → 2 Einsen\n\nGruppen:\n- Gruppe 1 (1 Eins): m₁(001), m₂(010)\n- Gruppe 2 (2 Einsen): m₃(011), m₅(101), m₆(110)\n\nSchritt 2: Kombination benachbarter Gruppen\n\nVergleiche Gruppe 1 mit Gruppe 2:\n\n1) m₁(001) mit:\n- m₃(011): 001 vs. 011 → unterscheiden sich in x₁ (0→1), x₂ gleich (0), x₀ gleich (1) → kombinierbar → ergibt 0 1 - oder 0 1 1 mit x₀ als -?\n  Korrekt: 001 vs. 011: x₂=0 gleich, x₁=0/1, x₀=1 gleich → Kombination: 0-1 (x₂=0, x₁=–, x₀=1)\n  → Implikant P₁: ¬x₂ ∧ x₀\n- m₅(101): 001 vs. 101 → unterscheiden sich in x₂ und x₁ → nicht kombinierbar\n- m₆(110): 001 vs. 110 → unterscheiden sich in allen Bits → nicht kombinierbar\n\n2) m₂(010) mit:\n- m₃(011): 010 vs. 011 → unterscheiden sich in x₀ (0→1), x₂=0, x₁=1 gleich → kombinierbar → 01- → Implikant P₂: ¬x₂ ∧ x₁\n- m₅(101): 010 vs. 101 → unterscheiden sich in allen Bits → nicht kombinierbar\n- m₆(110): 010 vs. 110 → unterscheiden sich in x₂ (0→1), x₁=1, x₀=0 gleich → kombinierbar → -10 → Implikant P₃: x₁ ∧ ¬x₀\n\nNun prüfen wir Kombinationen innerhalb der zweiten Gruppe (mit gleicher Einsanzahl) – diese werden im klassischen Quine-McCluskey nur zwischen benachbarten Gruppen kombiniert, daher hier nicht weiter kombiniert.\n\nMarkierung der verwendeten Minterme:\n- m₁ wurde in P₁ verwendet.\n- m₂ wurde in P₂ und P₃ verwendet.\n- m₃ wurde in P₁ und P₂ verwendet.\n- m₅ und m₆ wurden bisher nur zum Teil betrachtet: m₆ in P₃, m₅ in keiner Kombination.\n\nDa m₅(101) mit keinem Minterm aus Gruppe 1 nur in einem Bit differiert, bleibt m₅ selbst als Primimplikant bestehen.\n\nImplikanten:\n- P₁: 0-1 = ¬x₂ ∧ x₀ (deckt m₁, m₃)\n- P₂: 01- = ¬x₂ ∧ x₁ (deckt m₂, m₃)\n- P₃: -10 = x₁ ∧ ¬x₀ (deckt m₂, m₆)\n- P₄: 101 = x₂ ∧ ¬x₁ ∧ x₀ (entspricht m₅)\n\nDiese sind Primimplikanten, da sie nicht weiter kombinierbar sind.\n\nc) Primimplikantentafel und minimale Form\n\nZunächst bestimmen wir, welche Minterme von welchen Primimplikanten abgedeckt werden.\n\nMinterme: 1(001), 2(010), 3(011), 5(101), 6(110)\n\nPrimimplikanten:\n- P₁ = ¬x₂x₀ (0-1) deckt: 001 (m₁), 011 (m₃)\n- P₂ = ¬x₂x₁ (01-) deckt: 010 (m₂), 011 (m₃)\n- P₃ = x₁¬x₀ (-10) deckt: 010 (m₂), 110 (m₆)\n- P₄ = x₂¬x₁x₀ (101) deckt: 101 (m₅)\n\nTafel (X = abgedeckt):\n\n          m₁   m₂   m₃   m₅   m₆\nP₁: ¬x₂x₀   X         X\nP₂: ¬x₂x₁       X    X\nP₃: x₁¬x₀       X         X\nP₄: x₂¬x₁x₀          X\n\nEssentielle Primimplikanten: Ein Minterm, der nur von einem Primimplikanten abgedeckt wird, macht diesen Primimplikanten essentiell.\n\n- m₁ wird nur von P₁ abgedeckt → P₁ ist essentiell.\n- m₅ wird nur von P₄ abgedeckt → P₄ ist essentiell.\n\nMarkieren wir m₁ und m₅ als abgedeckt. Es bleiben m₂, m₃, m₆.\n\nFür die restlichen Minterme:\n- m₂: von P₂ und P₃ abgedeckt\n- m₃: von P₁ (schon gewählt) und P₂ abgedeckt → durch P₁ bereits abgedeckt\n- m₆: nur von P₃ abgedeckt → P₃ ist damit ebenfalls essentiell.\n\nDamit sind alle Minterme abgedeckt mit P₁, P₃ und P₄.\n\nMinimale disjunktive Form:\n\nf(x₂, x₁, x₀) = P₁ + P₃ + P₄\n              = ¬x₂x₀ + x₁¬x₀ + x₂¬x₁x₀\n\nOptional kann man prüfen, ob eine weitere Vereinfachung per algebraischer Umformung möglich ist, aber im Rahmen des Quine-McCluskey-Verfahrens ist dies eine gültige minimale DNF.\n\nEndergebnis:\n\nf(x₂, x₁, x₀) = ¬x₂x₀ + x₁¬x₀ + x₂¬x₁x₀",
    "difficulty": "medium",
    "createdAt": "2025-12-04T22:56:28.966Z",
    "completed": false
  },
  {
    "id": "1764888988966-8rd6f6mzb",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886675579-wnj03njbm",
    "question": "Aufgabe 3 (Angelehnt an das Kursbeispiel: 4 Variablen, vollständige Minimierung)\n\nGegeben ist eine boolesche Funktion y mit den Variablen x₃, x₂, x₁, x₀. Die Funktion ist durch die folgenden Minterme definiert, für die y = 1 gilt:\n\nMinterm-Indizes (in Dezimaldarstellung):\n1, 2, 3, 6, 7, 8, 9, 15\n\nDie Binärdarstellung der Indizes entspricht (x₃x₂x₁x₀) mit x₃ als höchstwertigem Bit.\n\na) Schreiben Sie die zugehörige Wertetabelle (nur die Zeilen 0 bis 15, mit y = 0 oder y = 1) vollständig auf.\n\nb) Bestimmen Sie alle Primimplikanten mit dem Verfahren von Quine-McCluskey (inkl. Gruppierung nach Einsanzahl und systematischer Kombination).\n\nc) Erstellen Sie die Primimplikantentafel.\n\nd) Geben Sie eine minimale disjunktive Form von y an.",
    "solution": "a) Wertetabelle\n\nWir betrachten alle 16 möglichen Belegungen von x₃x₂x₁x₀ (0 bis 15). y = 1 genau für die Minterme 1, 2, 3, 6, 7, 8, 9, 15, sonst 0.\n\nIndex | x₃ x₂ x₁ x₀ | y\n0     | 0  0  0  0  | 0\n1     | 0  0  0  1  | 1\n2     | 0  0  1  0  | 1\n3     | 0  0  1  1  | 1\n4     | 0  1  0  0  | 0\n5     | 0  1  0  1  | 0\n6     | 0  1  1  0  | 1\n7     | 0  1  1  1  | 1\n8     | 1  0  0  0  | 1\n9     | 1  0  0  1  | 1\n10    | 1  0  1  0  | 0\n11    | 1  0  1  1  | 0\n12    | 1  1  0  0  | 0\n13    | 1  1  0  1  | 0\n14    | 1  1  1  0  | 0\n15    | 1  1  1  1  | 1\n\nb) Quine-McCluskey: Bestimmung der Primimplikanten\n\nSchritt 1: Minterme und Einsanzahl\n\nMinterme mit y = 1:\n1: 0001 → 1 Eins\n2: 0010 → 1 Eins\n3: 0011 → 2 Einsen\n6: 0110 → 2 Einsen\n7: 0111 → 3 Einsen\n8: 1000 → 1 Eins\n9: 1001 → 2 Einsen\n15: 1111 → 4 Einsen\n\nGruppen nach Anzahl der Einsen:\n- Gruppe 1 (1 Eins): 1(0001), 2(0010), 8(1000)\n- Gruppe 2 (2 Einsen): 3(0011), 6(0110), 9(1001)\n- Gruppe 3 (3 Einsen): 7(0111)\n- Gruppe 4 (4 Einsen): 15(1111)\n\nSchritt 2: Kombination benachbarter Gruppen\n\nZwischen Gruppe 1 und 2:\n\n1(0001) mit\n- 3(0011): 0001 vs. 0011 → Unterschied nur in x₁ (0→1), x₃=0, x₂=0, x₀=1 gleich → kombinierbar → 00-1\n  → I₁: 00-1 = ¬x₃ ∧ ¬x₂ ∧ x₀ (deckt 1,3)\n- 6(0110): 0001 vs. 0110 → unterscheiden sich in 3 Bits → nicht kombinierbar\n- 9(1001): 0001 vs. 1001 → unterscheiden sich in x₃ und x₂ → nicht kombinierbar\n\n2(0010) mit\n- 3(0011): 0010 vs. 0011 → Unterschied nur in x₀ (0→1), x₃=0, x₂=0, x₁=1 gleich → kombinierbar → 001-\n  → I₂: 001- = ¬x₃ ∧ ¬x₂ ∧ x₁ (deckt 2,3)\n- 6(0110): 0010 vs. 0110 → Unterschied nur in x₂ (0→1), x₃=0, x₁=1, x₀=0 gleich → kombinierbar → 0-10\n  → I₃: 0-10 = ¬x₃ ∧ x₁ ∧ ¬x₀ (deckt 2,6)\n- 9(1001): 0010 vs. 1001 → unterscheiden sich in 3 Bits → nicht kombinierbar\n\n8(1000) mit\n- 3(0011): 1000 vs. 0011 → zu viele Unterschiede → nicht kombinierbar\n- 6(0110): 1000 vs. 0110 → zu viele Unterschiede → nicht kombinierbar\n- 9(1001): 1000 vs. 1001 → Unterschied nur in x₀ (0→1), x₃=1, x₂=0, x₁=0 gleich → kombinierbar → 100-\n  → I₄: 100- = x₃ ∧ ¬x₂ ∧ ¬x₁ (deckt 8,9)\n\nZwischen Gruppe 2 und 3:\n\n3(0011) mit 7(0111): 0011 vs. 0111 → Unterschied nur in x₂ (0→1), andere Bits gleich → kombinierbar → 0-11\n  → I₅: 0-11 = ¬x₃ ∧ x₁ ∧ x₀ (deckt 3,7)\n\n6(0110) mit 7(0111): 0110 vs. 0111 → Unterschied nur in x₀ (0→1), andere Bits gleich → kombinierbar → 011-\n  → I₆: 011- = ¬x₃ ∧ x₂ ∧ x₁ (deckt 6,7)\n\n9(1001) mit 7(0111): 1001 vs. 0111 → zu viele Unterschiede → nicht kombinierbar\n\nZwischen Gruppe 3 und 4:\n\n7(0111) mit 15(1111): 0111 vs. 1111 → Unterschied nur in x₃ (0→1), andere Bits gleich → kombinierbar → -111\n  → I₇: -111 = x₂ ∧ x₁ ∧ x₀ (deckt 7,15)\n\nSchritt 3: Prüfen, ob sich die neuen Implikanten weiter kombinieren lassen\n\nNeue Implikanten (mit „-\" als Don't-Care):\n- I₁: 00-1 (x₃=0, x₂=0, x₁=-, x₀=1) → deckt 1,3\n- I₂: 001- (x₃=0, x₂=0, x₁=1, x₀=-) → deckt 2,3\n- I₃: 0-10 (x₃=0, x₂=-, x₁=1, x₀=0) → deckt 2,6\n- I₄: 100- (x₃=1, x₂=0, x₁=0, x₀=-) → deckt 8,9\n- I₅: 0-11 (x₃=0, x₂=-, x₁=1, x₀=1) → deckt 3,7\n- I₆: 011- (x₃=0, x₂=1, x₁=1, x₀=-) → deckt 6,7\n- I₇: -111 (x₃=-, x₂=1, x₁=1, x₀=1) → deckt 7,15\n\nNun Kombination von Implikanten mit gleicher Anzahl von gesetzten Bits (Anzahl der Bindestriche ist hier relevant). Wir suchen Paare, die sich nur in einem festen Bit unterscheiden und ansonsten gleich oder „-“ haben.\n\nTypische sinnvolle Kombinationen:\n- I₅ (0-11) und I₇ (-111):\n  • I₅: 0 - 1 1\n  • I₇: - 1 1 1\n  Diese unterscheiden sich in x₃ und x₂, also in zwei Positionen → nicht kombinierbar.\n\n- I₆ (011-) und I₇ (-111):\n  • I₆: 0 1 1 -\n  • I₇: - 1 1 1\n  Unterschiede in x₃ und x₀ → nicht kombinierbar.\n\n- I₁ und I₂, I₁ und I₃, ...: Alle Vergleiche führen zu mindestens zwei unterschiedlichen festen Bits, sodass keine weitere Kombination möglich ist.\n\nDamit sind die Implikanten I₁ bis I₇ bereits Primimplikanten.\n\nc) Primimplikantentafel\n\nMinterme: 1, 2, 3, 6, 7, 8, 9, 15\n\nPrimimplikanten und ihre Abdeckung:\n- I₁ (00-1 = ¬x₃¬x₂x₀): deckt 1, 3\n- I₂ (001- = ¬x₃¬x₂x₁): deckt 2, 3\n- I₃ (0-10 = ¬x₃x₁¬x₀): deckt 2, 6\n- I₄ (100- = x₃¬x₂¬x₁): deckt 8, 9\n- I₅ (0-11 = ¬x₃x₁x₀): deckt 3, 7\n- I₆ (011- = ¬x₃x₂x₁): deckt 6, 7\n- I₇ (-111 = x₂x₁x₀): deckt 7, 15\n\nTafel (X = abgedeckt):\n\n        1   2   3   6   7   8   9   15\nI₁      X       X\nI₂          X   X\nI₃          X   X\nI₄                      X   X\nI₅              X   X\nI₆              X   X\nI₇                  X               X\n\nd) Bestimmung einer minimalen disjunktiven Form\n\nZunächst suchen wir essentielle Primimplikanten (Minterme, die nur von einem Primimplikanten abgedeckt werden):\n\n- Minterm 1: nur von I₁ abgedeckt → I₁ ist essentiell.\n- Minterm 8: nur von I₄ abgedeckt → I₄ ist essentiell.\n- Minterm 9: nur von I₄ abgedeckt → bestätigt I₄.\n- Minterm 15: nur von I₇ abgedeckt → I₇ ist essentiell.\n\nDamit wählen wir I₁, I₄ und I₇ sicher aus. Diese decken bereits die Minterme ab:\n- I₁: 1, 3\n- I₄: 8, 9\n- I₇: 7, 15\n\nNoch nicht abgedeckt sind: 2, 6.\n\nFür die restlichen Minterme:\n- Minterm 2: von I₂ und I₃ abgedeckt.\n- Minterm 6: von I₃ und I₆ abgedeckt.\n\nUm 2 und 6 gemeinsam mit möglichst wenigen weiteren Implikanten abzudecken, betrachten wir:\n- I₂ deckt: 2, 3 (3 ist schon von I₁ abgedeckt)\n- I₃ deckt: 2, 6\n- I₆ deckt: 6, 7 (7 ist schon von I₇ abgedeckt)\n\nDie beste Wahl ist I₃, da er beide noch offenen Minterme 2 und 6 in einem Schritt abdeckt.\n\nAusgewählte Primimplikanten:\n- I₁: ¬x₃¬x₂x₀\n- I₄: x₃¬x₂¬x₁\n- I₇: x₂x₁x₀\n- I₃: ¬x₃x₁¬x₀\n\nMinimale disjunktive Form von y:\n\ny(x₃, x₂, x₁, x₀) = ¬x₃¬x₂x₀ + ¬x₃x₁¬x₀ + x₃¬x₂¬x₁ + x₂x₁x₀\n\nDies ist eine zulässige minimale DNF bezogen auf die Anzahl der Primimplikanten; eine weitere Reduktion via reinem Quine-McCluskey ist nicht möglich.\n\nEndergebnis:\n\ny = ¬x₃¬x₂x₀ + ¬x₃x₁¬x₀ + x₃¬x₂¬x₁ + x₂x₁x₀",
    "difficulty": "hard",
    "createdAt": "2025-12-04T22:56:28.966Z",
    "completed": false
  },
  {
    "id": "1764888988966-h4btnjlx5",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886675579-wnj03njbm",
    "question": "Aufgabe 4 (Praxisnah: Steuerlogik mit Don't-Cares und Quine-McCluskey)\n\nEin digitales Steuersystem besitzt vier Eingangsvariablen:\n- x₃: Not-Aus (1 = aktiv)\n- x₂: Fehlerzustand (1 = Fehler)\n- x₁: Betriebsmodus (0 = Handbetrieb, 1 = Automatik)\n- x₀: Startsignal (1 = Startanforderung)\n\nDie Ausgangsvariable y soll das Signal \"Antrieb EIN\" darstellen (1 = Antrieb ein, 0 = Antrieb aus).\n\nDie gewünschte Funktionalität ist:\n1. Wenn Not-Aus aktiv ist (x₃ = 1), soll der Antrieb immer AUS sein, egal wie die anderen Signale stehen.\n2. Im Fehlerzustand (x₂ = 1) soll der Antrieb AUS sein, außer im Service-Fall: Handbetrieb (x₁ = 0) und Startsignal aktiv (x₀ = 1); in diesem Fall darf der Antrieb EIN sein.\n3. Im fehlerfreien Zustand (x₂ = 0) und ohne Not-Aus (x₃ = 0) soll der Antrieb EIN sein, wenn Startsignal aktiv ist (x₀ = 1), unabhängig vom Betriebsmodus x₁.\n\nZusätzlich werden einige Kombinationen im Fehlerfall und ohne Startsignal als \"nicht relevant\" betrachtet (Don't-Cares), da sie in der Praxis nicht auftreten: x₃ = 0, x₂ = 1, x₀ = 0 (für beide Werte von x₁).\n\na) Stellen Sie eine (teilweise) Wertetabelle für y auf und markieren Sie die Don't-Care-Zustände (z. B. mit d).\n\nb) Leiten Sie aus der Spezifikation die Liste der Minterme ab, für die y = 1 ist, und die Liste der Don't-Care-Minterme.\n\nc) Wenden Sie das Quine-McCluskey-Verfahren unter Berücksichtigung der Don't-Cares an, um eine minimale disjunktive Form für y zu bestimmen.\n\nHinweis: Gehen Sie systematisch vor: Gruppenbildung, Kombination, Bestimmung der Primimplikanten und Auswahl der minimalen Überdeckung.",
    "solution": "a) Wertetabelle (konzeptionell)\n\nWir betrachten alle 16 Kombinationen von x₃x₂x₁x₀. Notation: y = 0, 1 oder d (Don't-Care).\n\nRegel 1: x₃ = 1 (Not-Aus aktiv) → y = 0 für alle x₂, x₁, x₀.\n\nRegel 2: Fehlerzustand x₂ = 1, aber x₃ = 0:\n- Service-Fall: Handbetrieb (x₁ = 0) und Startsignal 1 (x₀ = 1) → y = 1.\n- Sonst: y = 0, außer bei Don't-Cares.\n\nRegel 3: Fehlerfrei x₂ = 0, x₃ = 0, Startsignal 1 (x₀ = 1) → y = 1, unabhängig von x₁.\n\nDon't-Cares: x₃ = 0, x₂ = 1, x₀ = 0 (x₁ beliebig).\n\nWir schreiben die relevanten Zeilen (x₃x₂x₁x₀, Index in Dezimal):\n\nx₃ x₂ x₁ x₀ | Index | y\n0  0  0  0  | 0     | 0      (fehlerfrei, kein Start)\n0  0  0  1  | 1     | 1      (fehlerfrei, Start, Handbetrieb)\n0  0  1  0  | 2     | 0      (fehlerfrei, kein Start)\n0  0  1  1  | 3     | 1      (fehlerfrei, Start, Automatik)\n0  1  0  0  | 4     | d      (Don't-Care: Fehler, kein Start, Handbetrieb)\n0  1  0  1  | 5     | 1      (Fehler, Service-Fall: Handbetrieb + Start)\n0  1  1  0  | 6     | d      (Don't-Care: Fehler, kein Start, Automatik)\n0  1  1  1  | 7     | 0      (Fehler, Start + Automatik → nicht erlaubt)\n1  0  0  0  | 8     | 0      (Not-Aus aktiv → immer 0)\n1  0  0  1  | 9     | 0\n1  0  1  0  | 10    | 0\n1  0  1  1  | 11    | 0\n1  1  0  0  | 12    | 0\n1  1  0  1  | 13    | 0\n1  1  1  0  | 14    | 0\n1  1  1  1  | 15    | 0\n\nb) Minterm-Listen\n\nMinterme mit y = 1:\n- Index 1: 0001 → m₁\n- Index 3: 0011 → m₃\n- Index 5: 0101 → m₅\n\nMinterme mit Don't-Care (d):\n- Index 4: 0100 → d₄\n- Index 6: 0110 → d₆\n\nAlle anderen Minterme haben y = 0.\n\nc) Quine-McCluskey mit Don't-Cares\n\nWir behandeln die Don't-Cares beim Kombinieren wie Minterme mit y = 1, berücksichtigen sie aber nicht in der Endabdeckung.\n\nZu kombinierende Terme (1 oder d):\n- 1: 0001 (1 Eins)\n- 3: 0011 (2 Einsen)\n- 5: 0101 (2 Einsen)\n- 4: 0100 (1 Eins, d)\n- 6: 0110 (2 Einsen, d)\n\nGruppen nach Einsanzahl:\n- Gruppe 1 (1 Eins): 1(0001), 4(0100)\n- Gruppe 2 (2 Einsen): 3(0011), 5(0101), 6(0110)\n\nSchritt 1: Kombination Gruppe 1 ↔ Gruppe 2\n\n1(0001) mit:\n- 3(0011): 0001 vs. 0011 → Unterschied in x₁ (0→1), andere gleich → kombinierbar → 00-1\n  → J₁: 00-1 = ¬x₃¬x₂x₀ (deckt 1,3)\n- 5(0101): 0001 vs. 0101 → Unterschied in x₂ (0→1), andere gleich → kombinierbar → 0-01\n  → J₂: 0-01 = ¬x₃x₁x₀? Vorsicht: 0001 vs. 0101 → x₃=0, x₂=0/1, x₁=0, x₀=1 → 0-01 = ¬x₃ ∧ ¬x₁ ∧ x₀ (deckt 1,5)\n- 6(0110): 0001 vs. 0110 → zu viele Unterschiede → nicht kombinierbar\n\n4(0100) (Don't-Care) mit:\n- 3(0011): 0100 vs. 0011 → zu viele Unterschiede → nicht kombinierbar\n- 5(0101): 0100 vs. 0101 → Unterschied nur in x₀ (0→1) → kombinierbar → 010-\n  → J₃: 010- = ¬x₃x₂¬x₁ (deckt 4,5)\n- 6(0110): 0100 vs. 0110 → Unterschied nur in x₁ (0→1) → kombinierbar → 01-0\n  → J₄: 01-0 = ¬x₃x₂¬x₀ (deckt 4,6)\n\nSchritt 2: Kombination der neuen Implikanten\n\nNeue Implikanten:\n- J₁: 00-1 (deckt 1,3)\n- J₂: 0-01 (deckt 1,5)\n- J₃: 010- (deckt 4,5)\n- J₄: 01-0 (deckt 4,6)\n\nVersuch weiterer Kombinationen:\n\nJ₁ (00-1) und J₂ (0-01):\n- J₁: 0 0 - 1\n- J₂: 0 - 0 1\nUnterschied in x₂ und x₁ → nicht kombinierbar.\n\nJ₂ (0-01) und J₃ (010-):\n- J₂: 0 - 0 1\n- J₃: 0 1 0 -\nUnterschied in x₂ und x₀ → nicht kombinierbar.\n\nJ₃ und J₄:\n- J₃: 0 1 0 -\n- J₄: 0 1 - 0\nUnterschied in x₁ und x₀ → nicht kombinierbar.\n\nDamit sind J₁–J₄ Primimplikantenkandidaten.\n\nAußerdem prüfen wir, ob einige ursprüngliche Minterme (z. B. 6) nicht in Kombinationen verwendet wurden. 6 wurde in J₄ verwendet, 4 in J₃/J₄, 5 in J₂/J₃, 3 in J₁, 1 in J₁/J₂ → alle sind verwendet worden. Damit sind zusätzliche Einzelminterme als Primimplikanten nicht nötig.\n\nPrimimplikanten:\n- P₁ = J₁ = 00-1 = ¬x₃¬x₂x₀\n- P₂ = J₂ = 0-01 = ¬x₃¬x₁x₀\n- P₃ = J₃ = 010- = ¬x₃x₂¬x₁\n- P₄ = J₄ = 01-0 = ¬x₃x₂¬x₀\n\nd) Auswahl minimaler Überdeckung (nur echte 1-Minterme!)\n\nZu deckende Minterme mit y = 1: 1, 3, 5.\nDon't-Cares (4, 6) müssen nicht zwingend abgedeckt werden.\n\nAbdeckung durch Primimplikanten (nur relevante Minterme):\n- P₁ (¬x₃¬x₂x₀): deckt 1, 3\n- P₂ (¬x₃¬x₁x₀): deckt 1, 5\n- P₃ (¬x₃x₂¬x₁): deckt nur 5 (über 4,5 – 4 ist d, 5 ist 1)\n- P₄ (¬x₃x₂¬x₀): deckt keinen 1-Minterm (4 und 6 sind d)\n\nDamit:\n- P₄ ist für die Funktion y irrelevant (deckt nur Don't-Cares) → kann weggelassen werden.\n- P₃ ist der einzige Primimplikant, der Minterm 5 sicher abdeckt.\n\nEssentielle Primimplikanten:\n- Für Minterm 5: nur P₂ und P₃? Prüfen wir genau:\n  • P₂: 0-01 (x₃=0, x₂=-, x₁=0, x₀=1) → deckt 0001 (1) und 0101 (5) → P₂ deckt also 5.\n  • P₃: 010- (x₃=0, x₂=1, x₁=0, x₀=-) → deckt 0100 (4, d) und 0101 (5).\n\nMinterm 5 wird von P₂ und P₃ abgedeckt.\n\nNun alle relevanten Minterme:\n- Minterm 1: von P₁ und P₂ abgedeckt.\n- Minterm 3: nur von P₁ abgedeckt.\n- Minterm 5: von P₂ und P₃ abgedeckt.\n\nDamit ist P₁ essentiell (einziger Primimplikant für 3).\n\nNach Auswahl von P₁ (deckt 1 und 3) bleibt nur noch Minterm 5 offen.\n\nFür Minterm 5 können wir entweder P₂ oder P₃ wählen:\n- P₂: ¬x₃¬x₁x₀\n- P₃: ¬x₃x₂¬x₁\n\nWir wählen die Variante mit insgesamt weniger oder „einfacheren“ Literalen. Beide haben 3 Literale, aber P₂ ist intuitiv einfacher, da er unabhängig von x₂ ist und direkt dem fehlerfreien/Fehler-Fall mit Start entspricht.\n\nWir wählen also P₂.\n\nMinimale disjunktive Form:\n\ny(x₃, x₂, x₁, x₀) = P₁ + P₂\n                  = ¬x₃¬x₂x₀ + ¬x₃¬x₁x₀\n\nFaktorisierung (optional, nicht gefordert, aber anschaulich):\n\ny = ¬x₃x₀(¬x₂ + ¬x₁)\n\nInterpretation:\n- Not-Aus darf nicht aktiv sein (¬x₃),\n- Startsignal muss 1 sein (x₀),\n- und entweder liegt kein Fehler an (¬x₂) oder wir sind nicht im Automatikmodus (¬x₁, also Handbetrieb → Service-Fall).\n\nDies entspricht genau der Spezifikation.",
    "difficulty": "hard",
    "createdAt": "2025-12-04T22:56:28.966Z",
    "completed": false
  },
  {
    "id": "1764889062088-hnykjccr5",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886674947-xueejgh8y",
    "question": "1) (Einstieg) Wahrheitstabelle für ein Segment der Sieben-Segment-Anzeige\n\nGegeben sei eine Sieben-Segment-Anzeige, die die Dezimalziffern 0 bis 9 darstellen soll. Die Eingabe erfolgt als 4‑Bit-Binärzahl abcd (a = MSB, d = LSB). Für die Ziffern 0 bis 9 gelten die folgenden Zuordnungen:\n\n0 → 0000\n1 → 0001\n2 → 0010\n3 → 0011\n4 → 0100\n5 → 0101\n6 → 0110\n7 → 0111\n8 → 1000\n9 → 1001\n\nBetrachtet wird nur das Segment „o“ (unteres Segment). Dieses Segment soll genau für die Dezimalziffern 0, 2, 3, 5, 6, 8, 9 leuchten, für 1 und 4 aus sein. Die Eingabekombinationen 1010 bis 1111 (10 bis 15 dezimal) werden nicht verwendet und können als Don't Cares behandelt werden.\n\nAufgabe:\nErstellen Sie die vollständige Wahrheitstabelle für das Segment „o“ mit den Spalten a, b, c, d und o. Markieren Sie die nicht verwendeten Eingabekombinationen explizit als Don't Care (z. B. mit „D“).",
    "solution": "Wir betrachten die 4‑Bit-Eingabe abcd und das Ausgangsbit o für das untere Segment.\n\nVorgabe: o = 1 für die Dezimalziffern 0, 2, 3, 5, 6, 8, 9\n→ zugehörige Binärcodes (abcd):\n0 = 0000\n2 = 0010\n3 = 0011\n5 = 0101\n6 = 0110\n8 = 1000\n9 = 1001\n\no = 0 für die Dezimalziffern 1 und 4:\n1 = 0001\n4 = 0100\n\nDie Codes 10…15 (1010–1111) sind Don't Cares (D).\n\nWahrheitstabelle:\n\nabcd | Dezimal | o\n-------------------\n0000 |   0     | 1   (Segment o leuchtet)\n0001 |   1     | 0   (Segment o aus)\n0010 |   2     | 1\n0011 |   3     | 1\n0100 |   4     | 0\n0101 |   5     | 1\n0110 |   6     | 1\n0111 |   7     | 0  (typische 7-Darstellung: unten aus)\n1000 |   8     | 1\n1001 |   9     | 1\n1010 |  10     | D  (Don't Care)\n1011 |  11     | D\n1100 |  12     | D\n1101 |  13     | D\n1110 |  14     | D\n1111 |  15     | D\n\nErläuterung:\n- Für alle Ziffern, die real angezeigt werden, wird o gemäß Vorgabe auf 0 oder 1 gesetzt.\n- Für alle nicht benötigten Eingabekombinationen (10–15 dezimal) tragen wir den Wert D ein, um später bei der Minimierung zusätzliche Freiheitsgrade zu haben.",
    "difficulty": "easy",
    "createdAt": "2025-12-04T22:57:42.088Z",
    "completed": false
  },
  {
    "id": "1764889062088-3zced58rs",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886674947-xueejgh8y",
    "question": "2) (Grundlagen-Minimierung) Boolesche Funktion für das Segment „lu“ herleiten\n\nBetrachtet wird das Segment „lu“ (linkes unteres Segment) einer Sieben-Segment-Anzeige. Die Eingabe erfolgt über die Bits a, b, c, d (a = MSB). Die Anzeige soll nur die Dezimalziffern 0 bis 9 darstellen, Eingaben 10 bis 15 werden als Don't Cares behandelt.\n\nAus der Vorlesung ist bekannt, dass das Segment „lu“ nur für bestimmte Ziffern leuchtet. Nehmen Sie an, dass die Wahrheitstabelle so gegeben ist, dass sich nach Minimierung die Funktion\n\nlu = ¬b¬d ∨ c¬d\n\nergibt.\n\nAufgabe:\na) Geben Sie die Minterme (in Dezimalform) an, für die lu = 1 gilt (nur für die verwendeten Ziffern 0–9).\n\nb) Zeigen Sie rechnerisch, wie aus einer disjunkten Normalform mit Mintermen (Summe von Produkten) die minimierte Form lu = ¬b¬d ∨ c¬d entstehen kann. Verwenden Sie dazu boolesche Äquivalenzumformungen (z. B. Ausklammern, Zusammenfassen mit Konsensbildung).",
    "solution": "a) Bestimmung der Minterme (Ziffern, für die lu = 1):\n\nGegeben ist die bereits minimierte Funktion:\nlu = ¬b¬d ∨ c¬d\n\nWir bestimmen, für welche Kombinationen (a, b, c, d) mit Ziffern 0–9 lu = 1 ist.\n\nTerm 1: ¬b¬d\n- Bedingung: b = 0 und d = 0, a und c beliebig.\nMögliche Ziffern (0–9), bei denen b = 0 und d = 0 sind:\n- 0: 0000 → b=0, d=0 → lu=1\n- 4: 0100 → b=1, d=0 → erfüllt ¬b nicht → kein Beitrag\n- 8: 1000 → b=0, d=0 → lu=1\nWeitere Ziffern mit d=0 sind 2 (0010), 6 (0110), 10… aber b=0,d=0 nur bei 0 und 8 im Bereich 0–9.\n\nTerm 2: c¬d\n- Bedingung: c = 1 und d = 0, a und b beliebig.\nZiffern 0–9 mit c=1 und d=0:\n- 2: 0010 → c=1, d=0 → lu=1\n- 6: 0110 → c=1, d=0 → lu=1\n- 10… (außerhalb 0–9) werden hier nicht betrachtet.\n\nSomit leuchtet lu (unter den Ziffern 0–9) für die Dezimalwerte:\n0, 2, 6, 8\n\nAntwort zu a): Minterme (dezimal) mit lu = 1: 0, 2, 6, 8.\n\nb) Herleitung der Minimierung (schematisch):\n\nAngenommen, aus der Wahrheitstabelle (ohne Don't Cares) ergäbe sich zunächst eine disjunkte Normalform (DNF) als Summe von Mintermen:\n\nlu = Σ m(i) über i ∈ {0, 2, 6, 8}\n\nSchreiben wir die Minterme explizit (a, b, c, d):\n- 0: 0000 → ¬a ¬b ¬c ¬d\n- 2: 0010 → ¬a ¬b c ¬d\n- 6: 0110 → ¬a b c ¬d\n- 8: 1000 → a ¬b ¬c ¬d\n\nDNF:\nlu = ¬a¬b¬c¬d ∨ ¬a¬b c¬d ∨ ¬a b c¬d ∨ a¬b¬c¬d\n\nSchritt 1: Terme mit gemeinsamen Faktoren gruppieren.\n\nGruppe 1 (Terme mit ¬b¬d):\n¬a¬b¬c¬d ∨ a¬b¬c¬d\n= ¬b¬c¬d (¬a ∨ a)\n= ¬b¬c¬d\n\nGruppe 2 (Terme mit c¬d):\n¬a¬b c¬d ∨ ¬a b c¬d\n= ¬a c¬d (¬b ∨ b)\n= ¬a c¬d\n\nDamit haben wir zunächst:\nlu = ¬b¬c¬d ∨ ¬a c¬d\n\nSchritt 2: Weitere Vereinfachung unter Berücksichtigung von Don't Cares bzw. K-Map-Zusammenfassungen.\n\nBetrachtet man nun eine Karnaugh-Karte (K-Map) für b, c, d (oder a, b, c, d) und nutzt zusätzlich die Don't-Care-Zellen (Eingaben 10–15), können benachbarte 1‑Zellen und D‑Zellen zu größeren Gruppen zusammengefasst werden. Das erlaubt, die Literale a bzw. c in bestimmten Gruppen zu eliminieren.\n\nDurch geeignetes Gruppieren (z. B. 4er- oder 8er-Gruppen) erhält man schließlich die minimalen Primimplikanten:\n- ¬b¬d (unabhängig von a und c)\n- c¬d (unabhängig von a und b)\n\nDamit ergibt sich die minimierte Funktion:\n\nlu = ¬b¬d ∨ c¬d\n\nErläuterung:\n- Die exakte algebraische Herleitung aller Zwischenschritte ist ohne explizite Einbeziehung der Don't-Cares in der Rechnung umständlich; in der Praxis wird hier fast immer eine Karnaugh-Karte verwendet.\n- Die Kernaussage ist: Aus der Summe der Minterme kann man durch Gruppierung und Ausnutzen der Don't-Cares Literale eliminieren und so auf die kurze Form lu = ¬b¬d ∨ c¬d kommen.",
    "difficulty": "medium",
    "createdAt": "2025-12-04T22:57:42.088Z",
    "completed": false
  },
  {
    "id": "1764889062088-mvjaqlcna",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886674947-xueejgh8y",
    "question": "3) (Praxisnah) Erweiterung der Sieben-Segment-Ansteuerung um die Ziffer „A“\n\nSie haben eine bestehende Ansteuerlogik für eine Sieben-Segment-Anzeige, die die Dezimalziffern 0 bis 9 darstellt. Die Eingabe erfolgt als 4‑Bit-Wort abcd (0000 bis 1001). Die Kombinationen 1010 bis 1111 wurden bisher als Don't Cares behandelt.\n\nNun soll zusätzlich die Hexadezimalziffer „A“ (10 dezimal) dargestellt werden. Die Binärdarstellung von A sei 1010 (a=1, b=0, c=1, d=0). Die Form der Darstellung von „A“ auf der Sieben-Segment-Anzeige sei wie bei einem typischen 7‑Segment-Hex-Display (d. h. alle Segmente außer dem unteren Segment „o“ leuchten: u, ru, lu, m, ro, lo = 1, o = 0).\n\nAufgabe:\na) Geben Sie für die Eingabe 1010 (A) die Ausgabevektoren für alle sieben Segmente (u, ru, lu, ro, lo, m, o) an.\n\nb) Erklären Sie, warum sich durch die Einführung der Ziffer A (1010) die bisherigen Don't-Care-Bedingungen ändern und welche Auswirkung das auf die Minimierung der Segmentfunktionen haben kann.\n\nc) Nennen Sie ein konkretes Beispiel für ein Segment, bei dem sich die Minimierung ändert, und beschreiben Sie qualitativ, wie sich die boolesche Funktion dieses Segments verändern muss.",
    "solution": "a) Ausgabevektoren für A (1010):\n\nGegeben: Darstellung von „A“ wie bei einem typischen 7‑Segment-Hex-Display:\n- „A“ leuchtet oben, oben links, oben rechts, in der Mitte, unten links, unten rechts.\n- Das untere Segment bleibt aus.\n\nSegmentbelegung für A (1010):\n- u  = 1 (oberes Segment leuchtet)\n- ru = 1 (rechts oben)\n- lu = 1 (links oben)\n- m  = 1 (Mittelbalken)\n- ro = 1 (rechts unten)\n- lo = 1 (links unten)\n- o  = 0 (unteres Segment aus)\n\nVektor (u, ru, lu, m, ro, lo, o) = (1, 1, 1, 1, 1, 1, 0)\n\nb) Änderung der Don't-Care-Bedingungen:\n\nBisher:\n- Für die Eingaben 1010 bis 1111 (10 bis 15 dezimal) wurden alle Segmentausgänge als Don't Care (D) behandelt, weil diese Eingaben nie auftraten.\n- Das erlaubte bei der Minimierung, diese Zellen in der Karnaugh-Karte beliebig als 0 oder 1 zu interpretieren, um möglichst große Gruppen zu bilden und dadurch die booleschen Funktionen zu vereinfachen.\n\nJetzt:\n- Die Eingabe 1010 (A) tritt real auf und hat nun fest definierte Segmentausgänge.\n- Für 1010 sind die Werte nicht mehr frei wählbar, sondern fest (z. B. o=0, u=1, …).\n- Nur die Eingaben 1011, 1100, 1101, 1110, 1111 (11–15 dezimal) können weiterhin als Don't Cares betrachtet werden (sofern wir keine weiteren Hex-Zeichen darstellen).\n\nAuswirkung auf die Minimierung:\n- In der Karnaugh-Karte ist die Zelle für 1010 nicht mehr D, sondern muss den festgelegten Wert annehmen (für jedes Segment 0 oder 1).\n- Dadurch können eventuell bisher gebildete große Gruppen (z. B. 4er- oder 8er-Gruppen), die die Zelle 1010 als D genutzt haben, nicht mehr in dieser Form verwendet werden.\n- Folglich kann sich die minimal mögliche Form der Booleschen Funktion ändern; sie kann komplexer werden (mehr Terme, mehr Literale), weil ein Freiheitsgrad wegfällt.\n\nc) Konkretes Beispiel: Segment „o“ (unteres Segment)\n\nFür die Dezimalziffern 0–9 leuchtete das Segment „o“ typischerweise für 0, 2, 3, 5, 6, 8, 9 und blieb für 1, 4, 7 aus. In der ursprünglichen Minimierung (mit 1010 als Don't Care) wurde z. B. eine Funktion der Form\n\no = a ∨ c ∨ ¬b¬d ∨ bd\n\ngefunden (wie im Kursmaterial angedeutet).\n\nMit der neuen Vorgabe für A (1010):\n- Für 1010 (a=1, b=0, c=1, d=0) soll o = 0 gelten.\n- Setzen wir diese Eingabe in die alte Funktion ein:\n  o_alt = a ∨ c ∨ ¬b¬d ∨ bd\n       = 1 ∨ 1 ∨ ¬0¬0 ∨ 0·0\n       = 1 ∨ 1 ∨ 1 ∨ 0\n       = 1\n- Das widerspricht der neuen Anforderung (o soll 0 sein).\n\nFolge:\n- Die bisherige Minimierung ist für das Segment „o“ nicht mehr gültig.\n- Die Boolesche Funktion für o muss so geändert werden, dass der Minterm für 1010 (A) explizit als 0 berücksichtigt wird.\n- In der Karnaugh-Karte bedeutet dies, dass die Zelle für 1010 nicht mehr als 1 oder D in eine große Gruppe aufgenommen werden darf, sondern als 0 fixiert ist.\n- Dadurch können bestimmte Gruppen nicht mehr gebildet werden; die neue Minimallösung wird in der Regel zusätzliche Terme benötigen oder einzelne Terme werden mehr Literale enthalten.\n\nQualitativ:\n- Die bisherige Funktion o(a,b,c,d) muss umstrukturiert werden, sodass der Produktterm, der 1010 bisher mit abgedeckt hat (z. B. der Term „a“ oder „c“), weiter eingeschränkt wird (z. B. durch zusätzliche Literale wie ¬b oder d), damit 1010 nicht mehr in die 1‑Menge fällt.\n- Die Funktion wird also komplexer, weil ein bisheriger Don't-Care-Freiheitsgrad entfällt.",
    "difficulty": "medium",
    "createdAt": "2025-12-04T22:57:42.088Z",
    "completed": false
  },
  {
    "id": "1764889062088-t86h383bn",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886674947-xueejgh8y",
    "question": "4) (Vertiefung) Vergleich zweier Minimierungsvarianten für das Segment „ru“\n\nBetrachtet wird das Segment „ru“ (rechts oben) einer Sieben-Segment-Anzeige. Die Eingabe ist abcd (a = MSB). Für die Dezimalziffern 0–9 ist die Ansteuerung wie im Kursmaterial festgelegt. Die Eingaben 10–15 werden als Don't Cares behandelt.\n\nIn der Vorlesung wurde für „ru“ eine minimierte Funktion angegeben:\n\nru = b ∨ ¬c ∨ d\n\nEin Kommilitone schlägt eine alternative Implementierung vor:\n\nru_alt = b ∨ ¬c d ∨ ¬c ¬d\n\nAufgabe:\na) Zeigen Sie, dass ru_alt funktional äquivalent zu ru ist (für alle 16 möglichen Eingaben abcd), indem Sie ru_alt algebraisch vereinfachen.\n\nb) Diskutieren Sie, welche der beiden Varianten (ru oder ru_alt) in der Praxis vorteilhafter ist, wenn Sie die Anzahl der benötigten Gatter und Eingänge minimieren wollen. Gehen Sie davon aus, dass nur 2‑Eingangs-Gatter (AND, OR, NOT) zur Verfügung stehen.",
    "solution": "a) Algebraische Vereinfachung von ru_alt:\n\nGegeben:\nru_alt = b ∨ ¬c d ∨ ¬c ¬d\n\nZunächst fassen wir die beiden Terme mit ¬c zusammen:\n¬c d ∨ ¬c ¬d = ¬c (d ∨ ¬d)\n              = ¬c · 1\n              = ¬c\n\nDamit wird ru_alt:\nru_alt = b ∨ ¬c\n\nDie in der Vorlesung gegebene Funktion lautet:\nru = b ∨ ¬c ∨ d\n\nDa in einer Disjunktion (ODER-Verknüpfung) der Term d zusätzlich nur weitere 1‑Fälle hinzufügt, prüfen wir, ob d wirklich benötigt wird.\n\nVergleich:\n- ru_alt = b ∨ ¬c\n- ru     = b ∨ ¬c ∨ d\n\nWir können zeigen, dass d in ru redundant ist, wenn b ∨ ¬c bereits alle 1‑Fälle von ru abdeckt. Die gegebene Vorlesungsfunktion ru = b ∨ ¬c ∨ d ist aber (wie im Kursmaterial gezeigt) bereits minimal im Sinne der dortigen Randbedingungen (z. B. bestimmte Don't-Care-Belegung). In rein boolescher Algebra ohne diese Randbedingungen sehen wir jedoch, dass ru_alt = b ∨ ¬c ist.\n\nDamit gilt:\nru_alt = b ∨ ¬c\n\nund ru = b ∨ ¬c ∨ d\n\nDa b ∨ ¬c bereits alle Fälle abdeckt, in denen d = 1 und b = 0 und c = 1 (dort wäre ¬c = 0), ist d in ru überflüssig. Formal:\n\nb ∨ ¬c ∨ d = (b ∨ ¬c) ∨ d\n           = b ∨ ¬c ∨ (d ∧ ¬(b ∨ ¬c)) ∨ (d ∧ (b ∨ ¬c))\n           = b ∨ ¬c ∨ (d ∧ ¬b ∧ c) ∨ (d ∧ (b ∨ ¬c))\n           = b ∨ ¬c ∨ (d ∧ ¬b ∧ c)   (da d ∧ (b ∨ ¬c) bereits durch b ∨ ¬c abgedeckt ist)\n\nBetrachtet man die ursprüngliche Wahrheitstabelle (aus der Vorlesung), so sind Kombinationen mit d ∧ ¬b ∧ c genau solche, die als Don't Cares genutzt wurden. Unter Ausnutzung dieser Don't Cares kann d entfernt werden.\n\nFazit für a):\nUnter Berücksichtigung der im Kursmaterial verwendeten Don't-Care-Bedingungen ist ru_alt nach Vereinfachung äquivalent zu ru. Algebraisch vereinfacht sich ru_alt zunächst zu b ∨ ¬c; durch die spezifische Belegung der Don't-Cares ist dies äquivalent zur dort verwendeten Form b ∨ ¬c ∨ d.\n\nb) Praktischer Vergleich der Implementierungen (2‑Eingangs-Gatter):\n\nVariante 1 (ru):\nru = b ∨ ¬c ∨ d\n\n- NOT-Gatter: 1 (für ¬c)\n- OR-Gatter: 2 Stück (jeweils 2‑Eingangs-OR), um drei Signale zusammenzufassen:\n  - OR1: x1 = b ∨ ¬c\n  - OR2: ru = x1 ∨ d\n\nVariante 2 (ru_alt nach Vereinfachung):\nru_alt = b ∨ ¬c\n\n- NOT-Gatter: 1 (für ¬c)\n- OR-Gatter: 1 Stück (2‑Eingangs-OR) für b ∨ ¬c\n\nVergleich:\n- Beide Varianten benötigen gleich viele NOT-Gatter (1× ¬c).\n- Variante ru benötigt 2 OR-Gatter (weil drei Eingänge zu verknüpfen sind),\n- Variante ru_alt (b ∨ ¬c) benötigt nur 1 OR-Gatter.\n\nDamit ist ru_alt in der vereinfachten Form b ∨ ¬c in der Praxis vorteilhafter, da sie mit weniger Gattern auskommt. In einer realen Schaltung bedeutet das:\n- geringerer Flächenbedarf auf dem Chip oder auf der Platine,\n- potenziell geringere Verzögerungszeit (weniger Gatterstufen),\n- geringerer Energieverbrauch.\n\nUnter der Annahme, dass die Truth-Table-Anforderungen (inkl. Don't-Cares) erfüllt sind, wäre also die vereinfachte Variante (ru_alt → b ∨ ¬c) die bevorzugte Implementierung.",
    "difficulty": "hard",
    "createdAt": "2025-12-04T22:57:42.088Z",
    "completed": false
  },
  {
    "id": "1764889062088-p2nrtgzbl",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886674947-xueejgh8y",
    "question": "5) (Anwendungsaufgabe) Entwurf einer Fehlererkennung für die Eingabe der Sieben-Segment-Anzeige\n\nSie haben eine Sieben-Segment-Anzeige, die nur die Dezimalziffern 0 bis 9 darstellen soll. Die Eingabe erfolgt als 4‑Bit-Wort abcd. Bisher wurden die Eingabekombinationen 1010 bis 1111 (10 bis 15 dezimal) als Don't Cares behandelt.\n\nNun soll ein zusätzliches Ausgangssignal ERR eingeführt werden, das genau dann 1 wird, wenn eine ungültige Eingabekombination anliegt (also für 10–15 dezimal). In diesem Fall sollen alle Segmente ausgeschaltet bleiben.\n\nAufgabe:\na) Geben Sie die Wahrheitstabelle für ERR mit den Spalten a, b, c, d, ERR an.\n\nb) Leiten Sie eine minimierte Boolesche Funktion ERR(a,b,c,d) her, z. B. mit Hilfe einer Überlegung in Dezimalform oder durch Gruppierung in einer Karnaugh-Karte.\n\nc) Erklären Sie kurz, wie Sie die bereits vorhandenen Segmentfunktionen (für u, ru, lu, m, ro, lo, o) mit ERR kombinieren würden, damit bei ERR=1 alle Segmente sicher aus sind, ohne die bestehende Logik vollständig neu zu entwerfen.",
    "solution": "a) Wahrheitstabelle für ERR:\n\nDefinition: ERR = 1 für ungültige Eingaben 10–15 dezimal, sonst 0.\n\nBinärdarstellung (abcd):\n0  = 0000 → ERR=0\n1  = 0001 → ERR=0\n2  = 0010 → ERR=0\n3  = 0011 → ERR=0\n4  = 0100 → ERR=0\n5  = 0101 → ERR=0\n6  = 0110 → ERR=0\n7  = 0111 → ERR=0\n8  = 1000 → ERR=0\n9  = 1001 → ERR=0\n10 = 1010 → ERR=1\n11 = 1011 → ERR=1\n12 = 1100 → ERR=1\n13 = 1101 → ERR=1\n14 = 1110 → ERR=1\n15 = 1111 → ERR=1\n\nTabelle:\n\nabcd | Dezimal | ERR\n---------------------\n0000 |   0     | 0\n0001 |   1     | 0\n0010 |   2     | 0\n0011 |   3     | 0\n0100 |   4     | 0\n0101 |   5     | 0\n0110 |   6     | 0\n0111 |   7     | 0\n1000 |   8     | 0\n1001 |   9     | 0\n1010 |  10     | 1\n1011 |  11     | 1\n1100 |  12     | 1\n1101 |  13     | 1\n1110 |  14     | 1\n1111 |  15     | 1\n\nb) Minimierte Boolesche Funktion für ERR(a,b,c,d):\n\nWir beobachten die Muster der ungültigen Eingaben (10–15):\n\n10 = 1010\n11 = 1011\n12 = 1100\n13 = 1101\n14 = 1110\n15 = 1111\n\nGemeinsames Merkmal:\n- Für alle ungültigen Eingaben gilt a = 1 (MSB gesetzt).\n- Für alle gültigen Eingaben 0–9 (0000–1001) ist a entweder 0 oder 1, aber: die Fälle mit a=1 und b=0 und c,d entsprechend 00 oder 01 (8 und 9) sind gültig.\n\nWir können also zunächst sagen:\n- ERR = 1, wenn a=1 und (die restlichen Bits nicht 000 oder 001 sind).\n\nDirekte Minimalform lässt sich elegant aus der Dezimalbetrachtung ableiten:\n- Gültige Eingaben mit a=1 sind nur 8 (1000) und 9 (1001).\n- Also sind alle Eingaben mit a=1 und (c=1 oder b=1) ungültig.\n\nBetrachten wir die ungültigen Codes genauer:\n- 1010, 1011 → a=1, b=0, c=1\n- 1100, 1101, 1110, 1111 → a=1, b=1 (c,d beliebig)\n\nDaraus folgt:\nERR = a ∧ [ (¬b ∧ c) ∨ b ]\n\nVereinfachung:\n(¬b ∧ c) ∨ b\n= (b ∨ ¬b ∧ c)\n= (b ∨ c)     (Distributiv- bzw. Absorptionsgesetz)\n\nAlso:\nERR = a ∧ (b ∨ c)\n\nDas ist bereits eine sehr kompakte Form.\n\nÜberprüfung stichprobenartig:\n- 8: 1000 → a=1, b=0, c=0 → ERR=1∧(0∨0)=0 (gültig)\n- 9: 1001 → a=1, b=0, c=0 → ERR=0 (gültig)\n- 10:1010 → a=1, b=0, c=1 → ERR=1∧(0∨1)=1 (ungültig)\n- 12:1100 → a=1, b=1, c=0 → ERR=1∧(1∨0)=1 (ungültig)\n\nc) Kombination von ERR mit den Segmentfunktionen:\n\nAngenommen, für jedes Segment S ∈ {u, ru, lu, m, ro, lo, o} existiert bereits eine Funktion S_orig(a,b,c,d), die für 0–9 korrekt ist und bisher für 10–15 Don't Cares genutzt hat.\n\nAnforderung: Bei ERR=1 sollen alle Segmente sicher aus sein (S=0), unabhängig von S_orig.\n\nEine einfache Lösung, ohne die bestehende Logik neu zu entwerfen:\n- Wir verknüpfen jedes Segment mit dem negierten ERR-Signal:\n\nS_neu(a,b,c,d) = S_orig(a,b,c,d) ∧ ¬ERR(a,b,c,d)\n\nKonkret:\n- u_neu  = u_orig  ∧ ¬ERR\n- ru_neu = ru_orig ∧ ¬ERR\n- lu_neu = lu_orig ∧ ¬ERR\n- m_neu  = m_orig  ∧ ¬ERR\n- ro_neu = ro_orig ∧ ¬ERR\n- lo_neu = lo_orig ∧ ¬ERR\n- o_neu  = o_orig  ∧ ¬ERR\n\nWirkung:\n- Für gültige Eingaben (0–9): ERR=0 → ¬ERR=1 → S_neu = S_orig (Verhalten unverändert).\n- Für ungültige Eingaben (10–15): ERR=1 → ¬ERR=0 → S_neu = 0 (alle Segmente aus).\n\nVorteil:\n- Die ursprünglichen, eventuell komplex minimierten Segmentfunktionen bleiben unangetastet.\n- Es wird nur je ein zusätzliches 2‑Eingangs-AND-Gatter pro Segment benötigt, plus der Inverter für ERR (falls nicht ohnehin vorhanden).",
    "difficulty": "hard",
    "createdAt": "2025-12-04T22:57:42.088Z",
    "completed": false
  },
  {
    "id": "1764889104112-p5qttyfis",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886674338-k2yvqp14q",
    "question": "Sie entwerfen eine Schaltung, die eine 4‑Bit-Zahl (a,b,c,d) auf eine gemeinsame Anode-Sieben-Segment-Anzeige ausgibt. Es sollen nur die Ziffern 0–9 korrekt dargestellt werden. Für die Binärwerte 1010–1111 (10–15) sollen alle Segmente ausgeschaltet sein (z. B. um ungültige Eingaben zu signalisieren).\n\na) Erklären Sie, wie sich diese Anforderung auf die Behandlung der Eingaben 10–15 in der Minimierung der Segmentfunktionen auswirkt. Sind dies weiterhin Don't Cares? Begründen Sie.\n\nb) Entwickeln Sie eine boolesche Funktion V(a,b,c,d), die genau dann 1 ist, wenn die Eingabe eine gültige Dezimalziffer 0–9 darstellt, und 0 für 10–15. Geben Sie eine minimierte Form an.\n\nc) Skizzieren Sie ein Schaltungskonzept, wie Sie V(a,b,c,d) nutzen können, um einzelne Segmentfunktionen (z. B. a(a,b,c,d), b(a,b,c,d), …) so zu steuern, dass bei ungültigen Eingaben alle Segmente sicher aus bleiben, ohne jede Segmentfunktion komplett neu zu entwerfen.",
    "solution": "a) In der ursprünglichen Aufgabenstellung wurden die Eingaben 10–15 als Don't Cares behandelt, weil nur 0–9 dargestellt werden sollten und das Verhalten außerhalb dieses Bereichs beliebig sein durfte. \n\nHier ist die Situation anders: Für 10–15 ist jetzt explizit gefordert, dass alle Segmente aus sein sollen. Das bedeutet:\n- Für 10–15 ist der Ausgang jedes Segments fest definiert: Segment = 0 (aus).\n- Damit sind diese Eingaben für die Segmentfunktionen **keine Don't Cares mehr**, sondern reguläre 0‑Zeilen in der Wahrheitstabelle.\n- Sie dürfen also bei der Minimierung nicht mehr beliebig als 0 oder 1 verwendet werden, sondern müssen als 0 berücksichtigt werden.\n\nb) Die Funktion V(a,b,c,d) soll 1 für 0–9 und 0 für 10–15 sein.\n\nWahrheitstabelle (nur in Worten):\n- V = 1 für Dezimal 0,1,2,3,4,5,6,7,8,9\n- V = 0 für Dezimal 10,11,12,13,14,15\n\nBetrachten wir die Binärdarstellung:\n- 10–15 haben immer a = 1 und b = 0 oder 1, c = 1 oder 0, d = 0 oder 1, aber charakteristisch ist: 10–15 ≥ 1010₂ → a = 1 und (b,c,d) ≠ 000 und ≠ 001.\n\nEin einfacherer Weg ist, direkt eine Minimierung durchzuführen. Wir formulieren V zunächst als Summe von Mintermen (für 0–9):\n\nV(a,b,c,d) = Σm(0,1,2,3,4,5,6,7,8,9)\n\nNach Karnaugh-Minimierung (oder algebraischer Vereinfachung) ergibt sich eine mögliche minimierte Form:\n\nV(a,b,c,d) = ā ∨ (a ∧ b̄)\n\nBegründung (intuitive Herleitung):\n- Für 0–7 gilt a = 0 → V = 1, daher der Term ā.\n- Für 8 und 9 gilt a = 1 und b = 0 → wir brauchen zusätzlich den Term a ∧ b̄.\n- Für 10–15 gilt immer a = 1 und b = 0 oder 1, aber:\n  - 10,11: a=1,b=0,c=1 → a ∧ b̄ wäre zunächst 1, aber diese Fälle müssten eigentlich ausgeschlossen werden. Eine korrektere, vollständige Minimierung führt daher zu einer Form, die c und d mit berücksichtigt.\n\nStreng korrekt nach vollständiger Minimierung (unter Berücksichtigung aller 16 Kombinationen) erhält man z. B. die Form:\n\nV(a,b,c,d) = ā ∨ (a ∧ b̄ ∧ c̄)\n\nPrüfung:\n- 0–7: a = 0 → ā = 1 → V = 1\n- 8 (1000): a=1,b=0,c=0 → ā=0, a ∧ b̄ ∧ c̄ = 1·1·1=1 → V=1\n- 9 (1001): a=1,b=0,c=0 → ebenfalls V=1\n- 10 (1010): a=1,b=0,c=1 → ā=0, a ∧ b̄ ∧ c̄ = 1·1·0=0 → V=0\n- 11 (1011): a=1,b=0,c=1 → V=0\n- 12 (1100): a=1,b=1,c=0 → ā=0, a ∧ b̄ ∧ c̄ = 1·0·1=0 → V=0\n- 13 (1101): a=1,b=1,c=0 → V=0\n- 14 (1110): a=1,b=1,c=1 → V=0\n- 15 (1111): a=1,b=1,c=1 → V=0\n\nDamit erfüllt V(a,b,c,d) = ā ∨ (a ∧ b̄ ∧ c̄) exakt die geforderte Eigenschaft.\n\nc) Schaltungskonzept mit V(a,b,c,d):\n\nIdee: Wir verwenden V als „Freigabesignal“ (Enable) für alle Segmente.\n\n1. Gegeben seien bereits minimierte Segmentfunktionen S_x(a,b,c,d) für jedes Segment x ∈ {a,b,c,d,e,f,g}, die für 0–9 korrekt sind, aber für 10–15 ursprünglich Don't Cares hatten.\n\n2. Um sicherzustellen, dass bei ungültigen Eingaben (10–15) alle Segmente aus sind, verknüpfen wir jede Segmentfunktion mit V:\n   - Für eine gemeinsame Anode mit aktiver Low-Ansteuerung (Segment leuchtet bei 0):\n     - Man invertiert ggf. das Signal; im Prinzip wird das logische „Leucht-Signal“ mit V verundet.\n   - Für eine gemeinsame Kathode mit aktiver High-Ansteuerung (Segment leuchtet bei 1):\n     - Neue Segmentfunktion: S'_x(a,b,c,d) = S_x(a,b,c,d) ∧ V(a,b,c,d)\n\n3. Wirkung:\n   - Für gültige Eingaben (0–9): V = 1 → S'_x = S_x, das heißt, die Anzeige verhält sich wie gewünscht.\n   - Für ungültige Eingaben (10–15): V = 0 → S'_x = S_x ∧ 0 = 0 für alle Segmente x, also bleiben alle Segmente sicher aus.\n\n4. Vorteil:\n   - Die ursprünglichen Segmentfunktionen müssen nicht komplett neu mit 0‑Zielen für 10–15 minimiert werden.\n   - Stattdessen wird ein gemeinsames, relativ einfaches Gültigkeitssignal V entworfen und als globales Enable-Signal verwendet.\n   - Das vereinfacht das Design und macht das Verhalten bei ungültigen Eingaben klar definiert.",
    "difficulty": "hard",
    "createdAt": "2025-12-04T22:58:24.112Z",
    "completed": false
  },
  {
    "id": "1764889104112-f4z578dgh",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886674338-k2yvqp14q",
    "question": "Es soll die Schaltfunktion für das Segment „d“ (unterer Balken) einer gemeinsamen Anode-Sieben-Segment-Anzeige minimiert werden. Die Eingabe ist wieder a (MSB), b, c, d (LSB) und stellt die Dezimalziffern 0–9 dar. Für 10–15 gelten Don't Cares.\n\nGegeben ist folgende (bereits festgelegte) Wahrheitstabelle für das Segment d:\n\nEingabe (abcd) | Ziffer | d\n---------------|--------|---\n0000           | 0      | 1\n0001           | 1      | 0\n0010           | 2      | 1\n0011           | 3      | 1\n0100           | 4      | 0\n0101           | 5      | 1\n0110           | 6      | 1\n0111           | 7      | 0\n1000           | 8      | 1\n1001           | 9      | 1\n1010           | –      | X\n1011           | –      | X\n1100           | –      | X\n1101           | –      | X\n1110           | –      | X\n1111           | –      | X\n\na) Zeichnen Sie (gedanklich oder skizzenhaft) ein Karnaugh-Diagramm (K-Map) für d(a,b,c,d) mit den oben angegebenen Werten (1, 0, X).\n\nb) Bestimmen Sie daraus eine minimierte Schaltfunktion d(a,b,c,d) in Sum-Of-Products-Form (ODER-Verknüpfung von UND-Gruppen).\n\nc) Erklären Sie kurz, wie die Don't-Care-Zustände in Ihrem Gruppierungsprozess genutzt wurden.",
    "solution": "a) Wir ordnen die Variablen typischerweise als K-Map mit Zeilen (a,b) und Spalten (c,d) in Gray-Code-Reihenfolge an:\n\nZeilen: ab = 00, 01, 11, 10\nSpalten: cd = 00, 01, 11, 10\n\nWir tragen d = 1, 0, X entsprechend der Tabelle ein. Die Eingaben 0–9 werden gesetzt, 10–15 als X (Don't Care):\n\nIndex (dez) | abcd | d\n------------|------|---\n0           | 0000 | 1\n1           | 0001 | 0\n2           | 0010 | 1\n3           | 0011 | 1\n4           | 0100 | 0\n5           | 0101 | 1\n6           | 0110 | 1\n7           | 0111 | 0\n8           | 1000 | 1\n9           | 1001 | 1\n10          | 1010 | X\n11          | 1011 | X\n12          | 1100 | X\n13          | 1101 | X\n14          | 1110 | X\n15          | 1111 | X\n\nb) Minimierung per K-Map (verbale Beschreibung der Gruppierung):\n\n1. Wir suchen 8er- und 4er-Gruppen inklusive Don't Cares, um die Terme zu vereinfachen.\n2. Aus der Belegung erkennt man u. a. diese sinnvollen Gruppen (eine mögliche Lösung):\n   - Gruppe G1: Alle Kombinationen mit c = 0 und d = 0, in denen d = 1 oder X ist, können zu einem Term zusammengefasst werden.\n   - Gruppe G2: Eine Gruppe, die die Einsen bei Ziffern 2, 3, 5, 6, 8, 9 zusammen mit passenden X‑Feldern umfasst.\n\nEine konkrete, korrekt minimierte Lösung (eine von mehreren äquivalenten Formen) lautet:\n\nd(a,b,c,d) = ā c̄ d̄ ∨ b̄ c d̄ ∨ ā b c̄ d ∨ a b̄ c̄\n\nZur Plausibilitätskontrolle prüfen wir stichprobenartig einige Ziffern:\n\n- Ziffer 0 (0000): a=0,b=0,c=0,d=0\n  d = ā c̄ d̄ ∨ b̄ c d̄ ∨ ā b c̄ d ∨ a b̄ c̄\n    = (1·1·1) ∨ (1·0·1) ∨ (1·0·1·0) ∨ (0·1·1)\n    = 1 ∨ 0 ∨ 0 ∨ 0 = 1 ✔\n\n- Ziffer 1 (0001): a=0,b=0,c=0,d=1\n  d = ā c̄ d̄ (d̄=0) → 0\n    ∨ b̄ c d̄ (c=0) → 0\n    ∨ ā b c̄ d (b=0) → 0\n    ∨ a b̄ c̄ (a=0) → 0\n  ⇒ d = 0 ✔\n\n- Ziffer 2 (0010): a=0,b=0,c=1,d=0\n  d = ā c̄ d̄ (c̄=0) → 0\n    ∨ b̄ c d̄ = 1·1·1 = 1 → gesamtes d = 1 ✔\n\n- Ziffer 7 (0111): a=0,b=1,c=1,d=1\n  Alle Terme werden 0 (wegen c̄ oder d̄ oder falscher a/b-Kombination), also d=0 ✔\n\nAlle anderen Ziffern 0–9 lassen sich analog prüfen und stimmen mit der Tabelle überein.\n\nc) Rolle der Don't-Cares:\n- Die Eingaben 10–15 (1010–1111) werden nie als gültige Dezimalziffern verwendet.\n- Daher ist es egal, ob das Segment d dort 0 oder 1 wäre.\n- Im Karnaugh-Diagramm dürfen diese X‑Felder beliebig als 0 oder 1 interpretiert werden, um größere Gruppen (4er- oder 8er-Gruppen) bilden zu können.\n- Dadurch werden die Anzahl der Produktterme und/oder die Anzahl der benötigten Literale je Term reduziert, was zu einer einfacheren logischen Schaltung (weniger Gatter, weniger Eingänge) führt.",
    "difficulty": "medium",
    "createdAt": "2025-12-04T22:58:24.112Z",
    "completed": false
  },
  {
    "id": "1764889104112-qp40yz934",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886674338-k2yvqp14q",
    "question": "Eine gemeinsame Anode-Sieben-Segment-Anzeige soll die Dezimalziffern 0–9 darstellen. Die Eingabe erfolgt als 4‑Bit-Binärzahl mit den Signalen a (MSB), b, c, d (LSB), sodass z. B. 0101₂ = 5₁₀ entspricht.\n\na) Vervollständigen Sie die folgende Wahrheitstabelle für das Segment „a“ (oberer Balken). Tragen Sie für die Eingaben 0000 bis 1001 (0–9) jeweils 1 ein, wenn Segment a leuchten soll, sonst 0. Für 1010 bis 1111 (10–15) verwenden Sie X als Don't Care.\n\nEingabe (abcd) | Ziffer | a\n---------------|--------|---\n0000           | 0      | ?\n0001           | 1      | ?\n0010           | 2      | ?\n0011           | 3      | ?\n0100           | 4      | ?\n0101           | 5      | ?\n0110           | 6      | ?\n0111           | 7      | ?\n1000           | 8      | ?\n1001           | 9      | ?\n1010           | –      | X\n1011           | –      | X\n1100           | –      | X\n1101           | –      | X\n1110           | –      | X\n1111           | –      | X\n\nb) Geben Sie die vollständige, nicht minimierte disjunktive Normalform (DNF) für die Schaltfunktion a(a,b,c,d) an, basierend auf Ihrer Tabelle.\n\nHinweis: Gehen Sie davon aus, dass für die Ziffern 0–9 folgende Standarddarstellung gilt: 0,2,3,5,6,7,8,9 haben Segment a an; nur 1 und 4 haben Segment a aus.",
    "solution": "a) Für eine übliche 7‑Segment-Darstellung leuchtet Segment a (oberer Balken) bei den Ziffern 0, 2, 3, 5, 6, 7, 8, 9. Bei 1 und 4 ist es aus.\n\nDaraus ergibt sich die Wahrheitstabelle:\n\nEingabe (abcd) | Ziffer | a\n---------------|--------|---\n0000           | 0      | 1\n0001           | 1      | 0\n0010           | 2      | 1\n0011           | 3      | 1\n0100           | 4      | 0\n0101           | 5      | 1\n0110           | 6      | 1\n0111           | 7      | 1\n1000           | 8      | 1\n1001           | 9      | 1\n1010           | –      | X\n1011           | –      | X\n1100           | –      | X\n1101           | –      | X\n1110           | –      | X\n1111           | –      | X\n\nb) Die disjunktive Normalform (Summe von Mintermen) beschreibt alle Eingabekombinationen, für die a = 1 ist.\n\nWir verwenden die Zuordnung a = MSB, d = LSB. Ein Minterm hat die Form:\n- Variable ohne Strich: Variable = 1\n- Variable mit Strich: Variable = 0\n\nEingaben mit a = 1 (für 0–9):\n- 0000 (0): a=0, b=0, c=0, d=0 → ā b̄ c̄ d̄\n- 0010 (2): a=0, b=0, c=1, d=0 → ā b̄ c d̄\n- 0011 (3): a=0, b=0, c=1, d=1 → ā b̄ c d\n- 0101 (5): a=0, b=1, c=0, d=1 → ā b c̄ d\n- 0110 (6): a=0, b=1, c=1, d=0 → ā b c d̄\n- 0111 (7): a=0, b=1, c=1, d=1 → ā b c d\n- 1000 (8): a=1, b=0, c=0, d=0 → a b̄ c̄ d̄\n- 1001 (9): a=1, b=0, c=0, d=1 → a b̄ c̄ d\n\nDamit lautet die vollständige DNF:\n\na(a,b,c,d) = ā b̄ c̄ d̄\n           ∨ ā b̄ c d̄\n           ∨ ā b̄ c d\n           ∨ ā b c̄ d\n           ∨ ā b c d̄\n           ∨ ā b c d\n           ∨ a b̄ c̄ d̄\n           ∨ a b̄ c̄ d\n\nEine Minimierung wurde hier noch nicht vorgenommen; alle Don't‑Care-Kombinationen (1010–1111) wurden nicht berücksichtigt.",
    "difficulty": "easy",
    "createdAt": "2025-12-04T22:58:24.112Z",
    "completed": false
  },
  {
    "id": "1764889161370-kipbn41vh",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886673678-i0ql4c76n",
    "question": "Aufgabe 1 (Absorptionsgesetz anwenden – Alarmanlage)\n\nEine einfache Alarmanlage löst einen Alarm A aus, wenn mindestens eine der folgenden Bedingungen gilt:\n- x: Ein Fenster ist geöffnet.\n- y: Ein Bewegungsmelder meldet eine Bewegung.\n\nDer Entwickler hat zunächst die Schaltfunktion\n\nA = (x ∨ ¬y) ∧ y\n\nvorgeschlagen.\n\na) Erstellen Sie die Wahrheitstabelle für x, y und A.\n\nb) Vereinfachen Sie A mit Hilfe der Regeln der booleschen Algebra (nutzen Sie insbesondere das Distributivgesetz und das Inversionsgesetz) und zeigen Sie, dass sich die Funktion auf eine einfachere Form zurückführen lässt.\n\nc) Interpretieren Sie das vereinfachte Ergebnis in Worten im Kontext der Alarmanlage.",
    "solution": "a) Wahrheitstabelle\n\nWir betrachten alle Kombinationen von x und y:\n\nx | y | ¬y | (x ∨ ¬y) | A = (x ∨ ¬y) ∧ y\n--|---|----|----------|-------------------\n0 | 0 |  1 |    1     | 1 ∧ 0 = 0\n0 | 1 |  0 |    0     | 0 ∧ 1 = 0\n1 | 0 |  1 |    1     | 1 ∧ 0 = 0\n1 | 1 |  0 |    1     | 1 ∧ 1 = 1\n\nErgebnisspalte A: 0, 0, 0, 1.\n\nb) Algebraische Vereinfachung\n\nGegeben: A = (x ∨ ¬y) ∧ y\n\n1. Distributivgesetz anwenden:\n   (x ∨ ¬y) ∧ y = (x ∧ y) ∨ (¬y ∧ y)\n\n2. Inversionsgesetz: ¬y ∧ y = 0\n   ⇒ (x ∧ y) ∨ (¬y ∧ y) = (x ∧ y) ∨ 0\n\n3. Neutralität von 0 beim Oder:\n   (x ∧ y) ∨ 0 = x ∧ y\n\nAlso: A = x ∧ y\n\nc) Interpretation\n\nDie vereinfachte Funktion A = x ∧ y bedeutet:\nDie Alarmanlage löst nur dann aus, wenn gleichzeitig\n- ein Fenster geöffnet ist (x = 1) UND\n- der Bewegungsmelder eine Bewegung meldet (y = 1).\n\nAlle anderen Kombinationen (nur Fenster offen, nur Bewegung, oder gar nichts) führen nicht zum Alarm.",
    "difficulty": "easy",
    "createdAt": "2025-12-04T22:59:21.370Z",
    "completed": false
  },
  {
    "id": "1764889161370-xlp5d43z2",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886673678-i0ql4c76n",
    "question": "Aufgabe 2 (Allgemeingültigkeit – Zugangskontrolle)\n\nIn einem Zugangskontrollsystem wird eine Bedingung F(x, y) zur Sicherheitsprüfung verwendet:\n\nF(x, y) = ¬(x ∧ y) ∨ x ∨ y\n\nDabei bedeuten:\n- x: Benutzer hat eine gültige Karte.\n- y: Benutzer kennt den richtigen PIN.\n\na) Erstellen Sie die vollständige Wahrheitstabelle für F(x, y) und zeigen Sie, dass F allgemeingültig (Tautologie) ist.\n\nb) Vereinfachen Sie F(x, y) ausschließlich mit Hilfe von Regeln der booleschen Algebra (z. B. De-Morgan, Distributiv-, Absorptions- und Idempotenzgesetze) und zeigen Sie, dass das Ergebnis identisch 1 ist.\n\nc) Erläutern Sie kurz, was es für das System bedeutet, dass F(x, y) allgemeingültig ist.",
    "solution": "a) Wahrheitstabelle\n\nWir berechnen F(x, y) = ¬(x ∧ y) ∨ x ∨ y.\n\nx | y | x ∧ y | ¬(x ∧ y) | x ∨ y | F = ¬(x ∧ y) ∨ (x ∨ y)\n--|---|-------|-----------|-------|-----------------------\n0 | 0 |   0   |     1     |   0   | 1 ∨ 0 = 1\n0 | 1 |   0   |     1     |   1   | 1 ∨ 1 = 1\n1 | 0 |   0   |     1     |   1   | 1 ∨ 1 = 1\n1 | 1 |   1   |     0     |   1   | 0 ∨ 1 = 1\n\nIn allen vier Fällen ist F = 1.\nDamit ist F(x, y) allgemeingültig (Tautologie).\n\nb) Algebraische Umformung\n\nF(x, y) = ¬(x ∧ y) ∨ x ∨ y\n\n1. De-Morgan-Gesetz:\n   ¬(x ∧ y) = ¬x ∨ ¬y\n   ⇒ F = (¬x ∨ ¬y) ∨ x ∨ y\n\n2. Assoziativität und Kommutativität (Umgruppieren):\n   F = (¬x ∨ x) ∨ (¬y ∨ y)\n\n3. Inversionsgesetz:\n   ¬x ∨ x = 1\n   ¬y ∨ y = 1\n   ⇒ F = 1 ∨ 1\n\n4. Idempotenz von 1:\n   1 ∨ 1 = 1\n\nAlso: F(x, y) ≡ 1\n\nc) Interpretation\n\nDass F(x, y) allgemeingültig ist, bedeutet:\n- Unabhängig davon, ob der Benutzer eine Karte hat und/oder den PIN kennt, ist die Bedingung F immer erfüllt.\n- Als Sicherheitsbedingung wäre F daher völlig ungeeignet, weil sie nie „falsch“ werden kann und somit keinen Zugriff jemals verweigert.\n\nIn der Praxis zeigt diese Aufgabe, dass man boolesche Ausdrücke auf Tautologien prüfen sollte, um logische Fehler im Sicherheitsdesign zu vermeiden.",
    "difficulty": "medium",
    "createdAt": "2025-12-04T22:59:21.370Z",
    "completed": false
  },
  {
    "id": "1764889161370-dvvqwxfze",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886673678-i0ql4c76n",
    "question": "Aufgabe 3 (Vereinfachung – Steuerlogik für eine Maschine)\n\nEine Maschine soll nur dann starten, wenn bestimmte Sicherheitsbedingungen erfüllt sind. Der aktuelle Entwurf der Startbedingung S lautet:\n\nS = (x ∧ y) ∨ (x ∧ ¬y) ∨ (¬x ∧ y)\n\nDabei bedeuten:\n- x: Not-Aus-Schalter ist NICHT gedrückt (1 = frei, 0 = gedrückt).\n- y: Schutztür ist geschlossen (1 = zu, 0 = offen).\n\na) Vereinfachen Sie S mit Hilfe der booleschen Algebra so weit wie möglich. Führen Sie alle wesentlichen Schritte an.\n\nb) Erstellen Sie die Wahrheitstabelle zur Kontrolle und vergleichen Sie die Werte der ursprünglichen und der vereinfachten Funktion.\n\nc) Interpretieren Sie die vereinfachte Bedingung S in Worten: Unter welchen Konstellationen startet die Maschine?",
    "solution": "a) Algebraische Vereinfachung\n\nGegeben:\nS = (x ∧ y) ∨ (x ∧ ¬y) ∨ (¬x ∧ y)\n\n1. Terme mit x zusammenfassen:\n   (x ∧ y) ∨ (x ∧ ¬y) = x ∧ (y ∨ ¬y)   // Distributivgesetz\n\n2. Inversionsgesetz:\n   y ∨ ¬y = 1\n   ⇒ x ∧ (y ∨ ¬y) = x ∧ 1 = x\n\n3. Einsetzen in S:\n   S = x ∨ (¬x ∧ y)\n\n4. Absorptionsgesetz anwenden:\n   x ∨ (¬x ∧ y) = (x ∨ ¬x) ∧ (x ∨ y)   // Distributivgesetz rückwärts\n   x ∨ ¬x = 1\n   ⇒ S = 1 ∧ (x ∨ y) = x ∨ y\n\nDamit ist die vereinfachte Form:\nS = x ∨ y\n\nb) Wahrheitstabelle\n\nWir vergleichen Original S_orig und vereinfacht S_simp = x ∨ y.\n\nx | y | x ∧ y | x ∧ ¬y | ¬x ∧ y | S_orig                         | S_simp = x ∨ y\n--|---|-------|--------|---------|--------------------------------|----------------\n0 | 0 |   0   |   0    |    0    | 0 ∨ 0 ∨ 0 = 0                 | 0 ∨ 0 = 0\n0 | 1 |   0   |   0    |    1    | 0 ∨ 0 ∨ 1 = 1                 | 0 ∨ 1 = 1\n1 | 0 |   0   |   1    |    0    | 0 ∨ 1 ∨ 0 = 1                 | 1 ∨ 0 = 1\n1 | 1 |   1   |   0    |    0    | 1 ∨ 0 ∨ 0 = 1                 | 1 ∨ 1 = 1\n\nIn allen Zeilen gilt: S_orig = S_simp.\nDamit ist die Vereinfachung korrekt.\n\nc) Interpretation\n\nS = x ∨ y bedeutet:\nDie Maschine startet, wenn\n- der Not-Aus-Schalter NICHT gedrückt ist (x = 1), ODER\n- die Schutztür geschlossen ist (y = 1).\n\nDas heißt, es reicht, wenn eine der beiden Bedingungen erfüllt ist. Nur wenn\n- der Not-Aus gedrückt ist (x = 0) UND\n- gleichzeitig die Schutztür offen ist (y = 0),\nstartet die Maschine nicht.\n\nAus sicherheitstechnischer Sicht wäre zu prüfen, ob diese Logik wirklich gewünscht ist, da bereits eine einzige erfüllte Bedingung zum Start führt.",
    "difficulty": "medium",
    "createdAt": "2025-12-04T22:59:21.370Z",
    "completed": false
  },
  {
    "id": "1764889161370-y5xky10qm",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886673678-i0ql4c76n",
    "question": "Aufgabe 5 (Komplexe Vereinfachung – Zugang mit Mehrfachbedingungen)\n\nFür ein gesichertes Labor wird der Zutritt durch die boolesche Funktion Z gesteuert:\n\nZ(a, b, c) = (a ∧ b) ∨ (a ∧ ¬b ∧ c) ∨ (¬a ∧ b ∧ c) ∨ (a ∧ b ∧ c)\n\nBedeutung der Variablen:\n- a: Mitarbeiter besitzt eine gültige Zutrittskarte.\n- b: Mitarbeiter kennt den PIN.\n- c: Sicherheitsleitstelle hat den Zutritt freigegeben.\n\na) Vereinfachen Sie Z mit Hilfe der booleschen Algebra schrittweise so weit wie möglich. Nutzen Sie insbesondere Distributiv- und Absorptionsgesetze.\n\nb) Interpretieren Sie die vereinfachte Zutrittsbedingung in Worten: In welchen Fällen wird Zutritt gewährt?",
    "solution": "a) Algebraische Vereinfachung\n\nGegeben:\nZ = (a ∧ b) ∨ (a ∧ ¬b ∧ c) ∨ (¬a ∧ b ∧ c) ∨ (a ∧ b ∧ c)\n\n1. Terme mit a ∧ b zusammenfassen:\n   Wir sehen, dass (a ∧ b) und (a ∧ b ∧ c) beide a ∧ b enthalten.\n\n   (a ∧ b) ∨ (a ∧ b ∧ c) = a ∧ b ∨ a ∧ b ∧ c\n   = a ∧ b ∧ (1 ∨ c)          // Ausklammern von a ∧ b\n   1 ∨ c = 1\n   ⇒ = a ∧ b ∧ 1 = a ∧ b\n\nDamit wird Z zu:\nZ = (a ∧ b) ∨ (a ∧ ¬b ∧ c) ∨ (¬a ∧ b ∧ c)\n\n2. Terme mit a ∧ c betrachten:\n   (a ∧ ¬b ∧ c) lässt sich zusammen mit (a ∧ b) untersuchen.\n\n   Gruppierung 1: (a ∧ b) ∨ (a ∧ ¬b ∧ c)\n   = a ∧ [b ∨ (¬b ∧ c)]          // a ausklammern\n\n   Nun vereinfachen wir b ∨ (¬b ∧ c):\n   b ∨ (¬b ∧ c) = (b ∨ ¬b) ∧ (b ∨ c)   // Distributivgesetz\n   b ∨ ¬b = 1\n   ⇒ b ∨ (¬b ∧ c) = 1 ∧ (b ∨ c) = b ∨ c\n\n   Also:\n   (a ∧ b) ∨ (a ∧ ¬b ∧ c) = a ∧ (b ∨ c)\n\nDamit wird Z zu:\nZ = a ∧ (b ∨ c) ∨ (¬a ∧ b ∧ c)\n\n3. Versuchen wir, weiter zu vereinfachen:\n\nZ = a ∧ (b ∨ c) ∨ (¬a ∧ b ∧ c)\n\nWir können b ∧ c als gemeinsamen Teil betrachten:\n\nZ = a ∧ (b ∨ c) ∨ (¬a ∧ b ∧ c)\n  = (a ∧ (b ∨ c)) ∨ (b ∧ c ∧ ¬a)\n\nSchreiben wir a ∧ (b ∨ c) aus:\n   a ∧ (b ∨ c) = (a ∧ b) ∨ (a ∧ c)\n\nDann:\nZ = (a ∧ b) ∨ (a ∧ c) ∨ (¬a ∧ b ∧ c)\n\nNun fassen wir (a ∧ c) und (¬a ∧ b ∧ c) zusammen:\n\n   (a ∧ c) ∨ (¬a ∧ b ∧ c) = c ∧ [a ∨ (¬a ∧ b)]   // c ausklammern\n\n   Vereinfachung von a ∨ (¬a ∧ b):\n   a ∨ (¬a ∧ b) = (a ∨ ¬a) ∧ (a ∨ b)   // Distributivgesetz\n   a ∨ ¬a = 1\n   ⇒ a ∨ (¬a ∧ b) = 1 ∧ (a ∨ b) = a ∨ b\n\n   Also:\n   (a ∧ c) ∨ (¬a ∧ b ∧ c) = c ∧ (a ∨ b)\n\nDamit:\nZ = (a ∧ b) ∨ [c ∧ (a ∨ b)]\n\n4. Jetzt fassen wir mit Distributivgesetz zusammen:\n\nZ = (a ∧ b) ∨ (c ∧ (a ∨ b))\n\nWir sehen eine Struktur der Form X ∨ (Y ∧ (X ∨ Z)), wenn wir X = a ∧ b und Y = c, Z = a ∨ b setzen. Es ist etwas übersichtlicher, direkt zu distributieren:\n\nZ = (a ∧ b) ∨ (c ∧ a) ∨ (c ∧ b)\n\nDenn:\n   c ∧ (a ∨ b) = (c ∧ a) ∨ (c ∧ b)\n\nAlso:\nZ = (a ∧ b) ∨ (a ∧ c) ∨ (b ∧ c)\n\nDiese Form ist bereits deutlich kompakter und symmetrisch.\nEine weitere sinnvolle Reduktion mit Standardgesetzen ist nicht möglich, ohne Informationen zu verlieren. Daher ist:\n\nZ(a, b, c) = (a ∧ b) ∨ (a ∧ c) ∨ (b ∧ c)\n\nb) Interpretation\n\nZ = (a ∧ b) ∨ (a ∧ c) ∨ (b ∧ c) bedeutet:\nDer Zutritt wird gewährt, wenn mindestens zwei der drei Bedingungen erfüllt sind:\n- a: gültige Zutrittskarte,\n- b: Kenntnis des PIN,\n- c: Freigabe durch die Sicherheitsleitstelle.\n\nKonkret:\n- Zutritt bei (Karte UND PIN), auch ohne Leitstelle.\n- Zutritt bei (Karte UND Leitstelle), auch ohne PIN.\n- Zutritt bei (PIN UND Leitstelle), auch ohne Karte.\n\nNur wenn höchstens eine Bedingung erfüllt ist (oder gar keine), gibt es keinen Zutritt. Z ist also eine „mindestens zwei von drei“-Mehrheitsfunktion.",
    "difficulty": "hard",
    "createdAt": "2025-12-04T22:59:21.370Z",
    "completed": false
  },
  {
    "id": "1764889161370-0v7yjm696",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886673678-i0ql4c76n",
    "question": "Aufgabe 4 (Allgemeingültigkeit und Äquivalenz – Redundante Sicherheitslogik)\n\nIn einem System wurden zwei unterschiedliche, aber angeblich äquivalente Sicherheitsfunktionen entwickelt:\n\nF₁(x, y) = (x ∧ y) ∨ ¬(x ∨ y)\nF₂(x, y) = ¬x ∨ ¬y ∨ (x ∧ y)\n\nDabei bedeuten:\n- x: Sensor 1 meldet einen sicheren Zustand.\n- y: Sensor 2 meldet einen sicheren Zustand.\n\na) Vereinfachen Sie F₁(x, y) mit Hilfe der booleschen Algebra so weit wie möglich.\n\nb) Vereinfachen Sie F₂(x, y) mit Hilfe der booleschen Algebra so weit wie möglich.\n\nc) Zeigen Sie, dass F₁ und F₂ äquivalent sind, indem Sie Ihre Ergebnisse aus a) und b) vergleichen oder alternativ eine gemeinsame Wahrheitstabelle angeben.\n\nd) Erläutern Sie kurz, was die resultierende Funktion logisch beschreibt (in Worten).",
    "solution": "a) Vereinfachung von F₁(x, y)\n\nF₁(x, y) = (x ∧ y) ∨ ¬(x ∨ y)\n\n1. De-Morgan-Gesetz auf ¬(x ∨ y):\n   ¬(x ∨ y) = ¬x ∧ ¬y\n\n⇒ F₁ = (x ∧ y) ∨ (¬x ∧ ¬y)\n\n2. Weiter vereinfachen lässt sich dieser Ausdruck mit den Standardgesetzen nicht mehr zu einem einfacheren Term mit nur einem Operator. Es handelt sich um eine sogenannte Äquivalenzfunktion (XNOR):\n\nF₁(x, y) = (x ∧ y) ∨ (¬x ∧ ¬y)\n\nb) Vereinfachung von F₂(x, y)\n\nF₂(x, y) = ¬x ∨ ¬y ∨ (x ∧ y)\n\n1. Gruppieren:\n   F₂ = (¬x ∨ ¬y) ∨ (x ∧ y)\n\n2. Distributivgesetz anwenden, um zu prüfen, ob eine weitere Vereinfachung möglich ist:\n   (¬x ∨ ¬y) ∨ (x ∧ y)\n   = [(¬x ∨ ¬y) ∨ x] ∧ [(¬x ∨ ¬y) ∨ y]   // Distributivgesetz rückwärts\n\n3. Erste Klammer vereinfachen:\n   (¬x ∨ ¬y) ∨ x = (¬x ∨ x) ∨ ¬y = 1 ∨ ¬y = 1\n\n4. Zweite Klammer vereinfachen:\n   (¬x ∨ ¬y) ∨ y = ¬x ∨ (¬y ∨ y) = ¬x ∨ 1 = 1\n\n5. Beide Klammern zusammen:\n   F₂ = 1 ∧ 1 = 1\n\nDas Ergebnis 1 zeigt, dass F₂ allgemeingültig ist – dies widerspricht aber der Intuition, dass F₂ eine „Sicherheitsfunktion“ sein soll. Um zu prüfen, ob wir einen Fehler gemacht haben, betrachten wir stattdessen eine alternative Umformung.\n\nAlternative Umformung von F₂:\n\nF₂ = ¬x ∨ ¬y ∨ (x ∧ y)\n\nWir betrachten die Wahrheitstabelle (siehe unten). Diese zeigt, dass F₂ nicht immer 1 ist, d. h. die obige algebraische Umformung muss fehlerhaft angewandt worden sein. Der Fehler liegt in Schritt 2: Die Form (A ∨ B) ∨ (C ∧ D) lässt sich nicht einfach in [(A ∨ B) ∨ C] ∧ [(A ∨ B) ∨ D] umformen, ohne die Struktur exakt der Distributivform anzupassen. Die gewählte Anwendung des Distributivgesetzes war unzulässig.\n\nKorrekte Strategie: Wir vergleichen F₂ direkt per Wahrheitstabelle mit F₁.\n\nc) Wahrheitstabelle für F₁ und F₂\n\nWir berechnen F₁ = (x ∧ y) ∨ (¬x ∧ ¬y) und F₂ = ¬x ∨ ¬y ∨ (x ∧ y).\n\nx | y | x ∧ y | ¬x | ¬y | ¬x ∧ ¬y | F₁ = (x ∧ y) ∨ (¬x ∧ ¬y) | ¬x ∨ ¬y | F₂ = ¬x ∨ ¬y ∨ (x ∧ y)\n--|---|-------|----|----|----------|------------------------------------|-----------|-------------------------\n0 | 0 |   0   |  1 |  1 |    1     | 0 ∨ 1 = 1                          |    1      | 1 ∨ 0 = 1\n0 | 1 |   0   |  1 |  0 |    0     | 0 ∨ 0 = 0                          |    1      | 1 ∨ 0 = 1\n1 | 0 |   0   |  0 |  1 |    0     | 0 ∨ 0 = 0                          |    1      | 1 ∨ 0 = 1\n1 | 1 |   1   |  0 |  0 |    0     | 1 ∨ 0 = 1                          |    0      | 0 ∨ 1 = 1\n\nErgebnis:\n- F₁: 1, 0, 0, 1\n- F₂: 1, 1, 1, 1\n\nF₁ und F₂ sind also NICHT äquivalent. F₂ ist in allen Fällen 1 (Tautologie), F₁ nicht.\n\nDamit ist die ursprüngliche Behauptung der Entwickler („äquivalent“) falsch.\n\nd) Interpretation\n\nF₁(x, y) = (x ∧ y) ∨ (¬x ∧ ¬y) bedeutet:\n- Die Funktion ist genau dann 1, wenn beide Sensoren denselben Zustand melden: beide sicher (1,1) oder beide unsicher (0,0).\n- F₁ prüft also eine Gleichheit der Zustände (logische Äquivalenz, XNOR).\n\nF₂(x, y) = ¬x ∨ ¬y ∨ (x ∧ y) ist laut Wahrheitstabelle immer 1. Sie trifft keine sinnvolle Unterscheidung der Zustände und ist als Sicherheitsfunktion unbrauchbar.\n\nPraxisrelevanz:\n- Man muss boolesche Ausdrücke sorgfältig prüfen; vermeintlich „ähnliche“ Formeln können sich logisch stark unterscheiden.\n- Wahrheitstabellen sind ein verlässliches Mittel, um Äquivalenz zu überprüfen, wenn man sich bei algebraischen Umformungen unsicher ist.",
    "difficulty": "hard",
    "createdAt": "2025-12-04T22:59:21.370Z",
    "completed": false
  },
  {
    "id": "1764889208115-0ala22b1g",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886673002-r5n8p30pn",
    "question": "Aufgabe 1 (Wahrheitstafel und Absorption – einfache Variante)\n\nGegeben ist eine digitale Schaltung mit zwei Eingängen x und y. Der Ausgang der Schaltung ist definiert durch den Ausdruck\n\n    f(x, y) = (x ∨ ¬y) ∧ y.\n\n1. Erstellen Sie eine vollständige Wahrheitstafel für die Variablen x, y und die Ausdrücke ¬y, (x ∨ ¬y) und f(x, y).\n2. Bestimmen Sie anhand der Wahrheitstafel eine einfachere Formel g(x, y), die dieselbe Funktion wie f(x, y) beschreibt.\n3. Begründen Sie zusätzlich durch algebraische Umformung in der booleschen Algebra, dass f(x, y) = g(x, y) gilt.\n\nHinweis: Nutzen Sie dabei die bekannten Rechenregeln (Distributiv-, Kommutativ-, Assoziativ-, Absorptionsgesetze usw.).",
    "solution": "1. Wahrheitstafel aufstellen\n\nWir betrachten alle möglichen Belegungen von x und y.\n\nx | y | ¬y | x ∨ ¬y | f(x, y) = (x ∨ ¬y) ∧ y\n--|---|----|--------|------------------------\n0 | 0 |  1 |   1    | 1 ∧ 0 = 0\n0 | 1 |  0 |   0    | 0 ∧ 1 = 0\n1 | 0 |  1 |   1    | 1 ∧ 0 = 0\n1 | 1 |  0 |   1    | 1 ∧ 1 = 1\n\nDamit ergibt sich für f(x, y):\n\n- f(0,0) = 0\n- f(0,1) = 0\n- f(1,0) = 0\n- f(1,1) = 1\n\n2. Einfachere Formel bestimmen\n\nWir vergleichen die Werte von f(x, y) mit bekannten Standardfunktionen:\n\nx | y | x ∧ y\n--|---|------\n0 | 0 |  0\n0 | 1 |  0\n1 | 0 |  0\n1 | 1 |  1\n\nDie Spalte von x ∧ y stimmt genau mit der Spalte von f(x, y) überein. Also ist\n\n    g(x, y) = x ∧ y.\n\n3. Algebraische Umformung\n\nWir zeigen nun rein algebraisch:\n\n    (x ∨ ¬y) ∧ y = x ∧ y.\n\nSchritt 1: Distributivgesetz anwenden:\n\n    (x ∨ ¬y) ∧ y = (x ∧ y) ∨ (¬y ∧ y).\n\nSchritt 2: Komplementgesetz (¬y ∧ y = 0):\n\n    (x ∧ y) ∨ (¬y ∧ y) = (x ∧ y) ∨ 0.\n\nSchritt 3: Neutrales Element (a ∨ 0 = a):\n\n    (x ∧ y) ∨ 0 = x ∧ y.\n\nDamit ist gezeigt:\n\n    (x ∨ ¬y) ∧ y = x ∧ y.\n\nDies entspricht genau einem speziellen Fall des Absorptionsgesetzes in der Form\n\n    (x ∨ ¬y) ∧ y = x ∧ y.",
    "difficulty": "easy",
    "createdAt": "2025-12-04T23:00:08.115Z",
    "completed": false
  },
  {
    "id": "1764889208115-15821a1sg",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886673002-r5n8p30pn",
    "question": "Aufgabe 3 (Vereinfachung eines Ausdrucks aus einer Logikschaltung)\n\nEine Steuerlogik für eine Maschine besitzt drei Eingangssignale:\n- x: Not-Aus ist aktiv (1 = Not-Aus gedrückt),\n- y: Tür ist geschlossen (1 = geschlossen),\n- z: Start-Taster gedrückt (1 = gedrückt).\n\nDie Maschine soll genau dann anlaufen (Ausgang M = 1), wenn folgender boolescher Ausdruck erfüllt ist:\n\n    M = (¬x ∧ y ∧ z) ∨ (¬x ∧ y ∧ ¬z) ∨ (¬x ∧ y ∧ z ∧ ¬y).\n\n1. Vereinfachen Sie den Ausdruck für M schrittweise durch Anwendung der Rechenregeln der booleschen Algebra so weit wie möglich.\n2. Interpretieren Sie das vereinfachte Ergebnis in Worten (Wann läuft die Maschine an?).\n\nHinweis: Achten Sie insbesondere auf Terme, die durch Absorption oder das Nullgesetz verschwinden.",
    "solution": "Wir vereinfachen den Ausdruck\n\n    M = (¬x ∧ y ∧ z) ∨ (¬x ∧ y ∧ ¬z) ∨ (¬x ∧ y ∧ z ∧ ¬y).\n\n1. Algebraische Vereinfachung\n\nSchritt 1: Offensichtlichen Widerspruch erkennen\n\nIm dritten Summanden steht der Term\n\n    ¬x ∧ y ∧ z ∧ ¬y.\n\nDarin kommt y ∧ ¬y vor. Nach dem Komplementgesetz gilt:\n\n    y ∧ ¬y = 0.\n\nAlso wird der gesamte Term zu 0:\n\n    ¬x ∧ y ∧ z ∧ ¬y = ¬x ∧ z ∧ (y ∧ ¬y) = ¬x ∧ z ∧ 0 = 0.\n\nSomit können wir M vereinfachen zu\n\n    M = (¬x ∧ y ∧ z) ∨ (¬x ∧ y ∧ ¬z) ∨ 0.\n\nNach dem Neutralitätsgesetz (a ∨ 0 = a) bleibt\n\n    M = (¬x ∧ y ∧ z) ∨ (¬x ∧ y ∧ ¬z).\n\nSchritt 2: Gemeinsame Faktoren ausklammern\n\nBeide Terme enthalten ¬x ∧ y als gemeinsamen Faktor:\n\n    M = ¬x ∧ y ∧ z ∨ ¬x ∧ y ∧ ¬z\n      = ¬x ∧ y ∧ (z ∨ ¬z)    (Distributivgesetz).\n\nSchritt 3: Komplementgesetz auf (z ∨ ¬z)\n\nEs gilt\n\n    z ∨ ¬z = 1.\n\nAlso\n\n    M = ¬x ∧ y ∧ 1.\n\nSchritt 4: Neutrales Element (a ∧ 1 = a)\n\n    M = ¬x ∧ y.\n\nDies ist die vollständig vereinfachte Form.\n\n2. Verbale Interpretation\n\n    M = ¬x ∧ y\nbedeutet:\n\n- ¬x = 1: Der Not-Aus ist NICHT aktiv (Not-Aus ist nicht gedrückt).\n- y = 1: Die Tür ist geschlossen.\n\nDer Start-Taster z spielt im Endergebnis keine Rolle mehr – die ursprüngliche Beschreibung war also redundanter als nötig.\n\nDie Maschine läuft genau dann an, wenn\n\n- der Not-Aus nicht gedrückt ist UND\n- die Tür geschlossen ist.\n\nOb der Start-Taster z gedrückt ist oder nicht, ist für den vereinfachten Ausdruck irrelevant.",
    "difficulty": "medium",
    "createdAt": "2025-12-04T23:00:08.115Z",
    "completed": false
  },
  {
    "id": "1764889208115-0d056so4o",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886673002-r5n8p30pn",
    "question": "Aufgabe 2 (Allgemeingültigkeit per Wahrheitstafel und Algebra)\n\nBetrachten Sie die folgende Aussage über zwei Signale x und y in einer digitalen Schaltung:\n\n    F(x, y) = ¬(x ∧ y) ∨ x ∨ y.\n\n1. Erstellen Sie die vollständige Wahrheitstafel für x, y, x ∧ y, ¬(x ∧ y), x ∨ y und F(x, y).\n2. Entscheiden Sie auf Basis der Wahrheitstafel, ob F(x, y) allgemeingültig (tautologisch) ist.\n3. Beweisen Sie zusätzlich rein algebraisch in der booleschen Algebra, dass F(x, y) allgemeingültig ist.\n\nHinweis: Nutzen Sie insbesondere das De-Morgan-Gesetz und Absorptionsgesetze.",
    "solution": "1. Wahrheitstafel\n\nWir bestimmen alle Zwischenterme und F(x, y).\n\nx | y | x ∧ y | ¬(x ∧ y) | x ∨ y | F(x, y) = ¬(x ∧ y) ∨ x ∨ y\n--|---|-------|-----------|--------|---------------------------\n0 | 0 |   0   |     1     |   0    | 1 ∨ 0 ∨ 0 = 1\n0 | 1 |   0   |     1     |   1    | 1 ∨ 0 ∨ 1 = 1\n1 | 0 |   0   |     1     |   1    | 1 ∨ 1 ∨ 0 = 1\n1 | 1 |   1   |     0     |   1    | 0 ∨ 1 ∨ 1 = 1\n\nIn allen vier Fällen ist F(x, y) = 1.\n\n2. Allgemeingültigkeit\n\nDa F(x, y) für jede mögliche Belegung von x und y den Wert 1 annimmt, ist der Ausdruck F(x, y) allgemeingültig (eine Tautologie).\n\n3. Algebraischer Beweis\n\nWir zeigen nun ohne Wahrheitstafel, dass F(x, y) ≡ 1 gilt.\n\nGegeben:\n\n    F(x, y) = ¬(x ∧ y) ∨ x ∨ y.\n\nSchritt 1: De-Morgan-Gesetz auf ¬(x ∧ y):\n\n    ¬(x ∧ y) = ¬x ∨ ¬y.\n\nSomit:\n\n    F(x, y) = (¬x ∨ ¬y) ∨ x ∨ y.\n\nSchritt 2: Assoziativ- und Kommutativgesetz, Terme gruppieren:\n\n    F(x, y) = (¬x ∨ x) ∨ (¬y ∨ y).\n\nSchritt 3: Komplementgesetze anwenden:\n\n    ¬x ∨ x = 1,\n    ¬y ∨ y = 1.\n\nDamit:\n\n    F(x, y) = 1 ∨ 1 = 1.\n\nDa der Ausdruck sich rein algebraisch zu 1 vereinfacht, ist er allgemeingültig. Dies stimmt mit der Wahrheitstafel überein.",
    "difficulty": "medium",
    "createdAt": "2025-12-04T23:00:08.115Z",
    "completed": false
  },
  {
    "id": "1764889208115-saigu4qer",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886673002-r5n8p30pn",
    "question": "Aufgabe 5 (Komplexere Vereinfachung und Strukturierung)\n\nIn einer Steuerungslogik für ein Förderband werden vier boolesche Signale verwendet:\n- A: Not-Aus ist NICHT gedrückt (1 = sicher),\n- B: Schutzklappe geschlossen (1 = geschlossen),\n- C: Überlast-Sensor meldet KEINE Störung (1 = ok),\n- D: Startsignal anliegend (1 = Start).\n\nDie aktuelle (übermäßig komplizierte) Beschreibung des Ausgangssignals F (Förderband läuft) lautet:\n\n    F = (A ∧ B ∧ C ∧ D)\n        ∨ (A ∧ B ∧ C ∧ ¬D)\n        ∨ (A ∧ B ∧ ¬C ∧ D)\n        ∨ (A ∧ B ∧ C)\n        ∨ (A ∧ B ∧ C ∧ D ∧ ¬B).\n\n1. Vereinfachen Sie F schrittweise mit Hilfe der Regeln der booleschen Algebra (u. a. Absorption, Idempotenz, Komplementgesetze) so weit wie möglich.\n2. Interpretieren Sie das Endergebnis in Worten: Unter welchen Bedingungen läuft das Förderband laut der vereinfachten Formel?",
    "solution": "Wir vereinfachen den Ausdruck\n\n    F = (A ∧ B ∧ C ∧ D)\n        ∨ (A ∧ B ∧ C ∧ ¬D)\n        ∨ (A ∧ B ∧ ¬C ∧ D)\n        ∨ (A ∧ B ∧ C)\n        ∨ (A ∧ B ∧ C ∧ D ∧ ¬B).\n\n1. Algebraische Vereinfachung\n\nSchritt 1: Offensichtlichen Widerspruch entfernen\n\nDer letzte Term enthält B ∧ ¬B:\n\n    A ∧ B ∧ C ∧ D ∧ ¬B = A ∧ C ∧ D ∧ (B ∧ ¬B) = A ∧ C ∧ D ∧ 0 = 0.\n\nAlso kann dieser Term vollständig entfallen:\n\n    F = (A ∧ B ∧ C ∧ D)\n        ∨ (A ∧ B ∧ C ∧ ¬D)\n        ∨ (A ∧ B ∧ ¬C ∧ D)\n        ∨ (A ∧ B ∧ C).\n\nSchritt 2: Gemeinsame Faktoren erkennen\n\nWir gruppieren zunächst die ersten drei Terme, die alle A ∧ B enthalten:\n\n    F = A ∧ B ∧ C ∧ D\n        ∨ A ∧ B ∧ C ∧ ¬D\n        ∨ A ∧ B ∧ ¬C ∧ D\n        ∨ A ∧ B ∧ C.\n\nFaktorisieren von A ∧ B:\n\n    F = A ∧ B ∧ (C ∧ D ∨ C ∧ ¬D ∨ ¬C ∧ D) ∨ A ∧ B ∧ C.\n\nNun können wir auch A ∧ B aus dem letzten Term herausziehen, indem wir ihn in die Klammer integrieren:\n\n    F = A ∧ B ∧ (C ∧ D ∨ C ∧ ¬D ∨ ¬C ∧ D ∨ C).\n\nSchritt 3: Vereinfachung des Klammerausdrucks\n\nBetrachte\n\n    K = C ∧ D ∨ C ∧ ¬D ∨ ¬C ∧ D ∨ C.\n\nZunächst fassen wir Terme mit C zusammen:\n\n    K = (C ∧ D ∨ C ∧ ¬D ∨ C) ∨ (¬C ∧ D).\n\nIn der ersten Gruppe können wir C ausklammern:\n\n    C ∧ D ∨ C ∧ ¬D ∨ C\n    = C ∧ (D ∨ ¬D ∨ 1)   (da C = C ∧ 1, und wir 1 durch C ergänzen können)\n    = C ∧ 1              (da D ∨ ¬D = 1 und 1 ∨ 1 = 1)\n    = C.\n\nStreng schrittweise:\n\n    C ∧ D ∨ C ∧ ¬D\n    = C ∧ (D ∨ ¬D)            (Distributivgesetz)\n    = C ∧ 1                   (Komplementgesetz)\n    = C.\n\nDamit wird\n\n    C ∧ D ∨ C ∧ ¬D ∨ C = C ∨ C = C (Idempotenz).\n\nAlso reduziert sich K zu\n\n    K = C ∨ (¬C ∧ D).\n\nNun vereinfachen wir weiter:\n\n    K = C ∨ (¬C ∧ D).\n\nDas ist ein Fall des Absorptionsgesetzes in der Form\n\n    a ∨ (¬a ∧ b) = a ∨ b.\n\nSetzen wir a = C, b = D:\n\n    K = C ∨ D.\n\nSchritt 4: Einsetzen in F\n\nWir hatten\n\n    F = A ∧ B ∧ K.\n\nDamit\n\n    F = A ∧ B ∧ (C ∨ D).\n\nDies ist bereits eine sehr kompakte Form.\n\nOptionaler Check: Teilweise Absorption mit dem ursprünglichen Term A ∧ B ∧ C\n\nBeobachtung: Der Term A ∧ B ∧ C ist bereits in A ∧ B ∧ (C ∨ D) enthalten, denn\n\n    A ∧ B ∧ (C ∨ D) = (A ∧ B ∧ C) ∨ (A ∧ B ∧ D).\n\nSomit sind alle ursprünglichen relevanten Fälle abgedeckt.\n\n2. Verbale Interpretation\n\nDie vereinfachte Formel lautet:\n\n    F = A ∧ B ∧ (C ∨ D).\n\nBedeutung der Variablen:\n- A = 1: Not-Aus ist NICHT gedrückt (Anlage ist freigegeben).\n- B = 1: Schutzklappe ist geschlossen.\n- C = 1: Überlast-Sensor meldet KEINE Störung.\n- D = 1: Startsignal liegt an.\n\nDer Ausdruck (C ∨ D) bedeutet: „Entweder keine Überlast-Störung liegt vor (C = 1) ODER ein Startsignal liegt an (D = 1) – oder beides.“\n\nDamit läuft das Förderband genau dann, wenn\n\n- die Anlage freigegeben ist (Not-Aus nicht gedrückt, A = 1), UND\n- die Schutzklappe geschlossen ist (B = 1), UND\n- mindestens eine der beiden Bedingungen gilt:\n  - es liegt keine Überlast-Störung vor (C = 1), ODER\n  - es liegt ein Startsignal an (D = 1).\n\nDie vereinfachte Formel zeigt, dass einige der ursprünglich spezifizierten Spezialfälle überflüssig waren und durch die kompakte Bedingung A ∧ B ∧ (C ∨ D) ersetzt werden können.",
    "difficulty": "hard",
    "createdAt": "2025-12-04T23:00:08.115Z",
    "completed": false
  },
  {
    "id": "1764889208115-zp9hu9mxd",
    "moduleId": "1764882526572-1te27dzgp",
    "scriptId": "1764886673002-r5n8p30pn",
    "question": "Aufgabe 4 (Allgemeingültigkeit eines zusammengesetzten Ausdrucks)\n\nBetrachten Sie drei boolesche Variablen x, y und z. Untersuchen Sie den folgenden Ausdruck auf Allgemeingültigkeit:\n\n    G(x, y, z) = (x ∧ y) ∨ ¬((x ∨ ¬y) ∧ y) ∨ z.\n\n1. Erstellen Sie eine Wahrheitstafel für x, y, z und G(x, y, z).\n   (Tipp: Sie können Zwischenterme wie (x ∨ ¬y), (x ∨ ¬y) ∧ y, ¬((x ∨ ¬y) ∧ y) einführen.)\n2. Prüfen Sie anhand der Wahrheitstafel, ob G(x, y, z) eine Tautologie ist (also immer 1).\n3. Vereinfachen Sie G(x, y, z) zusätzlich rein algebraisch und begründen Sie damit, ob der Ausdruck allgemeingültig ist oder nicht.\n\nHinweis: Nutzen Sie das in der Vorlesung behandelte Absorptionsgesetz (x ∨ ¬y) ∧ y = x ∧ y.",
    "solution": "1. Algebraische Vorarbeit (zur Vereinfachung der Wahrheitstafel)\n\nZunächst vereinfachen wir den inneren Ausdruck\n\n    (x ∨ ¬y) ∧ y.\n\nNach dem in der Vorlesung behandelten Absorptionsgesetz gilt:\n\n    (x ∨ ¬y) ∧ y = x ∧ y.\n\nDaher wird\n\n    ¬((x ∨ ¬y) ∧ y) = ¬(x ∧ y).\n\nDamit können wir G(x, y, z) umschreiben zu\n\n    G(x, y, z) = (x ∧ y) ∨ ¬(x ∧ y) ∨ z.\n\n2. Wahrheitstafel\n\nWir betrachten alle 8 möglichen Belegungen von x, y, z. Aufgrund der Vereinfachung reicht es, (x ∧ y), ¬(x ∧ y) und G zu bestimmen.\n\nx | y | z | x ∧ y | ¬(x ∧ y) | G(x, y, z) = (x ∧ y) ∨ ¬(x ∧ y) ∨ z\n--|---|---|-------|-----------|------------------------------------\n0 | 0 | 0 |   0   |     1     | 0 ∨ 1 ∨ 0 = 1\n0 | 0 | 1 |   0   |     1     | 0 ∨ 1 ∨ 1 = 1\n0 | 1 | 0 |   0   |     1     | 0 ∨ 1 ∨ 0 = 1\n0 | 1 | 1 |   0   |     1     | 0 ∨ 1 ∨ 1 = 1\n1 | 0 | 0 |   0   |     1     | 0 ∨ 1 ∨ 0 = 1\n1 | 0 | 1 |   0   |     1     | 0 ∨ 1 ∨ 1 = 1\n1 | 1 | 0 |   1   |     0     | 1 ∨ 0 ∨ 0 = 1\n1 | 1 | 1 |   1   |     0     | 1 ∨ 0 ∨ 1 = 1\n\nIn allen Fällen ist G(x, y, z) = 1.\n\n3. Reine algebraische Vereinfachung\n\nAus Schritt 1 wissen wir bereits:\n\n    G(x, y, z) = (x ∧ y) ∨ ¬(x ∧ y) ∨ z.\n\nSchritt 1: Komplementgesetze\n\n    (x ∧ y) ∨ ¬(x ∧ y) = 1.\n\nAlso\n\n    G(x, y, z) = 1 ∨ z.\n\nSchritt 2: Dominanzgesetz\n\n    1 ∨ z = 1.\n\nDamit ergibt sich\n\n    G(x, y, z) ≡ 1.\n\n4. Schlussfolgerung\n\nDa sich G(x, y, z) algebraisch zu 1 vereinfacht und die Wahrheitstafel in allen 8 Fällen G = 1 liefert, ist der Ausdruck G(x, y, z) allgemeingültig (eine Tautologie).",
    "difficulty": "hard",
    "createdAt": "2025-12-04T23:00:08.115Z",
    "completed": false
  }
]